module Graph = struct 
module Sig = struct
#0 "graph/sig.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: sig.mli,v 1.21 2006-05-12 14:07:16 filliatr Exp $ *)

(** {b Signatures for graph implementations.} *)

(** {2 Signatures for graph implementations} *)

(** Signature for vertices. *)
module type VERTEX = sig

  (** Vertices are {!COMPARABLE}. *)

  type t
  val compare : t -> t -> int
  val hash : t -> int
  val equal : t -> t -> bool

  (** Vertices are labeled. *)

  type label
  val create : label -> t
  val label : t -> label

end

(** Signature for edges. *)
module type EDGE = sig

  (** Edges are {!ORDERED_TYPE}. *)

  type t
  val compare : t -> t -> int

  (** Edges are directed. *)

  type vertex

  val src : t -> vertex
    (** Edge origin. *)
  val dst : t -> vertex
    (** Edge destination. *)

  (** Edges are labeled. *)

  type label
  val create : vertex -> label -> vertex -> t
      (** [create v1 l v2] creates an edge from [v1] to [v2] with label [l] *)
  val label : t -> label
    (** Get the label of an edge. *)

end

(** Common signature for all graphs. *)
module type G = sig

  (** {2 Graph structure} *)

  (** Abstract type of graphs *)
  type t

  (** Vertices have type [V.t] and are labeled with type [V.label]
      (note that an implementation may identify the vertex with its
      label) *)
  module V : VERTEX
  type vertex = V.t

  (** Edges have type [E.t] and are labeled with type [E.label].
      [src] (resp. [dst]) returns the origin (resp. the destination) of a
      given edge. *)
  module E : EDGE with type vertex = vertex
  type edge = E.t

  (** Is this an implementation of directed graphs? *)
  val is_directed : bool

  (** {2 Size functions} *)

  val is_empty : t -> bool
  val nb_vertex : t -> int
  val nb_edges : t -> int

  (** Degree of a vertex *)

  val out_degree : t -> vertex -> int
    (** [out_degree g v] returns the out-degree of [v] in [g].
	@raise Invalid_argument if [v] is not in [g]. *)

  val in_degree : t -> vertex -> int
    (** [in_degree g v] returns the in-degree of [v] in [g].
	@raise Invalid_argument if [v] is not in [g]. *)

  (** {2 Membership functions} *)

  val mem_vertex : t -> vertex -> bool
  val mem_edge : t -> vertex -> vertex -> bool
  val mem_edge_e : t -> edge -> bool

  val find_edge : t -> vertex -> vertex -> edge
    (** [find_edge g v1 v2] returns the edge from [v1] to [v2] if it exists.
	Unspecified behaviour if [g] has several edges from [v1] to [v2].
	@raise Not_found if no such edge exists. *)

  (** {2 Successors and predecessors}

      You should better use iterators on successors/predecessors (see
      Section "Vertex iterators"). *)

  val succ : t -> vertex -> vertex list
    (** [succ g v] returns the successors of [v] in [g].
        @raise Invalid_argument if [v] is not in [g]. *)

  val pred : t -> vertex -> vertex list
    (** [pred g v] returns the predecessors of [v] in [g].
        @raise Invalid_argument if [v] is not in [g]. *)

  (** Labeled edges going from/to a vertex *)

  val succ_e : t -> vertex -> edge list
    (** [succ_e g v] returns the edges going from [v] in [g].
        @raise Invalid_argument if [v] is not in [g]. *)

  val pred_e : t -> vertex -> edge list
    (** [pred_e g v] returns the edges going to [v] in [g].
        @raise Invalid_argument if [v] is not in [g]. *)

  (** {2 Graph iterators} *)

  val iter_vertex : (vertex -> unit) -> t -> unit
    (** Iter on all vertices of a graph. *)

  val fold_vertex : (vertex -> 'a -> 'a) -> t  -> 'a -> 'a
    (** Fold on all vertices of a graph. *)

  val iter_edges : (vertex -> vertex -> unit) -> t -> unit
    (** Iter on all edges of a graph. Edge label is ignored. *)

  val fold_edges : (vertex -> vertex -> 'a -> 'a) -> t -> 'a -> 'a
    (** Fold on all edges of a graph. Edge label is ignored. *)

  val iter_edges_e : (edge -> unit) -> t -> unit
    (** Iter on all edges of a graph. *)

  val fold_edges_e : (edge -> 'a -> 'a) -> t -> 'a -> 'a
    (** Fold on all edges of a graph. *)

  val map_vertex : (vertex -> vertex) -> t -> t
    (** Map on all vertices of a graph. *)

  (** {2 Vertex iterators}

      Each iterator [iterator f v g] iters [f] to the successors/predecessors
      of [v] in the graph [g] and raises [Invalid_argument] if [v] is not in
      [g]. It is the same for functions [fold_*] which use an additional
      accumulator.

      <b>Time complexity for ocamlgraph implementations:</b>
      operations on successors are in O(1) amortized for imperative graphs and
      in O(ln(|V|)) for persistent graphs while operations on predecessors are
      in O(max(|V|,|E|)) for imperative graphs and in O(max(|V|,|E|)*ln|V|) for
      persistent graphs. *)

  (** iter/fold on all successors/predecessors of a vertex. *)

  val iter_succ : (vertex -> unit) -> t -> vertex -> unit
  val iter_pred : (vertex -> unit) -> t -> vertex -> unit
  val fold_succ : (vertex -> 'a -> 'a) -> t -> vertex -> 'a -> 'a
  val fold_pred : (vertex -> 'a -> 'a) -> t -> vertex -> 'a -> 'a

  (** iter/fold on all edges going from/to a vertex. *)

  val iter_succ_e : (edge -> unit) -> t -> vertex -> unit
  val fold_succ_e : (edge -> 'a -> 'a) -> t -> vertex -> 'a -> 'a
  val iter_pred_e : (edge -> unit) -> t -> vertex -> unit
  val fold_pred_e : (edge -> 'a -> 'a) -> t -> vertex -> 'a -> 'a

end

(** Signature for persistent (i.e. immutable) graph. *)
module type P = sig

  include G
    (** A persistent graph is a graph. *)

  val empty : t
    (** The empty graph. *)

  val add_vertex : t -> vertex -> t
    (** [add_vertex g v] adds the vertex [v] to the graph [g].
	Just return [g] if [v] is already in [g]. *)

  val remove_vertex : t -> vertex -> t
    (** [remove g v] removes the vertex [v] from the graph [g]
	(and all the edges going from [v] in [g]).
	Just return [g] if [v] is not in [g].

	<b>Time complexity for ocamlgraph implementations:</b>
	O(|V|*ln(|V|)) for unlabeled graphs and
	O(|V|*max(ln(|V|),D)) for labeled graphs.
	D is the maximal degree of the graph. *)

  val add_edge : t -> vertex -> vertex -> t
    (** [add_edge g v1 v2] adds an edge from the vertex [v1] to the vertex [v2]
	in the graph [g].
	Add also [v1] (resp. [v2]) in [g] if [v1] (resp. [v2]) is not in [g].
	Just return [g] if this edge is already in [g]. *)

  val add_edge_e : t -> edge -> t
    (** [add_edge_e g e] adds the edge [e] in the graph [g].
	Add also [E.src e] (resp. [E.dst e]) in [g] if [E.src e] (resp. [E.dst
	e]) is not in [g].
	Just return [g] if [e] is already in [g]. *)

  val remove_edge : t -> vertex -> vertex -> t
    (** [remove_edge g v1 v2] removes the edge going from [v1] to [v2] from the
	graph [g]. If the graph is labelled, all the edges going from [v1] to
	[v2] are removed from [g].
	Just return [g] if this edge is not in [g].
	@raise Invalid_argument if [v1] or [v2] are not in [g]. *)

  val remove_edge_e : t -> edge -> t
    (** [remove_edge_e g e] removes the edge [e] from the graph [g].
	Just return [g] if [e] is not in [g].
	@raise Invalid_argument if [E.src e] or [E.dst e] are not in [g]. *)

end

(** Signature for imperative (i.e. mutable) graphs. *)
module type I = sig

  include G
    (** An imperative graph is a graph. *)

  val create : ?size:int -> unit -> t
    (** [create ()] returns an empty graph. Optionally, a size can be
        given, which should be on the order of the expected number of
        vertices that will be in the graph (for hash tables-based
        implementations).  The graph grows as needed, so [size] is
        just an initial guess. *)

  val clear: t -> unit
    (** Remove all vertices and edges from the given graph.
	@since ocamlgraph 1.4 *)

  val copy : t -> t
    (** [copy g] returns a copy of [g]. Vertices and edges (and eventually
	marks, see module [Mark]) are duplicated. *)

  val add_vertex : t -> vertex -> unit
    (** [add_vertex g v] adds the vertex [v] to the graph [g].
	Do nothing if [v] is already in [g]. *)

  val remove_vertex : t -> vertex -> unit
    (** [remove g v] removes the vertex [v] from the graph [g]
	(and all the edges going from [v] in [g]).
	Do nothing if [v] is not in [g].

	<b>Time complexity for ocamlgraph implementations:</b>
	O(|V|*ln(D)) for unlabeled graphs and O(|V|*D)	for
	labeled graphs. D is the maximal degree of the graph. *)

  val add_edge : t -> vertex -> vertex -> unit
    (** [add_edge g v1 v2] adds an edge from the vertex [v1] to the vertex [v2]
	in the graph [g].
	Add also [v1] (resp. [v2]) in [g] if [v1] (resp. [v2]) is not in [g].
	Do nothing if this edge is already in [g]. *)

  val add_edge_e : t -> edge -> unit
    (** [add_edge_e g e] adds the edge [e] in the graph [g].
	Add also [E.src e] (resp. [E.dst e]) in [g] if [E.src e] (resp. [E.dst
	e]) is not in [g].
	Do nothing if [e] is already in [g]. *)

  val remove_edge : t -> vertex -> vertex -> unit
    (** [remove_edge g v1 v2] removes the edge going from [v1] to [v2] from the
	graph [g]. If the graph is labelled, all the edges going from [v1] to
	[v2] are removed from [g].
	Do nothing if this edge is not in [g].
	@raise Invalid_argument if [v1] or [v2] are not in [g]. *)

  val remove_edge_e : t -> edge -> unit
    (** [remove_edge_e g e] removes the edge [e] from the graph [g].
	Do nothing if [e] is not in [g].
	@raise Invalid_argument if [E.src e] or [E.dst e] are not in [g]. *)

end

(** Signature for marks on vertices. *)
module type MARK = sig
  type graph
    (** Type of graphs. *)
  type vertex
    (** Type of graph vertices. *)
  val clear : graph -> unit
      (** [clear g] sets all the marks to 0 for all the vertices of [g]. *)
  val get : vertex -> int
    (** Mark value (in O(1)). *)
  val set : vertex -> int -> unit
    (** Set the mark of the given vertex. *)
end

(** Signature for imperative graphs with marks on vertices. *)
module type IM = sig
  include I
    (** An imperative graph with marks is an imperative graph. *)

  (** Mark on vertices.
      Marks can be used if you want to store some information on vertices:
      it is more efficient to use marks than an external table. *)
  module Mark : MARK with type graph = t and type vertex = vertex
end

(** {2 Signature for ordered and hashable types} *)

(** Signature with only an abstract type. *)
module type ANY_TYPE = sig type t end

(** Signature equivalent to [Set.OrderedType]. *)
module type ORDERED_TYPE = sig type t val compare : t -> t -> int end

(** Signature equivalent to [Set.OrderedType] with a default value. *)
module type ORDERED_TYPE_DFT = sig include ORDERED_TYPE val default : t end

(** Signature equivalent to [Hashtbl.HashedType]. *)
module type HASHABLE = sig
  type t
  val hash : t -> int
  val equal : t -> t -> bool
end

(** Signature merging {!ORDERED_TYPE} and {!HASHABLE}. *)
module type COMPARABLE = sig
  type t
  val compare : t -> t -> int
  val hash : t -> int
  val equal : t -> t -> bool
end
end
module Sig_pack = struct
#0 "graph/sig_pack.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: sig_pack.mli,v 1.23 2005-07-18 07:10:35 filliatr Exp $ *)

(** Immediate access to the library: contain a signature gathering an
    imperative graph signature and all algorithms.
    Vertices and edges are labeled with integers. *)

(** Signature gathering an imperative graph signature and all algorithms. 
    Vertices and edges are labeled with integers. *)
module type S = sig

  (** {2 Graph structure} *)

  (** abstract type of graphs *)
  type t

  (** Vertices *)
  module V : sig
    (** Vertices are [COMPARABLE] *)

    type t 
    val compare : t -> t -> int 
    val hash : t -> int 
    val equal : t -> t -> bool

    (** vertices are labeled with integers *)

    type label = int
    val create : label -> t
    val label : t -> label
  end

  type vertex = V.t

  (** Edges *)
  module E : sig
    (** Edges are [ORDERED]. *)

    type t
    val compare : t -> t -> int

    (** Edges are directed. *)

    val src : t -> V.t
    val dst : t -> V.t

    (** Edges are labeled with integers. *)

    type label = int
    val create : V.t -> label -> V.t -> t
      (** [create v1 l v2] creates an edge from [v1] to [v2] with label [l] *)
    val label : t -> label

    type vertex = V.t
  end

  type edge = E.t

  (** is this an implementation of directed graphs? *)
  val is_directed : bool

  (** {2 Graph constructors and destructors} *)

  val create : ?size:int -> unit -> t
    (** Return an empty graph. Optionally, a size can be
        given, which should be on the order of the expected number of
        vertices that will be in the graph (for hash tables-based
        implementations).  The graph grows as needed, so [size] is
        just an initial guess. *)

  val clear: t -> unit
    (** Remove all vertices and edges from the given graph. 
	@since ocamlgraph 1.4 *)

  val copy : t -> t
    (** [copy g] returns a copy of [g]. Vertices and edges (and eventually
      marks, see module [Mark]) are duplicated. *)

  val add_vertex : t -> V.t -> unit
    (** [add_vertex g v] adds the vertex [v] from the graph [g].
      Do nothing if [v] is already in [g]. *)

  val remove_vertex : t -> V.t -> unit
    (** [remove g v] removes the vertex [v] from the graph [g] 
      (and all the edges going from [v] in [g]).
      Do nothing if [v] is not in [g]. *)

  val add_edge : t -> V.t -> V.t -> unit
    (** [add_edge g v1 v2] adds an edge from the vertex [v1] to the vertex [v2]
      in the graph [g]. 
      Add also [v1] (resp. [v2]) in [g] if [v1] (resp. [v2]) is not in [g]. 
      Do nothing if this edge is already in [g]. *) 

  val add_edge_e : t -> E.t -> unit
    (** [add_edge_e g e] adds the edge [e] in the graph [g].
      Add also [E.src e] (resp. [E.dst e]) in [g] if [E.src e] (resp. [E.dst
      e]) is not in [g]. 
      Do nothing if [e] is already in [g]. *)

  val remove_edge : t -> V.t -> V.t -> unit
    (** [remove_edge g v1 v2] removes the edge going from [v1] to [v2] from the
      graph [g].
      Do nothing if this edge is not in [g].
      @raise Invalid_argument if [v1] or [v2] are not in [g]. *)

  val remove_edge_e : t -> E.t -> unit
    (** [remove_edge_e g e] removes the edge [e] from the graph [g].
      Do nothing if [e] is not in [g].
      @raise Invalid_argument if [E.src e] or [E.dst e] are not in [g]. *)

  (** Vertices contains integers marks, which can be set or used by some 
      algorithms (see for instance module [Marking] below) *)
  module Mark : sig
    type graph = t
    type vertex = V.t
    val clear : t -> unit
      (** [clear g] sets all marks to 0 from all the vertives of [g]. *)
    val get : V.t -> int
    val set : V.t -> int -> unit
  end

  (** {2 Size functions} *)

  val is_empty : t -> bool
  val nb_vertex : t -> int
  val nb_edges : t -> int

  (** Degree of a vertex *)

  val out_degree : t -> V.t -> int
    (** [out_degree g v] returns the out-degree of [v] in [g].
      @raise Invalid_argument if [v] is not in [g]. *)

  val in_degree : t -> V.t -> int
    (** [in_degree g v] returns the in-degree of [v] in [g].
      @raise Invalid_argument if [v] is not in [g]. *)

  (** {2 Membership functions} *)

  val mem_vertex : t -> V.t -> bool
  val mem_edge : t -> V.t -> V.t -> bool
  val mem_edge_e : t -> E.t -> bool
  val find_edge : t -> V.t -> V.t -> E.t

  (** {2 Successors and predecessors of a vertex} *)

  val succ : t -> V.t -> V.t list
    (** [succ g v] returns the successors of [v] in [g].
        @raise Invalid_argument if [v] is not in [g]. *)

  val pred : t -> V.t -> V.t list
    (** [pred g v] returns the predecessors of [v] in [g].
        @raise Invalid_argument if [v] is not in [g]. *)

  (** Labeled edges going from/to a vertex *)

  val succ_e : t -> V.t -> E.t list
    (** [succ_e g v] returns the edges going from [v] in [g].
        @raise Invalid_argument if [v] is not in [g]. *)

  val pred_e : t -> V.t -> E.t list
    (** [pred_e g v] returns the edges going to [v] in [g].
        @raise Invalid_argument if [v] is not in [g]. *)

  (** {2 Graph iterators} *)

  (** iter/fold on all vertices/edges of a graph *)

  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_edges : (V.t -> V.t -> unit) -> t -> unit
  val fold_vertex : (V.t -> 'a -> 'a) -> t  -> 'a -> 'a
  val fold_edges : (V.t -> V.t -> 'a -> 'a) -> t -> 'a -> 'a

  (** map iterator on vertex *)
  val map_vertex : (V.t -> V.t) -> t -> t

  (** iter/fold on all labeled edges of a graph *)

  val iter_edges_e : (E.t -> unit) -> t -> unit
  val fold_edges_e : (E.t -> 'a -> 'a) -> t -> 'a -> 'a

  (** {2 Vertex iterators}

    Each iterator [iterator f v g] iters [f] to the successors/predecessors
    of [v] in the graph [g] and raises [Invalid_argument] if [v] is not in
    [g]. *)

  (** iter/fold on all successors/predecessors of a vertex. *)

  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
  val iter_pred : (V.t -> unit) -> t -> V.t -> unit
  val fold_succ : (V.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
  val fold_pred : (V.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a

  (** iter/fold on all edges going from/to a vertex. *)

  val iter_succ_e : (E.t -> unit) -> t -> V.t -> unit
  val fold_succ_e : (E.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
  val iter_pred_e : (E.t -> unit) -> t -> V.t -> unit
  val fold_pred_e : (E.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a

  (** {2 Basic operations} *)

  val find_vertex : t -> int -> V.t
    (** [vertex g i] returns a vertex of label [i] in [g]. The behaviour is
      unspecified if [g] has several vertices with label [i]. 
      Note: this function is inefficient (linear in the number of vertices);
      you should better keep the vertices as long as you create them. *)

  val transitive_closure : ?reflexive:bool -> t -> t
    (** [transitive_closure ?reflexive g] returns the transitive closure 
      of [g] (as a new graph). Loops (i.e. edges from a vertex to itself) 
      are added only if [reflexive] is [true] (default is [false]). *)

  val add_transitive_closure : ?reflexive:bool -> t -> t
    (** [add_transitive_closure ?reflexive g] replaces [g] by its
      transitive closure. Meaningless for persistent implementations
      (then acts as [transitive_closure]). *)

  val mirror : t -> t
    (** [mirror g] returns a new graph which is the mirror image of [g]:
      each edge from [u] to [v] has been replaced by an edge from [v] to [u].
      For undirected graphs, it simply returns a copy of [g]. *)

  val complement : t -> t
    (** [complement g] builds a new graph which is the complement of [g]:
      each edge present in [g] is not present in the resulting graph and
      vice-versa. Edges of the returned graph are unlabeled. *)

  val intersect : t -> t -> t
    (** [intersect g1 g2] returns a new graph which is the intersection of [g1]
      and [g2]: each vertex and edge present in [g1] *and* [g2] is present 
      in the resulting graph. *)

  val union : t -> t -> t
    (** [union g1 g2] returns a new graph which is the union of [g1] and [g2]:
      each vertex and edge present in [g1] *or* [g2] is present in the 
      resulting graph. *)

  (** {2 Traversal} *)

  (** Depth-first search *)
  module Dfs : sig
    val iter : ?pre:(V.t -> unit) -> 
               ?post:(V.t -> unit) -> t -> unit
      (** [iter pre post g] visits all nodes of [g] in depth-first search, 
	  applying [pre] to each visited node before its successors,
	  and [post] after them. Each node is visited exactly once. *)
    val prefix : (V.t -> unit) -> t -> unit
      (** applies only a prefix function *)
    val postfix : (V.t -> unit) -> t -> unit
      (** applies only a postfix function *)

    (** Same thing, but for a single connected component *)

    val iter_component : 
               ?pre:(V.t -> unit) -> 
               ?post:(V.t -> unit) -> t -> V.t -> unit
    val prefix_component : (V.t -> unit) -> t -> V.t -> unit
    val postfix_component : (V.t -> unit) -> t -> V.t -> unit

    val has_cycle : t -> bool
  end

  (** Breadth-first search *)
  module Bfs : sig
    val iter : (V.t -> unit) -> t -> unit
    val iter_component : (V.t -> unit) -> t -> V.t -> unit
  end

  (** Graph traversal with marking *)
  module Marking : sig
    val dfs : t -> unit
    val has_cycle : t -> bool
  end

  (** {2 Graph generators} *)

  (** Classic graphs *)
  module Classic : sig
    val divisors : int -> t
      (** [divisors n] builds the graph of divisors. 
	Vertices are integers from [2] to [n]. [i] is connected to [j] if
        and only if [i] divides [j]. 
	@raise Invalid_argument is [n < 2]. *)

    val de_bruijn : int -> t
      (** [de_bruijn n] builds the de Bruijn graph of order [n].
	Vertices are bit sequences of length [n] (encoded as their
	interpretation as binary integers). The sequence [xw] is connected
	to the sequence [wy] for any bits [x] and [y] and any bit sequence 
        [w] of length [n-1]. 
	@raise Invalid_argument is [n < 1] or [n > Sys.word_size-1]. *)

    val vertex_only : int -> t
      (** [vertex_only n] builds a graph with [n] vertices and no edge. *)

    val full : ?self:bool -> int -> t
      (** [full n] builds a graph with [n] vertices and all possible edges.
	The optional argument [self] indicates if loop edges should be added
        (default value is [true]). *)
  end

  (** Random graphs *)
  module Rand : sig
    val graph : ?loops:bool -> v:int -> e:int -> unit -> t
      (** [random v e] generates a random with [v] vertices and [e] edges. *)

    val labeled : 
      (V.t -> V.t -> E.label) -> 
	?loops:bool -> v:int -> e:int -> unit -> t
	  (** [random_labeled f] is similar to [random] except that edges are 
            labeled using function [f] *)
  end

  (** Strongly connected components *)
  module Components : sig
    val scc : t -> int*(V.t -> int)
	(** strongly connected components *)
    val scc_array : t -> V.t list array
    val scc_list : t -> V.t list list
  end

  (** {2 Classical algorithms} *)

  val shortest_path : t -> V.t -> V.t -> E.t list * int
    (** Dijkstra's shortest path algorithm. Weights are the labels. *)

  val ford_fulkerson : t -> V.t -> V.t -> (E.t -> int) * int
    (** Ford Fulkerson maximum flow algorithm *)

  val goldberg : t -> V.t -> V.t -> (E.t -> int) * int
    (** Goldberg maximum flow algorithm *)

  (** Path checking *)
  module PathCheck : sig
    type path_checker
    val create : t -> path_checker
    val check_path : path_checker -> V.t -> V.t -> bool
  end

  (** Topological order *)
  module Topological : sig
    val fold : (V.t -> 'a -> 'a) -> t -> 'a -> 'a
    val iter : (V.t -> unit) -> t -> unit
  end

  val spanningtree : t -> E.t list
    (** Kruskal algorithm *)

  (** {2 Input / Output} *)

  val dot_output : t -> string -> unit 
    (** DOT output *)

  val display_with_gv : t -> unit
    (** Displays the given graph using the external tools "dot" and "gv"
        and returns when gv's window is closed *)

  val parse_gml_file : string -> t
  val parse_dot_file : string -> t

  val print_gml_file : t -> string -> unit

end
end
module Dot_ast = struct
#0 "graph/dot_ast.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id:$ *)

(** AST for DOT file format. *)

type id = 
  | Ident of string
  | Number of string
  | String of string
  | Html of string

type attr = (id * id option) list

type compass_pt = N | Ne | E | Se | S | Sw | W | Nw

type port = 
  | PortId of id * compass_pt option
  | PortC of compass_pt

type node_id = id * port option

type subgraph = 
  | SubgraphId of id
  | SubgraphDef of id option * stmt list

and node =
  | NodeId of node_id
  | NodeSub of subgraph

and stmt = 
  | Node_stmt of node_id * attr list
  | Edge_stmt of node * node list * attr list
  | Attr_graph of attr list
  | Attr_node of attr list
  | Attr_edge of attr list
  | Equal of id * id
  | Subgraph of subgraph

type file =
  { strict : bool;
    digraph : bool;
    id : id option;
    stmts : stmt list }
end
module Unionfind: sig
#0 "graph/unionfind.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)



(* Unionfind structure over hash-ordered types.

   This module implements a unionfind data structure, given a total ordering
   function and a hash function over the elements. 

*)


module type HashedOrderedType = sig
  (* The type of the elements*)
  type t
  val equal : t -> t -> bool
  val hash : t -> int 
  val compare : t -> t -> int 
end

(* Input signature of the functor Unionfind.Make *)

module type S = sig
  type elt
  type t
    
  val init : elt list -> t
  val find : elt -> t -> elt
  val union : elt -> elt -> t -> unit
end

module Make (X : HashedOrderedType) : S with type elt = X.t


end = struct
#0 "graph/unionfind.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id$ *)

module type HashedOrderedType = sig
  type t
  val equal : t -> t -> bool
  val hash : t -> int 
  val compare : t -> t -> int 
end

module type S = sig
  type elt
  type t
    
  val init : elt list -> t
  val find : elt -> t -> elt
  val union : elt -> elt -> t -> unit
end

module Make(X:HashedOrderedType) = struct

  type elt = X.t

  module H = Hashtbl.Make(X)
  
  type cell = {
    mutable c : int;
    data : elt;
    mutable father : cell
  }
  
  type t = cell H.t (* a forest *)

  let init l = 
    let h = H.create 997 in
    List.iter 
      (fun x ->
         let rec cell = { c = 0; data = x; father = cell } in 
	 H.add h x cell) 
      l;
    h

  let rec find_aux cell = 
    if cell.father == cell then 
      cell
    else 
      let r = find_aux cell.father in 
      cell.father <- r; 
      r

  let find x h = (find_aux (H.find h x)).data

  let union x y h = 
    let rx = find_aux (H.find h x) in
    let ry = find_aux (H.find h y) in
    if rx != ry then begin
      if rx.c > ry.c then
        ry.father <- rx
      else if rx.c < ry.c then
        rx.father <- ry
      else begin
        rx.c <- rx.c + 1;
        ry.father <- rx
      end
    end
end

(*** test ***)
(***

module M = Make (struct 
        type t = int let 
        hash = Hashtbl.hash 
        let compare = compare 
        let equal = (=) 
    end)

open Printf

let saisir s  = 
        printf "%s = " s; flush stdout;
        let x = read_int () in
        x

let h = M.init [0;1;2;3;4;5;6;7;8;9] 
let () = if not !Sys.interactive then 
    while true do 
        printf "1) find\n2) union\n";
        match read_int () with
            1 -> begin
                let x = saisir "x" in
                printf "%d\n" (M.find x h) 
            end
          | 2 -> begin
                let x, y = saisir "x", saisir "y" in
                M.union x y h
            end
          | _ -> ()
    done

***)
end
module Heap: sig
#0 "graph/heap.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)


module type Ordered = sig
  type t
  val compare : t -> t -> int
end

exception EmptyHeap

(*S Imperative implementation. *)

module Imperative(X: Ordered) : sig

  (* Type of imperative heaps.
     (In the following [n] refers to the number of elements in the heap) *)

  type t 

  (* [create c] creates a new heap, with initial capacity of [c] *)
  val create : int -> t

  (* [is_empty h] checks the emptiness of [h] *)
  val is_empty : t -> bool

  (* [add x h] adds a new element [x] in heap [h]; size of [h] is doubled
     when maximum capacity is reached; complexity $O(log(n))$ *)
  val add : t -> X.t -> unit

  (* [maximum h] returns the maximum element of [h]; raises [EmptyHeap]
     when [h] is empty; complexity $O(1)$ *)
  val maximum : t -> X.t

  (* [remove h] removes the maximum element of [h]; raises [EmptyHeap]
     when [h] is empty; complexity $O(log(n))$ *)
  val remove : t -> unit

  (* [pop_maximum h] removes the maximum element of [h] and returns it;
     raises [EmptyHeap] when [h] is empty; complexity $O(log(n))$ *)
  val pop_maximum : t -> X.t

  (* usual iterators and combinators; elements are presented in
     arbitrary order *)
  val iter : (X.t -> unit) -> t -> unit

  val fold : (X.t -> 'a -> 'a) -> t -> 'a -> 'a

end

(*S Functional implementation. *)

module type FunctionalSig = sig

  (* heap elements *)
  type elt

  (* Type of functional heaps *)
  type t

  (* The empty heap *)
  val empty : t

  (* [add x h] returns a new heap containing the elements of [h], plus [x];
     complexity $O(log(n))$ *)
  val add : elt -> t -> t

  (* [maximum h] returns the maximum element of [h]; raises [EmptyHeap]
     when [h] is empty; complexity $O(1)$ *)
  val maximum : t -> elt

  (* [remove h] returns a new heap containing the elements of [h], except
     the maximum of [h]; raises [EmptyHeap] when [h] is empty; 
     complexity $O(log(n))$ *) 
  val remove : t -> t

  (* usual iterators and combinators; elements are presented in
     arbitrary order *)
  val iter : (elt -> unit) -> t -> unit

  val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a

end

module Functional(X: Ordered) : FunctionalSig with type elt = X.t
end = struct
#0 "graph/heap.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id:$ *)

module type Ordered = sig
  type t
  val compare : t -> t -> int
end

exception EmptyHeap

(*s Imperative implementation *)

module Imperative(X : Ordered) = struct

  (* The heap is encoded in the array [data], where elements are stored
     from [0] to [size - 1]. From an element stored at [i], the left 
     (resp. right) subtree, if any, is rooted at [2*i+1] (resp. [2*i+2]). *)

  type t = { mutable size : int; mutable data : X.t array }

  (* When [create n] is called, we cannot allocate the array, since there is
     no known value of type [X.t]; we'll wait for the first addition to 
     do it, and we remember this situation with a negative size. *)

  let create n = 
    if n <= 0 then invalid_arg "create";
    { size = -n; data = [||] }

  let is_empty h = h.size <= 0

  (* [resize] doubles the size of [data] *)

  let resize h =
    let n = h.size in
    assert (n > 0);
    let n' = 2 * n in
    let d = h.data in
    let d' = Array.create n' d.(0) in
    Array.blit d 0 d' 0 n;
    h.data <- d'

  let add h x =
    (* first addition: we allocate the array *)
    if h.size < 0 then begin
      h.data <- Array.create (- h.size) x; h.size <- 0
    end;
    let n = h.size in
    (* resizing if needed *)
    if n == Array.length h.data then resize h;
    let d = h.data in
    (* moving [x] up in the heap *)
    let rec moveup i =
      let fi = (i - 1) / 2 in
      if i > 0 && X.compare d.(fi) x < 0 then begin
	d.(i) <- d.(fi);
	moveup fi
      end else
	d.(i) <- x
    in
    moveup n;
    h.size <- n + 1

  let maximum h =
    if h.size <= 0 then raise EmptyHeap;
    h.data.(0)

  let remove h =
    if h.size <= 0 then raise EmptyHeap;
    let n = h.size - 1 in
    h.size <- n;
    let d = h.data in
    let x = d.(n) in
    (* moving [x] down in the heap *)
    let rec movedown i =
      let j = 2 * i + 1 in
      if j < n then
	let j = 
	  let j' = j + 1 in 
	  if j' < n && X.compare d.(j') d.(j) > 0 then j' else j 
	in
	if X.compare d.(j) x > 0 then begin 
	  d.(i) <- d.(j); 
	  movedown j 
	end else
	  d.(i) <- x
      else
	d.(i) <- x
    in
    movedown 0

  let pop_maximum h = let m = maximum h in remove h; m

  let iter f h = 
    let d = h.data in
    for i = 0 to h.size - 1 do f d.(i) done

  let fold f h x0 =
    let n = h.size in
    let d = h.data in
    let rec foldrec x i =
      if i >= n then x else foldrec (f d.(i) x) (succ i)
    in
    foldrec x0 0

end


(*s Functional implementation *)

module type FunctionalSig = sig
  type elt
  type t
  val empty : t
  val add : elt -> t -> t
  val maximum : t -> elt
  val remove : t -> t
  val iter : (elt -> unit) -> t -> unit
  val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
end

module Functional(X : Ordered) = struct

  (* Heaps are encoded as complete binary trees, i.e., binary trees
     which are full expect, may be, on the bottom level where it is filled 
     from the left. 
     These trees also enjoy the heap property, namely the value of any node 
     is greater or equal than those of its left and right subtrees.

     There are 4 kinds of complete binary trees, denoted by 4 constructors:
     [FFF] for a full binary tree (and thus 2 full subtrees);
     [PPF] for a partial tree with a partial left subtree and a full
     right subtree;
     [PFF] for a partial tree with a full left subtree and a full right subtree
     (but of different heights);
     and [PFP] for a partial tree with a full left subtree and a partial
     right subtree. *)

  type elt = X.t

  type t = 
    | Empty
    | FFF of t * X.t * t (* full    (full,    full) *)
    | PPF of t * X.t * t (* partial (partial, full) *)
    | PFF of t * X.t * t (* partial (full,    full) *)
    | PFP of t * X.t * t (* partial (full,    partial) *)

  let empty = Empty
 
  (* smart constructors for insertion *)
  let p_f l x r = match l with
    | Empty | FFF _ -> PFF (l, x, r)
    | _ -> PPF (l, x, r)

  let pf_ l x = function
    | Empty | FFF _ as r -> FFF (l, x, r)
    | r -> PFP (l, x, r)

  let rec add x = function
    | Empty -> 
	FFF (Empty, x, Empty)
    (* insertion to the left *)
    | FFF (l, y, r) | PPF (l, y, r) ->
	if X.compare x y > 0 then p_f (add y l) x r else p_f (add x l) y r
    (* insertion to the right *)
    | PFF (l, y, r) | PFP (l, y, r) ->
	if X.compare x y > 0 then pf_ l x (add y r) else pf_ l y (add x r)

  let maximum = function
    | Empty -> raise EmptyHeap
    | FFF (_, x, _) | PPF (_, x, _) | PFF (_, x, _) | PFP (_, x, _) -> x

  (* smart constructors for removal; note that they are different
     from the ones for insertion! *)
  let p_f l x r = match l with
    | Empty | FFF _ -> FFF (l, x, r)
    | _ -> PPF (l, x, r)

  let pf_ l x = function
    | Empty | FFF _ as r -> PFF (l, x, r)
    | r -> PFP (l, x, r)

  let rec remove = function
    | Empty -> 
	raise EmptyHeap
    | FFF (Empty, _, Empty) -> 
	Empty
    | PFF (l, _, Empty) ->
	l
    (* remove on the left *)
    | PPF (l, x, r) | PFF (l, x, r) ->
        let xl = maximum l in
	let xr = maximum r in
	let l' = remove l in
	if X.compare xl xr >= 0 then 
	  p_f l' xl r 
	else 
	  p_f l' xr (add xl (remove r))
    (* remove on the right *)
    | FFF (l, x, r) | PFP (l, x, r) ->
        let xl = maximum l in
	let xr = maximum r in
	let r' = remove r in
	if X.compare xl xr > 0 then 
	  pf_ (add xr (remove l)) xl r'
	else 
	  pf_ l xr r'

  let rec iter f = function
    | Empty -> 
	()
    | FFF (l, x, r) | PPF (l, x, r) | PFF (l, x, r) | PFP (l, x, r) -> 
	iter f l; f x; iter f r

  let rec fold f h x0 = match h with
    | Empty -> 
	x0
    | FFF (l, x, r) | PPF (l, x, r) | PFF (l, x, r) | PFP (l, x, r) -> 
	fold f l (fold f r (f x x0))

end
end
module Bitv: sig
#0 "graph/bitv.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(*s {\bf Module Bitv}.
    This module implements bit vectors, as an abstract datatype [t]. 
    Since bit vectors are particular cases of arrays, this module provides
    the same operations as the module [Array] (Sections~\ref{barray} 
    up to \ref{earray}). It also provides bitwise operations 
    (Section~\ref{bitwise}). In the following, [false] stands for the bit 0 
    and [true] for the bit 1. *)

type t

(*s {\bf Creation, access and assignment.} \label{barray}
    [(Bitv.create n b)] creates a new bit vector of length [n],
    initialized with [b].
    [(Bitv.init n f)] returns a fresh vector of length [n],
    with bit number [i] initialized to the result of [(f i)]. 
    [(Bitv.set v n b)] sets the [n]th bit of [v] to the value [b].
    [(Bitv.get v n)] returns the [n]th bit of [v]. 
    [Bitv.length] returns the length (number of elements) of the given 
    vector. *)

val create : int -> bool -> t

val init : int -> (int -> bool) -> t

val set : t -> int -> bool -> unit
    
val get : t -> int -> bool

val length : t -> int

(*s [max_length] is the maximum length of a bit vector (System dependent). *)

val max_length : int

(*s {\bf Copies and concatenations.}
   [(Bitv.copy v)] returns a copy of [v],
   that is, a fresh vector containing the same elements as
   [v]. [(Bitv.append v1 v2)] returns a fresh vector containing the
   concatenation of the vectors [v1] and [v2]. [Bitv.concat] is
   similar to [Bitv.append], but catenates a list of vectors. *)

val copy : t -> t

val append : t -> t -> t

val concat : t list -> t

(*s {\bf Sub-vectors and filling.} 
    [(Bitv.sub v start len)] returns a fresh
    vector of length [len], containing the bits number [start] to
    [start + len - 1] of vector [v].  Raise [Invalid_argument
    "Bitv.sub"] if [start] and [len] do not designate a valid
    subvector of [v]; that is, if [start < 0], or [len < 0], or [start
    + len > Bitv.length a].

    [(Bitv.fill v ofs len b)] modifies the vector [v] in place,
    storing [b] in elements number [ofs] to [ofs + len - 1].  Raise
    [Invalid_argument "Bitv.fill"] if [ofs] and [len] do not designate
    a valid subvector of [v].

    [(Bitv.blit v1 o1 v2 o2 len)] copies [len] elements from vector
    [v1], starting at element number [o1], to vector [v2], starting at
    element number [o2]. It {\em does not work} correctly if [v1] and [v2] are
    the same vector with the source and destination chunks overlapping.
    Raise [Invalid_argument "Bitv.blit"] if [o1] and [len] do not
    designate a valid subvector of [v1], or if [o2] and [len] do not
    designate a valid subvector of [v2]. *)

val sub : t -> int -> int -> t

val fill : t -> int -> int -> bool -> unit

val blit : t -> int -> t -> int -> int -> unit

(*s {\bf Iterators.} \label{earray}
    [(Bitv.iter f v)] applies function [f] in turn to all
    the elements of [v]. Given a function [f], [(Bitv.map f v)] applies
    [f] to all
    the elements of [v], and builds a vector with the results returned
    by [f]. [Bitv.iteri] and [Bitv.mapi] are similar to [Bitv.iter]
    and [Bitv.map] respectively, but the function is applied to the
    index of the element as first argument, and the element itself as
    second argument.

    [(Bitv.fold_left f x v)] computes [f (... (f (f x (get v 0)) (get
    v 1)) ...) (get v (n-1))], where [n] is the length of the vector
    [v]. 

    [(Bitv.fold_right f a x)] computes [f (get v 0) (f (get v 1)
    ( ... (f (get v (n-1)) x) ...))], where [n] is the length of the
    vector [v]. *)

val iter : (bool -> unit) -> t -> unit
val map : (bool -> bool) -> t -> t

val iteri : (int -> bool -> unit) -> t -> unit
val mapi : (int -> bool -> bool) -> t -> t

val fold_left : ('a -> bool -> 'a) -> 'a -> t -> 'a
val fold_right : (bool -> 'a -> 'a) -> t -> 'a -> 'a
val foldi_left : ('a -> int -> bool -> 'a) -> 'a -> t -> 'a
val foldi_right : (int -> bool -> 'a -> 'a) -> t -> 'a -> 'a

(*s [gray_iter f n] iterates function [f] on all bit vectors
    of length [n], once each, using a Gray code. The order in which
    bit vectors are processed is unspecified. *)

val gray_iter : (t -> unit) -> int -> unit

(*s {\bf Bitwise operations.} \label{bitwise} [bwand], [bwor] and
    [bwxor] implement logical and, or and exclusive or.  They return
    fresh vectors and raise [Invalid_argument "Bitv.xxx"] if the two
    vectors do not have the same length (where \texttt{xxx} is the
    name of the function).  [bwnot] implements the logical negation. 
    It returns a fresh vector.
    [shiftl] and [shiftr] implement shifts. They return fresh vectors.
    [shiftl] moves bits from least to most significant, and [shiftr]
    from most to least significant (think [lsl] and [lsr]).
    [all_zeros] and [all_ones] respectively test for a vector only
    containing zeros and only containing ones. *)

val bw_and : t -> t -> t
val bw_or  : t -> t -> t
val bw_xor : t -> t -> t
val bw_not : t -> t

val shiftl : t -> int -> t
val shiftr : t -> int -> t

val all_zeros : t -> bool
val all_ones  : t -> bool

(*s {\bf Conversions to and from strings.} 
    Least significant bit comes first. *)

val to_string : t -> string
val of_string : string -> t
val print : Format.formatter -> t -> unit

(*s {\bf Conversions to and from lists of integers.} 
    The list gives the indices of bits which are set (ie [true]). *)

val to_list : t -> int list
val of_list : int list -> t
val of_list_with_length : int list -> int -> t

(*s Interpretation of bit vectors as integers. Least significant bit 
    comes first (ie is at index 0 in the bit vector). 
    [to_xxx] functions truncate when the bit vector is too wide, 
    and raise [Invalid_argument] when it is too short. 
    Suffix [_s] indicates that sign bit is kept, 
    and [_us] that it is discarded. *) 

(* type [int] (length 31/63 with sign, 30/62 without) *)
val of_int_s : int -> t
val to_int_s : t -> int
val of_int_us : int -> t
val to_int_us : t -> int
(* type [Int32.t] (length 32 with sign, 31 without) *)
val of_int32_s : Int32.t -> t
val to_int32_s : t -> Int32.t
val of_int32_us : Int32.t -> t
val to_int32_us : t -> Int32.t
(* type [Int64.t] (length 64 with sign, 63 without) *)
val of_int64_s : Int64.t -> t
val to_int64_s : t -> Int64.t
val of_int64_us : Int64.t -> t
val to_int64_us : t -> Int64.t
(* type [Nativeint.t] (length 32/64 with sign, 31/63 without) *)
val of_nativeint_s : Nativeint.t -> t
val to_nativeint_s : t -> Nativeint.t
val of_nativeint_us : Nativeint.t -> t
val to_nativeint_us : t -> Nativeint.t

(*s Only if you know what you are doing... *)

val unsafe_set : t -> int -> bool -> unit
val unsafe_get : t -> int -> bool
end = struct
#0 "graph/bitv.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(*i $Id: bitv.ml,v 1.18 2008/04/01 09:59:03 filliatr Exp $ i*)

(*s Bit vectors. The interface and part of the code are borrowed from the 
    [Array] module of the ocaml standard library (but things are simplified
    here since we can always initialize a bit vector). This module also
    provides bitwise operations. *)

(*s We represent a bit vector by a vector of integers (field [bits]),
    and we keep the information of the size of the bit vector since it
    can not be found out with the size of the array (field [length]). *)

type t = {
  length : int;
  bits   : int array }

let length v = v.length

(*s Each element of the array is an integer containing [bpi] bits, where
    [bpi] is determined according to the machine word size. Since we do not
    use the sign bit, [bpi] is 30 on a 32-bits machine and 62 on a 64-bits
    machines. We maintain the following invariant:
    {\em The unused bits of the last integer are always 
    zeros.} This is ensured by [create] and maintained in other functions
    using [normalize]. [bit_j], [bit_not_j], [low_mask] and [up_mask]
    are arrays used to extract and mask bits in a single integer. *)

let bpi = Sys.word_size - 2

let max_length = Sys.max_array_length * bpi

let bit_j = Array.init bpi (fun j -> 1 lsl j)
let bit_not_j = Array.init bpi (fun j -> max_int - bit_j.(j))

let low_mask = Array.create (succ bpi) 0
let _ = 
  for i = 1 to bpi do low_mask.(i) <- low_mask.(i-1) lor bit_j.(pred i) done

let keep_lowest_bits a j = a land low_mask.(j)

let high_mask = Array.init (succ bpi) (fun j -> low_mask.(j) lsl (bpi-j))

let keep_highest_bits a j = a land high_mask.(j)

(*s Creating and normalizing a bit vector is easy: it is just a matter of
    taking care of the invariant. Copy is immediate. *)

let create n b =
  let initv = if b then max_int else 0 in
  let r = n mod bpi in
  if r = 0 then
    { length = n; bits = Array.create (n / bpi) initv }
  else begin
    let s = n / bpi in
    let b = Array.create (succ s) initv in
    b.(s) <- b.(s) land low_mask.(r);
    { length = n; bits = b }
  end
    
let normalize v =
  let r = v.length mod bpi in
  if r > 0 then
    let b = v.bits in
    let s = Array.length b in
    b.(s-1) <- b.(s-1) land low_mask.(r)

let copy v = { length = v.length; bits = Array.copy v.bits }

(*s Access and assignment. The [n]th bit of a bit vector is the [j]th
    bit of the [i]th integer, where [i = n / bpi] and [j = n mod
    bpi]. Both [i] and [j] and computed by the function [pos].
    Accessing a bit is testing whether the result of the corresponding
    mask operation is non-zero, and assigning it is done with a
    bitwiwe operation: an {\em or} with [bit_j] to set it, and an {\em
    and} with [bit_not_j] to unset it. *)

let pos n = 
  let i = n / bpi and j = n mod bpi in
  if j < 0 then (i - 1, j + bpi) else (i,j)

let unsafe_get v n =
  let (i,j) = pos n in 
  ((Array.unsafe_get v.bits i) land (Array.unsafe_get bit_j j)) > 0

let unsafe_set v n b =
  let (i,j) = pos n in
  if b then
    Array.unsafe_set v.bits i 
      ((Array.unsafe_get v.bits i) lor (Array.unsafe_get bit_j j))
  else 
    Array.unsafe_set v.bits i 
      ((Array.unsafe_get v.bits i) land (Array.unsafe_get bit_not_j j))

(*s The corresponding safe operations test the validiy of the access. *)

let get v n =
  if n < 0 or n >= v.length then invalid_arg "Bitv.get";
  let (i,j) = pos n in 
  ((Array.unsafe_get v.bits i) land (Array.unsafe_get bit_j j)) > 0

let set v n b =
  if n < 0 or n >= v.length then invalid_arg "Bitv.set";
  let (i,j) = pos n in
  if b then
    Array.unsafe_set v.bits i
      ((Array.unsafe_get v.bits i) lor (Array.unsafe_get bit_j j))
  else
    Array.unsafe_set v.bits i
      ((Array.unsafe_get v.bits i) land (Array.unsafe_get bit_not_j j))

(*s [init] is implemented naively using [unsafe_set]. *)

let init n f =
  let v = create n false in
  for i = 0 to pred n do
    unsafe_set v i (f i)
  done;
  v

(*s Handling bits by packets is the key for efficiency of functions
    [append], [concat], [sub] and [blit]. 
    We start by a very general function [blit_bits a i m v n] which blits 
    the bits [i] to [i+m-1] of a native integer [a] 
    onto the bit vector [v] at index [n]. It assumes that [i..i+m-1] and
    [n..n+m-1] are respectively valid subparts of [a] and [v]. 
    It is optimized when the bits fit the lowest boundary of an integer 
    (case [j == 0]). *)

let blit_bits a i m v n =
  let (i',j) = pos n in
  if j == 0 then
    Array.unsafe_set v i'
      ((keep_lowest_bits (a lsr i) m) lor
       (keep_highest_bits (Array.unsafe_get v i') (bpi - m)))
  else 
    let d = m + j - bpi in
    if d > 0 then begin
      Array.unsafe_set v i'
	(((keep_lowest_bits (a lsr i) (bpi - j)) lsl j) lor
	 (keep_lowest_bits (Array.unsafe_get v i') j));
      Array.unsafe_set v (succ i')
	((keep_lowest_bits (a lsr (i + bpi - j)) d) lor
	 (keep_highest_bits (Array.unsafe_get v (succ i')) (bpi - d)))
    end else 
      Array.unsafe_set v i'
	(((keep_lowest_bits (a lsr i) m) lsl j) lor
	 ((Array.unsafe_get v i') land (low_mask.(j) lor high_mask.(-d))))

(*s [blit_int] implements [blit_bits] in the particular case when
    [i=0] and [m=bpi] i.e. when we blit all the bits of [a]. *)

let blit_int a v n =
  let (i,j) = pos n in
  if j == 0 then
    Array.unsafe_set v i a
  else begin
    Array.unsafe_set v i 
      ( (keep_lowest_bits (Array.unsafe_get v i) j) lor
       ((keep_lowest_bits a (bpi - j)) lsl j));
    Array.unsafe_set v (succ i)
      ((keep_highest_bits (Array.unsafe_get v (succ i)) (bpi - j)) lor
       (a lsr (bpi - j)))
  end

(*s When blitting a subpart of a bit vector into another bit vector, there
    are two possible cases: (1) all the bits are contained in a single integer
    of the first bit vector, and a single call to [blit_bits] is the
    only thing to do, or (2) the source bits overlap on several integers of
    the source array, and then we do a loop of [blit_int], with two calls
    to [blit_bits] for the two bounds. *)

let unsafe_blit v1 ofs1 v2 ofs2 len =
  if len > 0 then
    let (bi,bj) = pos ofs1 in
    let (ei,ej) = pos (ofs1 + len - 1) in
    if bi == ei then
      blit_bits (Array.unsafe_get v1 bi) bj len v2 ofs2
    else begin
      blit_bits (Array.unsafe_get v1 bi) bj (bpi - bj) v2 ofs2;
      let n = ref (ofs2 + bpi - bj) in
      for i = succ bi to pred ei do
	blit_int (Array.unsafe_get v1 i) v2 !n;
	n := !n + bpi
      done;
      blit_bits (Array.unsafe_get v1 ei) 0 (succ ej) v2 !n
    end

let blit v1 ofs1 v2 ofs2 len =
  if len < 0 or ofs1 < 0 or ofs1 + len > v1.length
             or ofs2 < 0 or ofs2 + len > v2.length
  then invalid_arg "Bitv.blit";
  unsafe_blit v1.bits ofs1 v2.bits ofs2 len

(*s Extracting the subvector [ofs..ofs+len-1] of [v] is just creating a
    new vector of length [len] and blitting the subvector of [v] inside. *)

let sub v ofs len =
  if ofs < 0 or len < 0 or ofs + len > v.length then invalid_arg "Bitv.sub";
  let r = create len false in
  unsafe_blit v.bits ofs r.bits 0 len;
  r

(*s The concatenation of two bit vectors [v1] and [v2] is obtained by 
    creating a vector for the result and blitting inside the two vectors.
    [v1] is copied directly. *)

let append v1 v2 =
  let l1 = v1.length 
  and l2 = v2.length in
  let r = create (l1 + l2) false in
  let b1 = v1.bits in
  let b2 = v2.bits in
  let b = r.bits in
  for i = 0 to Array.length b1 - 1 do 
    Array.unsafe_set b i (Array.unsafe_get b1 i) 
  done;  
  unsafe_blit b2 0 b l1 l2;
  r

(*s The concatenation of a list of bit vectors is obtained by iterating
    [unsafe_blit]. *)

let concat vl =
  let size = List.fold_left (fun sz v -> sz + v.length) 0 vl in
  let res = create size false in
  let b = res.bits in
  let pos = ref 0 in
  List.iter
    (fun v ->
       let n = v.length in
       unsafe_blit v.bits 0 b !pos n;
       pos := !pos + n)
    vl;
  res

(*s Filling is a particular case of blitting with a source made of all
    ones or all zeros. Thus we instanciate [unsafe_blit], with 0 and
    [max_int]. *)

let blit_zeros v ofs len =
  if len > 0 then
    let (bi,bj) = pos ofs in
    let (ei,ej) = pos (ofs + len - 1) in
    if bi == ei then
      blit_bits 0 bj len v ofs
    else begin
      blit_bits 0 bj (bpi - bj) v ofs;
      let n = ref (ofs + bpi - bj) in
      for i = succ bi to pred ei do
	blit_int 0 v !n;
	n := !n + bpi
      done;
      blit_bits 0 0 (succ ej) v !n
    end

let blit_ones v ofs len =
  if len > 0 then
    let (bi,bj) = pos ofs in
    let (ei,ej) = pos (ofs + len - 1) in
    if bi == ei then
      blit_bits max_int bj len v ofs
    else begin
      blit_bits max_int bj (bpi - bj) v ofs;
      let n = ref (ofs + bpi - bj) in
      for i = succ bi to pred ei do
	blit_int max_int v !n;
	n := !n + bpi
      done;
      blit_bits max_int 0 (succ ej) v !n
    end

let fill v ofs len b =
  if ofs < 0 or len < 0 or ofs + len > v.length then invalid_arg "Bitv.fill";
  if b then blit_ones v.bits ofs len else blit_zeros v.bits ofs len

(*s All the iterators are implemented as for traditional arrays, using
    [unsafe_get]. For [iter] and [map], we do not precompute [(f
    true)] and [(f false)] since [f] is likely to have
    side-effects. *)

let iter f v =
  for i = 0 to v.length - 1 do f (unsafe_get v i) done

let map f v =
  let l = v.length in
  let r = create l false in
  for i = 0 to l - 1 do
    unsafe_set r i (f (unsafe_get v i))
  done;
  r

let iteri f v =
  for i = 0 to v.length - 1 do f i (unsafe_get v i) done

let mapi f v =
  let l = v.length in
  let r = create l false in
  for i = 0 to l - 1 do
    unsafe_set r i (f i (unsafe_get v i))
  done;
  r

let fold_left f x v =
  let r = ref x in
  for i = 0 to v.length - 1 do
    r := f !r (unsafe_get v i)
  done;
  !r

let fold_right f v x =
  let r = ref x in
  for i = v.length - 1 downto 0 do
    r := f (unsafe_get v i) !r
  done;
  !r

let foldi_left f x v =
  let r = ref x in
  for i = 0 to v.length - 1 do
    r := f !r i (unsafe_get v i)
  done;
  !r

let foldi_right f v x =
  let r = ref x in
  for i = v.length - 1 downto 0 do
    r := f i (unsafe_get v i) !r
  done;
  !r

let iteri_true f v =
  Array.iteri 
    (fun i n -> if n != 0 then begin
       let i_bpi = i * bpi in
       for j = 0 to bpi - 1 do
	 if n land (Array.unsafe_get bit_j j) > 0 then f (i_bpi + j)
       done
     end) 
    v.bits

(*s Bitwise operations. It is straigthforward, since bitwise operations
    can be realized by the corresponding bitwise operations over integers.
    However, one has to take care of normalizing the result of [bwnot]
    which introduces ones in highest significant positions. *)

let bw_and v1 v2 = 
  let l = v1.length in
  if l <> v2.length then invalid_arg "Bitv.bw_and";
  let b1 = v1.bits 
  and b2 = v2.bits in
  let n = Array.length b1 in
  let a = Array.create n 0 in
  for i = 0 to n - 1 do
    a.(i) <- b1.(i) land b2.(i)
  done;
  { length = l; bits = a }
  
let bw_or v1 v2 = 
  let l = v1.length in
  if l <> v2.length then invalid_arg "Bitv.bw_or";
  let b1 = v1.bits 
  and b2 = v2.bits in
  let n = Array.length b1 in
  let a = Array.create n 0 in
  for i = 0 to n - 1 do
    a.(i) <- b1.(i) lor b2.(i)
  done;
  { length = l; bits = a }
  
let bw_xor v1 v2 = 
  let l = v1.length in
  if l <> v2.length then invalid_arg "Bitv.bw_xor";
  let b1 = v1.bits 
  and b2 = v2.bits in
  let n = Array.length b1 in
  let a = Array.create n 0 in
  for i = 0 to n - 1 do
    a.(i) <- b1.(i) lxor b2.(i)
  done;
  { length = l; bits = a }
  
let bw_not v = 
  let b = v.bits in
  let n = Array.length b in
  let a = Array.create n 0 in
  for i = 0 to n - 1 do
    a.(i) <- max_int land (lnot b.(i))
  done;
  let r = { length = v.length; bits = a } in
  normalize r;
  r

(*s Shift operations. It is easy to reuse [unsafe_blit], although it is 
    probably slightly less efficient than a ad-hoc piece of code. *)

let rec shiftl v d =
  if d == 0 then 
    copy v
  else if d < 0 then
    shiftr v (-d)
  else begin
    let n = v.length in
    let r = create n false in
    if d < n then unsafe_blit v.bits 0 r.bits d (n - d);
    r
  end
  
and shiftr v d =
  if d == 0 then 
    copy v
  else if d < 0 then
    shiftl v (-d)
  else begin
    let n = v.length in
    let r = create n false in
    if d < n then unsafe_blit v.bits d r.bits 0 (n - d);
    r
  end

(*s Testing for all zeros and all ones. *)

let all_zeros v = 
  let b = v.bits in
  let n = Array.length b in
  let rec test i = 
    (i == n) || ((Array.unsafe_get b i == 0) && test (succ i)) 
  in
  test 0

let all_ones v = 
  let b = v.bits in
  let n = Array.length b in
  let rec test i = 
    if i == n - 1 then
      let m = v.length mod bpi in
      (Array.unsafe_get b i) == (if m == 0 then max_int else low_mask.(m))
    else
      ((Array.unsafe_get b i) == max_int) && test (succ i)
  in
  test 0

(*s Conversions to and from strings. *)

let to_string v = 
  let n = v.length in
  let s = String.make n '0' in
  for i = 0 to n - 1 do
    if unsafe_get v i then s.[i] <- '1'
  done;
  s

let print fmt v = Format.pp_print_string fmt (to_string v)

let of_string s =
  let n = String.length s in
  let v = create n false in
  for i = 0 to n - 1 do
    let c = String.unsafe_get s i in
    if c = '1' then 
      unsafe_set v i true
    else 
      if c <> '0' then invalid_arg "Bitv.of_string"
  done;
  v

(*s Iteration on all bit vectors of length [n] using a Gray code. *)

let first_set v n = 
  let rec lookup i = 
    if i = n then raise Not_found ;
    if unsafe_get v i then i else lookup (i + 1)
  in 
  lookup 0

let gray_iter f n = 
  let bv = create n false in 
  let rec iter () =
    f bv; 
    unsafe_set bv 0 (not (unsafe_get bv 0));
    f bv; 
    let pos = succ (first_set bv n) in
    if pos < n then begin
      unsafe_set bv pos (not (unsafe_get bv pos));
      iter ()
    end
  in
  if n > 0 then iter ()


(*s Coercions to/from lists of integers *)

let of_list l =
  let n = List.fold_left max 0 l in
  let b = create (succ n) false in
  let add_element i = 
    (* negative numbers are invalid *)
    if i < 0 then invalid_arg "Bitv.of_list";
    unsafe_set b i true 
  in
  List.iter add_element l;
  b

let of_list_with_length l len =
  let b = create len false in
  let add_element i =
    if i < 0 || i >= len then invalid_arg "Bitv.of_list_with_length";
    unsafe_set b i true
  in
  List.iter add_element l;
  b

let to_list b =
  let n = length b in
  let rec make i acc = 
    if i < 0 then acc 
    else make (pred i) (if unsafe_get b i then i :: acc else acc)
  in
  make (pred n) []


(*s To/from integers. *)

(* [int] *)
let of_int_us i = 
  { length = bpi; bits = [| i land max_int |] }
let to_int_us v = 
  if v.length < bpi then invalid_arg "Bitv.to_int_us"; 
  v.bits.(0)

let of_int_s i = 
  { length = succ bpi; bits = [| i land max_int; (i lsr bpi) land 1 |] }
let to_int_s v = 
  if v.length < succ bpi then invalid_arg "Bitv.to_int_s"; 
  v.bits.(0) lor (v.bits.(1) lsl bpi)

(* [Int32] *)
let of_int32_us i = match Sys.word_size with
  | 32 -> { length = 31; 
	    bits = [| (Int32.to_int i) land max_int; 
		      let hi = Int32.shift_right_logical i 30 in
		      (Int32.to_int hi) land 1 |] }
  | 64 -> { length = 31; bits = [| (Int32.to_int i) land 0x7fffffff |] }
  | _ -> assert false
let to_int32_us v =
  if v.length < 31 then invalid_arg "Bitv.to_int32_us"; 
  match Sys.word_size with
    | 32 -> 
	Int32.logor (Int32.of_int v.bits.(0))
	            (Int32.shift_left (Int32.of_int (v.bits.(1) land 1)) 30)
    | 64 ->
	Int32.of_int (v.bits.(0) land 0x7fffffff)
    | _ -> assert false

(* this is 0xffffffff (ocaml >= 3.08 checks for literal overflow) *)
let ffffffff = (0xffff lsl 16) lor 0xffff

let of_int32_s i = match Sys.word_size with
  | 32 -> { length = 32; 
	    bits = [| (Int32.to_int i) land max_int; 
		      let hi = Int32.shift_right_logical i 30 in
		      (Int32.to_int hi) land 3 |] }
  | 64 -> { length = 32; bits = [| (Int32.to_int i) land ffffffff |] }
  | _ -> assert false
let to_int32_s v =
  if v.length < 32 then invalid_arg "Bitv.to_int32_s"; 
  match Sys.word_size with
    | 32 -> 
	Int32.logor (Int32.of_int v.bits.(0))
	            (Int32.shift_left (Int32.of_int (v.bits.(1) land 3)) 30)
    | 64 ->
	Int32.of_int (v.bits.(0) land ffffffff)
    | _ -> assert false

(* [Int64] *)
let of_int64_us i = match Sys.word_size with
  | 32 -> { length = 63; 
	    bits = [| (Int64.to_int i) land max_int; 
		      (let mi = Int64.shift_right_logical i 30 in
		       (Int64.to_int mi) land max_int);
		      let hi = Int64.shift_right_logical i 60 in
		      (Int64.to_int hi) land 1 |] }
  | 64 -> { length = 63; 
	    bits = [| (Int64.to_int i) land max_int;
		      let hi = Int64.shift_right_logical i 62 in 
		      (Int64.to_int hi) land 1 |] }
  | _ -> assert false
let to_int64_us v = failwith "todo"

let of_int64_s i = failwith "todo"
let to_int64_s v = failwith "todo"

(* [Nativeint] *)
let select_of f32 f64 = match Sys.word_size with 
  | 32 -> (fun i -> f32 (Nativeint.to_int32 i))
  | 64 -> (fun i -> f64 (Int64.of_nativeint i))
  | _ -> assert false
let of_nativeint_s = select_of of_int32_s of_int64_s
let of_nativeint_us = select_of of_int32_us of_int64_us
let select_to f32 f64 = match Sys.word_size with 
  | 32 -> (fun i -> Nativeint.of_int32 (f32 i))
  | 64 -> (fun i -> Int64.to_nativeint (f64 i))
  | _ -> assert false
let to_nativeint_s = select_to to_int32_s to_int64_s
let to_nativeint_us = select_to to_int32_us to_int64_us


end
module Version: sig
#0 "graph/version.mli"
val version : string
val date : string
end = struct
#0 "graph/version.ml"
let version = "1.7"
let date = "Wed May 4 13:55:50 CEST 2011"
end
module Util: sig
#0 "graph/util.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(** Some useful operations. *)

open Sig

(** Cartesian product of two ordered types. *)
module OTProduct(X: ORDERED_TYPE)(Y: ORDERED_TYPE) :
  ORDERED_TYPE with type t = X.t * Y.t

(** Cartesian product of two hashable types. *)
module HTProduct(X: HASHABLE)(Y: HASHABLE) :
  HASHABLE with type t = X.t * Y.t

(** Cartesian product of two comparable types. *)
module CMPProduct(X: COMPARABLE)(Y: COMPARABLE) :
  COMPARABLE with type t = X.t * Y.t

(** Create a vertex type with some data attached to it *)
module DataV(L : sig type t end)(V : Sig.COMPARABLE) : sig
  type data = L.t
  and label = V.t
  and t = data ref * V.t
  val compare : t -> t -> int
  val hash : t -> int
  val equal : t -> t -> bool
  val create : data -> V.t -> t
  val label : t -> V.t
  val data : t -> data
  val set_data : t -> data -> unit
end

end = struct
#0 "graph/util.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

open Sig

module OTProduct(X: ORDERED_TYPE)(Y: ORDERED_TYPE) = struct
  type t = X.t * Y.t
  let compare (x1, y1) (x2, y2) =
    let cv = X.compare x1 x2 in
    if cv != 0 then cv else Y.compare y1 y2
end

module HTProduct(X: HASHABLE)(Y: HASHABLE) = struct
  type t = X.t * Y.t
  let equal (x1, y1) (x2, y2) = X.equal x1 x2 && Y.equal y1 y2
  let hash (x, y) = Hashtbl.hash (X.hash x, Y.hash y)
end

module CMPProduct(X: COMPARABLE)(Y: COMPARABLE) = struct
  include HTProduct(X)(Y)
  include (OTProduct(X)(Y): sig val compare : t -> t -> int end)
end

module DataV(L : sig type t end)(V : Sig.COMPARABLE) = struct
  type data = L.t
  type label = V.t
  type t = data ref * V.t
  let compare (_, x) (_, x') = V.compare x x'
  let hash (_, x) = V.hash x
  let equal (_, x) (_, x') = V.equal x x'
  let create y lbl = (ref y, lbl)
  let label (_, z) = z
  let data (y, _) = !y
  let set_data (y, _) = (:=) y
end

end
module Blocks = struct
#0 "graph/blocks.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(** Common implementation to persistent and imperative graphs. *)

open Sig
open Util

let first_value_for_cpt_vertex = 0
let cpt_vertex = ref first_value_for_cpt_vertex
  (* global counter for abstract vertex *)

(* [max_cpt t1 t2] returns the maximum of [t1] and [t2] wrt the total ordering
   induced by tags creation. This ordering is defined as follow:
   forall tags t1 t2,
   t1 <= t2 iff
   t1 is before t2 in the finite sequence
   [0; 1; ..; max_int; min_int; min_int-1; -1] *)
let max_cpt c1 c2 = max (c1 + min_int) (c2 + min_int) - min_int

(* This function must be called after the unserialisation of any abstract
   vertex if you want to create new vertices. *)
let after_unserialization serialized_cpt_vertex =
  cpt_vertex := max_cpt serialized_cpt_vertex !cpt_vertex

(* ************************************************************************* *)
(** {2 Association table builder} *)
(* ************************************************************************* *)

(** Common signature to an imperative/persistent association table *)
module type HM = sig
  type 'a return
  type 'a t
  type key
  val create : ?size:int -> unit -> 'a t
  val create_from : 'a t -> 'a t
  val empty : 'a return
  val clear: 'a t -> unit
  val is_empty : 'a t -> bool
  val add : key -> 'a -> 'a t -> 'a t
  val remove : key -> 'a t -> 'a t
  val mem : key -> 'a t -> bool
  val find : key -> 'a t -> 'a
  val find_and_raise : key -> 'a t -> string -> 'a
    (** [find_and_raise k t s] is equivalent to [find k t] but
       raises [Invalid_argument s] when [find k t] raises [Not_found] *)
  val iter : (key -> 'a -> unit) -> 'a t -> unit
  val map : (key -> 'a -> key * 'a) -> 'a t -> 'a t
  val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
  val copy : 'a t -> 'a t
end

module type TBL_BUILDER = functor(X: COMPARABLE) -> HM with type key = X.t

(** [HM] implementation using hashtbl. *)
module Make_Hashtbl(X: COMPARABLE) = struct

  include Hashtbl.Make(X)

  type 'a return = unit
  let empty = ()
    (* never call and not visible for the user thank's to signature
       constraints *)

  let create_from h = create (length h)
  let create ?(size=97) () = create size

  let is_empty h = (length h = 0)

  let find_and_raise k h s = try find h k with Not_found -> invalid_arg s

  let map f h =
    let h' = create_from h  in
    iter (fun k v -> let k, v = f k v in add h' k v) h;
    h'

  let add k v h = replace h k v; h
  let remove k h = remove h k; h
  let mem k h = mem h k
  let find k h = find h k

end

(** [HM] implementation using map *)
module Make_Map(X: COMPARABLE) = struct
  include Map.Make(X)
  type 'a return = 'a t
  let is_empty m = (m = empty)
  let create ?size () = assert false
    (* never call and not visible for the user thank's to
       signature constraints *)
  let create_from _ = empty
  let copy m = m
  let map f m = fold (fun k v m -> let k, v = f k v in add k v m) m empty
  let find_and_raise k h s = try find k h with Not_found -> invalid_arg s
  let clear _ = assert false
    (* never call and not visible for the user thank's to
       signature constraints *)
end

(* ************************************************************************* *)
(** {2 Blocks builder} *)
(* ************************************************************************* *)

(** Common implementation to all (directed) graph implementations. *)
module Minimal(S: Set.S)(HM: HM) = struct

  type vertex = HM.key

  let is_directed = true
  let empty = HM.empty
  let create = HM.create
  let is_empty = HM.is_empty
  let copy = HM.copy
  let clear = HM.clear

  let nb_vertex g = HM.fold (fun _ _ -> succ) g 0
  let nb_edges g = HM.fold (fun _ s n -> n + S.cardinal s) g 0
  let out_degree g v =
    S.cardinal
      (try HM.find v g with Not_found -> invalid_arg "[ocamlgraph] out_degree")

  let mem_vertex g v = HM.mem v g

  let unsafe_add_vertex g v = HM.add v S.empty g
  let unsafe_add_edge g v1 v2 = HM.add v1 (S.add v2 (HM.find v1 g)) g

  let add_vertex g v = if HM.mem v g then g else unsafe_add_vertex g v

  let iter_vertex f = HM.iter (fun v _ -> f v)
  let fold_vertex f = HM.fold (fun v _ -> f v)

end

(** All the predecessor operations from the iterators on the edges *)
module Pred
  (S: sig
     module PV: COMPARABLE
     module PE: EDGE with type vertex = PV.t
     type t
     val mem_vertex : PV.t -> t -> bool
     val iter_edges : (PV.t -> PV.t -> unit) -> t -> unit
     val fold_edges : (PV.t -> PV.t -> 'a -> 'a) -> t -> 'a -> 'a
     val iter_edges_e : (PE.t -> unit) -> t -> unit
     val fold_edges_e : (PE.t -> 'a -> 'a) -> t -> 'a -> 'a
   end) =
struct

  open S

  let iter_pred f g v =
    if not (mem_vertex v g) then invalid_arg "[ocamlgraph] iter_pred";
    iter_edges (fun v1 v2 -> if PV.equal v v2 then f v1) g

  let fold_pred f g v =
    if not (mem_vertex v g) then invalid_arg "[ocamlgraph] fold_pred";
    fold_edges (fun v1 v2 a -> if PV.equal v v2 then f v1 a else a) g

  let pred g v = fold_pred (fun v l -> v :: l) g v []

  let in_degree g v =
    if not (mem_vertex v g) then invalid_arg "[ocamlgraph] in_degree";
    fold_pred (fun v n -> n + 1) g v 0

  let iter_pred_e f g v =
    if not (mem_vertex v g) then invalid_arg "[ocamlgraph] iter_pred_e";
    iter_edges_e (fun e -> if PV.equal v (PE.dst e) then f e) g

  let fold_pred_e f g v =
    if not (mem_vertex v g) then invalid_arg "[ocamlgraph] fold_pred_e";
    fold_edges_e (fun e a -> if PV.equal v (PE.dst e) then f e a else a) g

  let pred_e g v = fold_pred_e (fun v l -> v :: l) g v []

end

(** Common implementation to all the unlabeled (directed) graphs. *)
module Unlabeled(V: COMPARABLE)(HM: HM with type key = V.t) = struct

  module S = Set.Make(V)

  module E = struct
    type vertex = V.t
    include OTProduct(V)(V)
    let src = fst
    let dst = snd
    type label = unit
    let label _ = ()
    let create v1 () v2 = v1, v2
  end
  type edge = E.t

  let mem_edge g v1 v2 =
    try S.mem v2 (HM.find v1 g)
    with Not_found -> false

  let mem_edge_e g (v1, v2) = mem_edge g v1 v2

  let find_edge g v1 v2 = if mem_edge g v1 v2 then v1, v2 else raise Not_found

  let unsafe_remove_edge g v1 v2 = HM.add v1 (S.remove v2 (HM.find v1 g)) g
  let unsafe_remove_edge_e g (v1, v2) = unsafe_remove_edge g v1 v2

  let remove_edge g v1 v2 =
    if not (HM.mem v2 g) then invalid_arg "[ocamlgraph] remove_edge";
    HM.add
      v1 (S.remove v2 (HM.find_and_raise v1 g "[ocamlgraph] remove_edge")) g

  let remove_edge_e g (v1, v2) = remove_edge g v1 v2

  let iter_succ f g v =
    S.iter f (HM.find_and_raise v g "[ocamlgraph] iter_succ")

  let fold_succ f g v =
    S.fold f (HM.find_and_raise v g "[ocamlgraph] fold_succ")

  let iter_succ_e f g v = iter_succ (fun v2 -> f (v, v2)) g v
  let fold_succ_e f g v = fold_succ (fun v2 -> f (v, v2)) g v

  let succ g v = S.elements (HM.find_and_raise v g "[ocamlgraph] succ")
  let succ_e g v = fold_succ_e (fun e l -> e :: l) g v []

  let map_vertex f =
    HM.map (fun v s -> f v, S.fold (fun v s -> S.add (f v) s) s S.empty)

  module I = struct
    type t = S.t HM.t
    module PV = V
    module PE = E
    let iter_edges f = HM.iter (fun v -> S.iter (f v))
    let fold_edges f = HM.fold (fun v -> S.fold (f v))
    let iter_edges_e f = iter_edges (fun v1 v2 -> f (v1, v2))
    let fold_edges_e f = fold_edges (fun v1 v2 a -> f (v1, v2) a)
  end
  include I

  include Pred(struct include I let mem_vertex = HM.mem end)

end

(** Common implementation to all the labeled (directed) graphs. *)
module Labeled(V: COMPARABLE)(E: ORDERED_TYPE)(HM: HM with type key = V.t) =
struct

  module VE = OTProduct(V)(E)
  module S = Set.Make(VE)

  module E = struct
    type vertex = V.t
    type label = E.t
    type t = vertex * label * vertex
    let src (v, _, _) = v
    let dst (_, _, v) = v
    let label (_, l, _) = l
    let create v1 l v2 = v1, l, v2
    module C = OTProduct(V)(VE)
    let compare (x1, x2, x3) (y1, y2, y3) =
      C.compare (x1, (x3, x2)) (y1, (y3, y2))
  end
  type edge = E.t

  let mem_edge g v1 v2 =
    try S.exists (fun (v2', _) -> V.equal v2 v2') (HM.find v1 g)
    with Not_found -> false

  let mem_edge_e g (v1, l, v2) =
    try
      let ve = v2, l in
      S.exists (fun ve' -> VE.compare ve ve' = 0) (HM.find v1 g)
    with Not_found ->
      false

  exception Found of edge
  let find_edge g v1 v2 =
    try
      S.iter
	(fun (v2', l) -> if V.equal v2 v2' then raise (Found (v1, l, v2')))
	(HM.find v1 g);
      raise Not_found
    with Found e ->
      e

  let unsafe_remove_edge g v1 v2 =
    HM.add
      v1
      (S.filter (fun (v2', _) -> not (V.equal v2 v2')) (HM.find v1 g))
      g

  let unsafe_remove_edge_e g (v1, l, v2) =
    HM.add v1 (S.remove (v2, l) (HM.find v1 g)) g

  let remove_edge g v1 v2 =
    if not (HM.mem v2 g) then invalid_arg "[ocamlgraph] remove_edge";
    HM.add
      v1
      (S.filter
	 (fun (v2', _) -> not (V.equal v2 v2'))
	 (HM.find_and_raise v1 g "[ocamlgraph] remove_edge"))
      g

  let remove_edge_e g (v1, l, v2) =
    if not (HM.mem v2 g) then invalid_arg "[ocamlgraph] remove_edge_e";
    HM.add
      v1
      (S.remove (v2, l) (HM.find_and_raise v1 g "[ocamlgraph] remove_edge_e"))
      g

  let iter_succ f g v =
    S.iter (fun (w, _) -> f w) (HM.find_and_raise v g "[ocamlgraph] iter_succ")
  let fold_succ f g v =
    S.fold (fun (w, _) -> f w) (HM.find_and_raise v g "[ocamlgraph] fold_succ")

  let iter_succ_e f g v =
    S.iter
      (fun (w, l) -> f (v, l, w))
      (HM.find_and_raise v g "[ocamlgraph] iter_succ_e")

  let fold_succ_e f g v =
    S.fold
      (fun (w, l) -> f (v, l, w))
      (HM.find_and_raise v g "[ocamlgraph] fold_succ_e")

  let succ g v = fold_succ (fun w l -> w :: l) g v []
  let succ_e g v = fold_succ_e (fun e l -> e :: l) g v []

  let map_vertex f =
    HM.map
      (fun v s -> f v, S.fold (fun (v, l) s -> S.add (f v, l) s) s S.empty)

  module I = struct
    type t = S.t HM.t
    module PV = V
    module PE = E
    let iter_edges f = HM.iter (fun v -> S.iter (fun (w, _) -> f v w))
    let fold_edges f = HM.fold (fun v -> S.fold (fun (w, _) -> f v w))
    let iter_edges_e f =
      HM.iter (fun v -> S.iter (fun (w, l) -> f (v, l, w)))
    let fold_edges_e f =
      HM.fold (fun v -> S.fold (fun (w, l) -> f (v, l, w)))
  end
  include I

  include Pred(struct include I let mem_vertex = HM.mem end)

end

(** The vertex module and the vertex table for the concrete graphs. *)
module ConcreteVertex(F : TBL_BUILDER)(V: COMPARABLE) = struct
  module V = struct
    include V
    type label = t
    let label v = v
    let create v = v
  end
  module HM = F(V)
end

module Make_Abstract
  (G: sig
     module HM: HM
     module S: Set.S
     include G with type t = S.t HM.t and type V.t = HM.key
     val remove_edge: t -> vertex -> vertex -> t
     val remove_edge_e: t -> edge -> t
     val unsafe_add_vertex: t -> vertex -> t
     val unsafe_add_edge: t -> vertex -> S.elt -> t
     val unsafe_remove_edge: t -> vertex -> vertex -> t
     val unsafe_remove_edge_e: t -> edge -> t
     val create: ?size:int -> unit -> t
     val clear: t -> unit
   end) =
struct

  module I = struct
    type t = { edges : G.t; mutable size : int }
	(* BE CAREFUL: [size] is only mutable in the imperative version. As
	   there is no extensible records in current ocaml version, and for
	   genericity purpose, [size] is mutable in both imperative and
	   persistent implementations.
	   Do not modify size in the persistent implementation! *)

    type vertex = G.vertex
    type edge = G.edge

    module PV = G.V
    module PE = G.E

    let iter_edges f g = G.iter_edges f g.edges
    let fold_edges f g = G.fold_edges f g.edges
    let iter_edges_e f g = G.iter_edges_e f g.edges
    let fold_edges_e f g = G.fold_edges_e f g.edges
    let mem_vertex v g = G.mem_vertex g.edges v
    let create ?size () = { edges = G.create ?size (); size = 0 }
    let clear g = G.clear g.edges; g.size <- 0
  end
  include I

  include Pred(I)

  (* optimisations *)

  let is_empty g = g.size = 0
  let nb_vertex g = g.size

  (* redefinitions *)
  module V = G.V
  module E = G.E
  module HM = G.HM
  module S = G.S

  let unsafe_add_edge = G.unsafe_add_edge
  let unsafe_remove_edge = G.unsafe_remove_edge
  let unsafe_remove_edge_e = G.unsafe_remove_edge_e
  let is_directed = G.is_directed

  let remove_edge g = G.remove_edge g.edges
  let remove_edge_e g = G.remove_edge_e g.edges

  let out_degree g = G.out_degree g.edges
  let in_degree g = G.in_degree g.edges

  let nb_edges g = G.nb_edges g.edges
  let succ g = G.succ g.edges
  let mem_vertex g = G.mem_vertex g.edges
  let mem_edge g = G.mem_edge g.edges
  let mem_edge_e g = G.mem_edge_e g.edges
  let find_edge g = G.find_edge g.edges

  let iter_vertex f g = G.iter_vertex f g.edges
  let fold_vertex f g = G.fold_vertex f g.edges
  let iter_succ f g = G.iter_succ f g.edges
  let fold_succ f g = G.fold_succ f g.edges
  let succ_e g = G.succ_e g.edges
  let iter_succ_e f g = G.iter_succ_e f g.edges
  let fold_succ_e f g = G.fold_succ_e f g.edges
  let map_vertex f g = { g with edges = G.map_vertex f g.edges }

  (* reimplementation *)

  let copy g =
    let h = HM.create () in
    let vertex v =
      try
	HM.find v h
      with Not_found ->
	let v' = V.create (V.label v) in
	let h' = HM.add v v' h in
	assert (h == h');
	v'
    in
    map_vertex vertex g

end

(** Support for explicitly maintaining edge set of
    predecessors.  Crucial for algorithms that do a lot of backwards
    traversal. *)

module BidirectionalMinimal(S:Set.S)(HM:HM) = struct

  type vertex = HM.key

  let is_directed = true
  let empty = HM.empty
  let create = HM.create
  let clear = HM.clear
  let is_empty = HM.is_empty
  let copy = HM.copy

  let nb_vertex g = HM.fold (fun _ _ -> succ) g 0
  let nb_edges g = HM.fold (fun _ (_,s) n -> n + S.cardinal s) g 0
  let out_degree g v =
    S.cardinal
      (snd (try HM.find v g
	    with Not_found -> invalid_arg "[ocamlgraph] out_degree"))

  let mem_vertex g v = HM.mem v g

  let unsafe_add_vertex g v = HM.add v (S.empty, S.empty) g
  let add_vertex g v = if HM.mem v g then g else unsafe_add_vertex g v

  let iter_vertex f = HM.iter (fun v _ -> f v)
  let fold_vertex f = HM.fold (fun v _ -> f v)

end

module BidirectionalUnlabeled(V:COMPARABLE)(HM:HM with type key = V.t) = struct

  module S = Set.Make(V)

  module E = struct
    type vertex = V.t
    include OTProduct(V)(V)
    let src = fst
    let dst = snd
    type label = unit
    let label _ = ()
    let create v1 () v2 = v1, v2
  end
  type edge = E.t

  let mem_edge g v1 v2 =
    try S.mem v2 (snd (HM.find v1 g))
    with Not_found -> false

  let mem_edge_e g (v1,v2) = mem_edge g v1 v2

  let find_edge g v1 v2 = if mem_edge g v1 v2 then v1, v2 else raise Not_found

  let unsafe_remove_edge g v1 v2 =
    let in_set, out_set = HM.find v1 g in
    let g = HM.add v1 (in_set, S.remove v2 out_set) g in
    let in_set, out_set = HM.find v2 g in
    HM.add v2 (S.remove v1 in_set, out_set) g

  let unsafe_remove_edge_e g (v1,v2) = unsafe_remove_edge g v1 v2

  let remove_edge g v1 v2 =
    if not (HM.mem v2 g && HM.mem v1 g) then
      invalid_arg "[ocamlgraph] remove_edge";
    unsafe_remove_edge g v1 v2

  let remove_edge_e g (v1, v2) = remove_edge g v1 v2

  let iter_succ f g v =
    S.iter f (snd (HM.find_and_raise v g "[ocamlgraph] iter_succ"))

  let fold_succ f g v =
    S.fold f (snd (HM.find_and_raise v g "[ocamlgraph] fold_succ"))

  let iter_succ_e f g v = iter_succ (fun v2 -> f (v, v2)) g v
  let fold_succ_e f g v = fold_succ (fun v2 -> f (v, v2)) g v

  let succ g v = S.elements (snd (HM.find_and_raise v g "[ocamlgraph] succ"))
  let succ_e g v = fold_succ_e (fun e l -> e :: l) g v []

  let map_vertex f =
    HM.map
      (fun v (s1,s2) ->
	 f v,
	 (S.fold (fun v s -> S.add (f v) s) s1 S.empty,
	  S.fold (fun v s -> S.add (f v) s) s2 S.empty))

  module I = struct
    (* we keep sets for both incoming and outgoing edges *)
    type t = (S.t (* incoming *) * S.t (* outgoing *)) HM.t
    module PV = V
    module PE = E
    let iter_edges f = HM.iter (fun v (_, outset) -> S.iter (f v) outset)
    let fold_edges f = HM.fold (fun v (_, outset) -> S.fold (f v) outset)
    let iter_edges_e f = iter_edges (fun v1 v2 -> f (v1, v2))
    let fold_edges_e f = fold_edges (fun v1 v2 a -> f (v1, v2) a)
  end
  include I

  let iter_pred f g v =
    S.iter f (fst (HM.find_and_raise v g "[ocamlgraph] iter_pred"))

  let fold_pred f g v =
    S.fold f (fst (HM.find_and_raise v g "[ocamlgraph] fold_pred"))

  let pred g v = S.elements (fst (HM.find_and_raise v g "[ocamlgraph] pred"))

  let in_degree g v =
    S.cardinal
      (fst (try HM.find v g
	    with Not_found -> invalid_arg "[ocamlgraph] in_degree"))

  let iter_pred_e f g v = iter_pred (fun v2 -> f (v2, v)) g v
  let fold_pred_e f g v = fold_pred (fun v2 -> f (v2, v)) g v

  let pred_e g v = fold_pred_e (fun e l -> e :: l) g v []

end

module BidirectionalLabeled
  (V:COMPARABLE)(E:ORDERED_TYPE)(HM:HM with type key = V.t) =
struct

  module VE = OTProduct(V)(E)
  module S = Set.Make(VE)

  module E = struct
    type vertex = V.t
    type label = E.t
    type t = vertex * label * vertex
    let src (v, _, _) = v
    let dst (_, _, v) = v
    let label (_, l, _) = l
    let create v1 l v2 = v1, l, v2
    module C = OTProduct(V)(VE)
    let compare (x1, x2, x3) (y1, y2, y3) =
      C.compare (x1, (x3, x2)) (y1, (y3, y2))
  end
  type edge = E.t

  let mem_edge g v1 v2 =
    try S.exists (fun (v2', _) -> V.equal v2 v2') (snd (HM.find v1 g))
    with Not_found -> false

  let mem_edge_e g (v1, l, v2) =
    try
      let ve = v2, l in
      S.exists (fun ve' -> VE.compare ve ve' = 0) (snd (HM.find v1 g))
    with Not_found ->
      false

  exception Found of edge
  let find_edge g v1 v2 =
    try
      S.iter
	(fun (v2', l) -> if V.equal v2 v2' then raise (Found (v1, l, v2')))
	(snd (HM.find v1 g));
      raise Not_found
    with Found e ->
      e

  let unsafe_remove_edge g v1 v2 =
    let in_set, out_set = HM.find v1 g in
    let del v set = S.filter (fun (v', _) -> not (V.equal v v')) set in
    let g = HM.add v1 (in_set, del v2 out_set) g in
    let in_set, out_set = HM.find v2 g in
    HM.add v2 (del v1 in_set, out_set) g

  let unsafe_remove_edge_e g (v1, l, v2) =
    let in_set, out_set = HM.find v1 g in
    let g = HM.add v1 (in_set, S.remove (v2, l) out_set) g in
    let in_set, out_set = HM.find v2 g in
    HM.add v2 (S.remove (v1, l) in_set, out_set) g

  let remove_edge g v1 v2 =
(*    if not (HM.mem v2 g) then invalid_arg "[ocamlgraph] remove_edge";*)
    let in_set, out_set = HM.find_and_raise v1 g "[ocamlgraph] remove_edge" in
    let del v set = S.filter (fun (v', _) -> not (V.equal v v')) set in
    let g = HM.add v1 (in_set, del v2 out_set) g in
    let in_set, out_set = HM.find_and_raise v2 g "[ocamlgraph] remove_edge" in
    HM.add v2 (del v1 in_set, out_set) g

  let remove_edge_e g (v1, l, v2) =
(*    if not (HM.mem v2 g) then invalid_arg "[ocamlgraph] remove_edge_e";*)
    let in_set, out_set = HM.find_and_raise v1 g "[ocamlgraph] remove_edge_e" in
    let g = HM.add v1 (in_set, S.remove (v2, l) out_set) g in
    let in_set, out_set = HM.find_and_raise v2 g "[ocamlgraph] remove_edge_e" in
    HM.add v2 (S.remove (v1, l) in_set, out_set) g

  let iter_succ f g v =
    S.iter
      (fun (w, _) -> f w)
      (snd (HM.find_and_raise v g "[ocamlgraph] iter_succ"))

  let fold_succ f g v =
    S.fold
      (fun (w, _) -> f w)
      (snd (HM.find_and_raise v g "[ocamlgraph] fold_succ"))

  let iter_succ_e f g v =
    S.iter
      (fun (w, l) -> f (v, l, w))
      (snd (HM.find_and_raise v g "[ocamlgraph] iter_succ_e"))

  let fold_succ_e f g v =
    S.fold
      (fun (w, l) -> f (v, l, w))
      (snd (HM.find_and_raise v g "[ocamlgraph] fold_succ_e"))

  let succ g v = fold_succ (fun w l -> w :: l) g v []
  let succ_e g v = fold_succ_e (fun e l -> e :: l) g v []

  let map_vertex f =
    HM.map
      (fun v (s1,s2) ->
	 f v,
	 (S.fold (fun (v, l) s -> S.add (f v, l) s) s1 S.empty,
	  S.fold (fun (v, l) s -> S.add (f v, l) s) s2 S.empty))

  module I = struct
    type t = (S.t * S.t) HM.t
    module PV = V
    module PE = E
    let iter_edges f = HM.iter (fun v (_,outset) ->
      S.iter (fun (w, _) -> f v w) outset)
    let fold_edges f = HM.fold (fun v (_,outset) ->
      S.fold (fun (w, _) -> f v w) outset)
    let iter_edges_e f = HM.iter (fun v (_,outset) ->
      S.iter (fun (w, l) -> f (v, l, w)) outset)
    let fold_edges_e f = HM.fold (fun v (_,outset) ->
      S.fold (fun (w, l) -> f (v, l, w)) outset)
  end
  include I

  let iter_pred f g v =
    S.iter
      (fun (w, _) -> f w)
      (fst (HM.find_and_raise v g "[ocamlgraph] iter_pred"))

  let fold_pred f g v =
    S.fold
      (fun (w, _) -> f w)
      (fst (HM.find_and_raise v g "[ocamlgraph] fold_pred"))

  let in_degree g v =
    S.cardinal
      (fst (try HM.find v g
	    with Not_found -> invalid_arg "[ocamlgraph] in_degree"))

  let iter_pred_e f g v =
    S.iter
      (fun (w, l) -> f (w, l, v))
      (fst (HM.find_and_raise v g "[ocamlgraph] iter_pred_e"))

  let fold_pred_e f g v =
    S.fold
      (fun (w, l) -> f (w, l, v))
      (fst (HM.find_and_raise v g "[ocamlgraph] fold_pred_e"))

  let pred g v = fold_pred (fun w l -> w :: l) g v []
  let pred_e g v = fold_pred_e (fun e l -> e :: l) g v []

end

(** Build persistent (resp. imperative) graphs from a persistent (resp.
    imperative) association table *)
module Make(F : TBL_BUILDER) = struct

  module Digraph = struct

    module Concrete(V: COMPARABLE) = struct

      include ConcreteVertex(F)(V)
      include Unlabeled(V)(HM)
      include Minimal(S)(HM)

      let add_edge g v1 v2 =
	let g = add_vertex g v1 in
	let g = add_vertex g v2 in
	unsafe_add_edge g v1 v2

      let add_edge_e g (v1, v2) = add_edge g v1 v2

    end

    module ConcreteBidirectional(V: COMPARABLE) = struct

      include ConcreteVertex(F)(V)
      include BidirectionalUnlabeled(V)(HM)
      include BidirectionalMinimal(S)(HM)

      let unsafe_add_edge g v1 v2 =
        let in_set, out_set = HM.find v1 g in
        let g = HM.add v1 (in_set,S.add v2 out_set) g in
        let in_set, out_set = HM.find v2 g in
	HM.add v2 (S.add v1 in_set,out_set) g

      let add_edge g v1 v2 =
	let g = add_vertex g v1 in
	let g = add_vertex g v2 in
	unsafe_add_edge g v1 v2

      let add_edge_e g (v1, v2) = add_edge g v1 v2

    end

    module ConcreteLabeled(V: COMPARABLE)(Edge: ORDERED_TYPE_DFT) = struct

      include ConcreteVertex(F)(V)
      include Labeled(V)(Edge)(HM)
      include Minimal(S)(HM)

      let add_edge_e g (v1, l, v2) =
	let g = add_vertex g v1 in
	let g = add_vertex g v2 in
	unsafe_add_edge g v1 (v2, l)

      let add_edge g v1 v2 = add_edge_e g (v1, Edge.default, v2)

    end

    module ConcreteBidirectionalLabeled
      (V: COMPARABLE)(Edge: ORDERED_TYPE_DFT) =
    struct

      include ConcreteVertex(F)(V)
      include BidirectionalLabeled(V)(Edge)(HM)
      include BidirectionalMinimal(S)(HM)

      let unsafe_add_edge_e g (v1, l, v2) =
        let in_set, out_set = HM.find v1 g in
        let g = HM.add v1 (in_set,S.add (v2,l) out_set) g in
        let in_set, out_set = HM.find v2 g in
	HM.add v2 (S.add (v1,l) in_set,out_set) g

      let unsafe_add_edge g v1 v2 =
        unsafe_add_edge_e g (v1, Edge.default, v2)

      let add_edge_e g (v1, l, v2) =
	let g = add_vertex g v1 in
	let g = add_vertex g v2 in
	unsafe_add_edge_e g (v1, l, v2)

      let add_edge g v1 v2 = add_edge_e g (v1, Edge.default, v2)

    end

    module Abstract(V: VERTEX) = struct
      module G = struct
	module V = V
	module HM = F(V)
	include Unlabeled(V)(HM)
	include Minimal(S)(HM)
      end
      include Make_Abstract(G)
    end

    module AbstractLabeled(V: VERTEX)(E: ORDERED_TYPE_DFT) = struct
      module G = struct
	module V = V
	module HM = F(V)
	include Labeled(V)(E)(HM)
	include Minimal(S)(HM)
      end
      include Make_Abstract(G)
    end

  end

end

(** Implementation of undirected graphs from implementation of directed
    graphs. *)
module Graph
  (G: sig
     include Sig.G
     val create: ?size:int -> unit -> t
     val clear: t -> unit
     val copy: t -> t
     type return
     val add_vertex: t -> vertex -> return
     val remove_vertex: t -> vertex -> return
   end) =
struct

  include G

  let is_directed = false

  (* Redefine iterators and [nb_edges]. *)

  let iter_edges f =
    iter_edges (fun v1 v2 -> if V.compare v1 v2 >= 0 then f v1 v2)

  let fold_edges f =
    fold_edges
      (fun v1 v2 acc -> if V.compare v1 v2 >= 0 then f v1 v2 acc else acc)

  let iter_edges_e f =
    iter_edges_e (fun e -> if V.compare (E.src e) (E.dst e) >= 0 then f e)

  let fold_edges_e f =
    fold_edges_e
      (fun e acc ->
	 if V.compare (E.src e) (E.dst e) >= 0 then f e acc else acc)

  let nb_edges g = fold_edges_e (fun _ -> (+) 1) g 0

  (* Redefine operations on predecessors:
     predecessors are successors in an undirected graph. *)

  let pred = succ
  let in_degree = out_degree
  let iter_pred = iter_succ
  let fold_pred = fold_succ
  let pred_e = succ_e
  let iter_pred_e = iter_succ_e
  let fold_pred_e = fold_succ_e

end

(*
Local Variables:
compile-command: "make -C .."
End:
*)
end
module Persistent: sig
#0 "graph/persistent.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(** Persistent Graph Implementations. *)

open Sig

(** Signature of persistent graphs. *)
module type S = sig

  (** <b>Edges may be labeled or not</b>:
      - Unlabeled: there is no label on edges
      - Labeled: you have to provide a label implementation as a functor
      parameter.

      <b>Vertices may be concrete or abstract</b>:
      - Concrete: type of vertex labels and type of vertices are identified.
      - Abstract: type of vertices is abstract (in particular it is not equal
      to type of vertex labels

      <b>How to choose between concrete and abstract vertices for my graph
      implementation</b>?

      Usually, if you fall into one of the following cases, use abstract
      vertices:
      - you cannot provide efficient comparison/hash functions for vertices; or
      - you wish to get two different vertices with the same label.

      In other cases, it is certainly easier to use concrete vertices.  *)

  (** Persistent Unlabeled Graphs. *)
  module Concrete (V: COMPARABLE) :
    Sig.P with type V.t = V.t and type V.label = V.t and type E.t = V.t * V.t
	  and type E.label = unit

  (** Abstract Persistent Unlabeled Graphs. *)
  module Abstract(V: ANY_TYPE) : Sig.P with type V.label = V.t
				       and type E.label = unit

  (** Persistent Labeled Graphs. *)
  module ConcreteLabeled (V: COMPARABLE)(E: ORDERED_TYPE_DFT) :
    Sig.P with type V.t = V.t and type V.label = V.t
	    and type E.t = V.t * E.t * V.t and type E.label = E.t

  (** Abstract Persistent Labeled Graphs. *)
  module AbstractLabeled (V: ANY_TYPE)(E: ORDERED_TYPE_DFT) :
    Sig.P with type V.label = V.t and type E.label = E.t

end

(** Persistent Directed Graphs. *)
module Digraph : sig

  include S

  (** {2 Bidirectional graphs}

      Bidirectional graphs use more memory space (at worse the double) that
      standard concrete directional graphs. But accessing predecessors and
      removing a vertex are faster. *)

  (** Imperative Unlabeled, bidirectional graph. *)
  module ConcreteBidirectional (V: COMPARABLE) :
    Sig.P with type V.t = V.t and type V.label = V.t and type E.t = V.t * V.t
          and type E.label = unit

  (** Imperative Labeled and bidirectional graph. *)
  module ConcreteBidirectionalLabeled(V:COMPARABLE)(E:ORDERED_TYPE_DFT) :
    Sig.P with type V.t = V.t and type V.label = V.t
          and type E.t = V.t * E.t * V.t and type E.label = E.t

end

(** Persistent Undirected Graphs. *)
module Graph : S

(*
Local Variables:
compile-command: "make -C .."
End:
*)
end = struct
#0 "graph/persistent.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

open Sig
open Util
open Blocks

module type S = sig

  (** Persistent Unlabeled Graphs *)
  module Concrete (V: COMPARABLE) :
    Sig.P with type V.t = V.t and type V.label = V.t and type E.t = V.t * V.t
	  and type E.label = unit

  (** Abstract Persistent Unlabeled Graphs *)
  module Abstract(V: sig type t end) : Sig.P with type V.label = V.t
					     and type E.label = unit

  (** Persistent Labeled Graphs *)
  module ConcreteLabeled (V: COMPARABLE)(E: ORDERED_TYPE_DFT) :
    Sig.P with type V.t = V.t and type V.label = V.t
	    and type E.t = V.t * E.t * V.t and type E.label = E.t

  (** Abstract Persistent Labeled Graphs *)
  module AbstractLabeled (V: sig type t end)(E: ORDERED_TYPE_DFT) :
    Sig.P with type V.label = V.t and type E.label = E.t

end

module P = Make(Make_Map)

type 'a abstract_vertex = { tag : int; label : 'a }

(* Vertex for the abstract persistent graphs. *)
module AbstractVertex(V: sig type t end) = struct
  type label = V.t
  type t = label abstract_vertex
  let compare x y = Pervasives.compare x.tag y.tag
  let hash x = x.tag
  let equal x y = x.tag = y.tag
  let label x = x.label
  let create l =
    if !cpt_vertex = first_value_for_cpt_vertex - 1 then
      invalid_arg "Too much vertices";
    incr cpt_vertex;
    { tag = !cpt_vertex; label = l }
end

module Digraph = struct

  module Concrete(V:COMPARABLE) = struct
    include P.Digraph.Concrete(V)
    let remove_vertex g v =
      if HM.mem v g then
	let g = HM.remove v g in
	HM.fold (fun k s -> HM.add k (S.remove v s)) g empty
      else
	g
  end

  module ConcreteLabeled(V:COMPARABLE)(E:ORDERED_TYPE_DFT) = struct
    include P.Digraph.ConcreteLabeled(V)(E)
    let remove_vertex g v =
      if HM.mem v g then
	let g = HM.remove v g in
	let remove v = S.filter (fun (v2, _) -> not (V.equal v v2)) in
	HM.fold (fun k s -> HM.add k (remove v s)) g empty
      else
	g
  end

  module ConcreteBidirectional(V: COMPARABLE) = struct
    include P.Digraph.ConcreteBidirectional(V)
    let remove_vertex g v =
      if HM.mem v g then
	let remove v = S.filter (fun v' -> not (V.equal v v')) in
	let g =
	  fold_pred
	    (fun v' acc ->
	       let in_set, out_set = HM.find v' acc in
	       HM.add v' (in_set, remove v out_set) acc)
	    g v g
	in
	let g =
	  fold_succ
	    (fun v' acc ->
	       let in_set, out_set = HM.find v' acc in
	       HM.add v' (remove v in_set, out_set) acc)
	    g v g
	in
	HM.remove v g
      else
	g
  end

  module ConcreteBidirectionalLabeled(V:COMPARABLE)(E:ORDERED_TYPE_DFT) = struct
    include P.Digraph.ConcreteBidirectionalLabeled(V)(E)
    let remove_vertex (g:t) (v:vertex) =
      if HM.mem v g then
	let remove v = S.filter (fun (v', _) -> not (V.equal v v')) in
	let g =
	  fold_pred
	    (fun v' acc ->
	       let in_set, out_set = HM.find v' acc in
	       HM.add v' (in_set, remove v out_set) acc)
	    g v g
	in
	let g =
	  fold_succ
	    (fun v' acc ->
	       let in_set, out_set = HM.find v' acc in
	       HM.add v' (remove v in_set, out_set) acc)
	    g v g
	in
	HM.remove v g
      else
	g
  end

  module Abstract(V: sig type t end) = struct

    include P.Digraph.Abstract(AbstractVertex(V))

    let empty = { edges = G.empty; size = 0 }

    let add_vertex g v =
      if mem_vertex g v then
	g
      else
	{ edges = G.unsafe_add_vertex g.edges v;
	  size = Pervasives.succ g.size }

    let add_edge g v1 v2 =
      let g = add_vertex g v1 in
      let g = add_vertex g v2 in
      { g with edges = G.unsafe_add_edge g.edges v1 v2 }

    let add_edge_e g (v1, v2) = add_edge g v1 v2

    let remove_vertex g v =
      if HM.mem v g.edges then
	let e = HM.remove v g.edges in
	let e = HM.fold (fun k s g -> HM.add k (S.remove v s) g) e HM.empty in
	{ edges = e; size = Pervasives.pred g.size }
      else
	g

    let remove_edge g v1 v2 = { g with edges = remove_edge g v1 v2 }
    let remove_edge_e g e = { g with edges = remove_edge_e g e }

  end

  module AbstractLabeled(V: sig type t end)(Edge: ORDERED_TYPE_DFT) = struct

    include P.Digraph.AbstractLabeled(AbstractVertex(V))(Edge)

    let empty = { edges = G.empty; size = 0 }

    let add_vertex g v =
      if mem_vertex g v then
	g
      else
	{ edges = G.unsafe_add_vertex g.edges v;
	  size = Pervasives.succ g.size }

    let add_edge_e g (v1, l, v2) =
      let g = add_vertex g v1 in
      let g = add_vertex g v2 in
      { g with edges = G.unsafe_add_edge g.edges v1 (v2, l) }

    let add_edge g v1 v2 = add_edge_e g (v1, Edge.default, v2)

    let remove_vertex g v =
      if HM.mem v g.edges then
	let remove v s =
	  S.fold
	    (fun (v2, _ as e) s -> if not (V.equal v v2) then S.add e s else s)
	    s S.empty
	in
	let edges = HM.remove v g.edges in
	{ edges =
	    HM.fold (fun k s g -> HM.add k (remove v s) g) edges HM.empty;
	  size = Pervasives.pred g.size }
      else
	g

    let remove_edge g v1 v2 = { g with edges = remove_edge g v1 v2 }
    let remove_edge_e g e = { g with edges = remove_edge_e g e }

  end

end

module Graph = struct

  module Concrete(V: COMPARABLE) = struct

    module G = struct include Digraph.Concrete(V) type return = t end
    include Graph(G)

    (* Export some definitions of [G] *)
    let empty = G.empty

    (* Redefine the [add_edge] and [remove_edge] operations *)

    let add_edge g v1 v2 =
      let g = G.add_edge g v1 v2 in
      assert (G.HM.mem v1 g && G.HM.mem v2 g);
      G.unsafe_add_edge g v2 v1

    let add_edge_e g (v1, v2) = add_edge g v1 v2

    let remove_edge g v1 v2 =
      let g = G.remove_edge g v1 v2 in
      assert (G.HM.mem v1 g && G.HM.mem v2 g);
      G.unsafe_remove_edge g v2 v1

    let remove_edge_e g (v1, v2) = remove_edge g v1 v2

  end

  module ConcreteLabeled(V: COMPARABLE)(Edge: ORDERED_TYPE_DFT) = struct

    module G = struct
      include Digraph.ConcreteLabeled(V)(Edge)
      type return = t
    end
    include Graph(G)

    (* Export some definitions of [G] *)
    let empty = G.empty

    (* Redefine the [add_edge] and [remove_edge] operations *)

    let add_edge_e g (v1, l, v2 as e) =
      let g = G.add_edge_e g e in
      assert (G.HM.mem v1 g && G.HM.mem v2 g);
      G.unsafe_add_edge g v2 (v1, l)

    let add_edge g v1 v2 = add_edge_e g (v1, Edge.default, v2)

    let remove_edge g v1 v2 =
      let g = G.remove_edge g v1 v2 in
      assert (G.HM.mem v1 g && G.HM.mem v2 g);
      G.unsafe_remove_edge g v2 v1

    let remove_edge_e g (v1, l, v2 as e) =
      let g = G.remove_edge_e g e in
      assert (G.HM.mem v1 g && G.HM.mem v2 g);
      G.unsafe_remove_edge_e g (v2, l, v1)

  end

  module Abstract(V: sig type t end) = struct

    module G = struct include Digraph.Abstract(V) type return = t end
    include Graph(G)

    (* Export some definitions of [G] *)
    let empty = G.empty

    (* Redefine the [add_edge] and [remove_edge] operations *)

    let add_edge g v1 v2 =
      let g = G.add_edge g v1 v2 in
      assert (G.HM.mem v1 g.G.edges && G.HM.mem v2 g.G.edges);
      { g with G.edges = G.unsafe_add_edge g.G.edges v2 v1 }

    let add_edge_e g (v1, v2) = add_edge g v1 v2

    let remove_edge g v1 v2 =
      let g = G.remove_edge g v1 v2 in
      assert (G.HM.mem v1 g.G.edges && G.HM.mem v2 g.G.edges);
      { g with G.edges = G.unsafe_remove_edge g.G.edges v2 v1 }

    let remove_edge_e g (v1, v2) = remove_edge g v1 v2

  end

  module AbstractLabeled (V: sig type t end)(Edge: ORDERED_TYPE_DFT) = struct

    module G = struct
      include Digraph.AbstractLabeled(V)(Edge)
      type return = t
    end
    include Graph(G)

    (* Export some definitions of [G] *)
    let empty = G.empty

    (* Redefine the [add_edge] and [remove_edge] operations *)

    let add_edge_e g (v1, l, v2 as e) =
      let g = G.add_edge_e g e in
      assert (G.HM.mem v1 g.G.edges && G.HM.mem v2 g.G.edges);
      { g with G.edges = G.unsafe_add_edge g.G.edges v2 (v1, l) }

    let add_edge g v1 v2 = add_edge_e g (v1, Edge.default, v2)

    let remove_edge g v1 v2 =
      let g = G.remove_edge g v1 v2 in
      assert (G.HM.mem v1 g.G.edges && G.HM.mem v2 g.G.edges);
      { g with G.edges = G.unsafe_remove_edge g.G.edges v2 v1 }

    let remove_edge_e g (v1, l, v2 as e) =
      let g = G.remove_edge_e g e in
      assert (G.HM.mem v1 g.G.edges && G.HM.mem v2 g.G.edges);
      { g with G.edges = G.unsafe_remove_edge_e g.G.edges (v2, l, v1) }

  end

end

(*
Local Variables:
compile-command: "make -C .."
End:
*)
end
module Imperative: sig
#0 "graph/imperative.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(** Imperative Graph Implementations. *)

open Sig

(** Signature of imperative graphs. *)
module type S = sig

  (** <b>Edges may be labeled or not</b>:
      - Unlabeled: there is no label on edges
      - Labeled: you have to provide a label implementation as a functor
      parameter.

      <b>Vertices may be concrete or abstract</b>:
      - Concrete: type of vertex labels and type of vertices are identified.
      - Abstract: type of vertices is abstract (in particular it is not equal
      to type of vertex labels

      <b>How to choose between concrete and abstract vertices for my graph
      implementation</b>?

      Usually, if you fall into one of the following cases, use abstract
      vertices:
      - you cannot provide efficient comparison/hash functions for vertices; or
      - you wish to get two different vertices with the same label.

      In other cases, it is certainly easier to use concrete vertices.  *)

  (** Imperative Unlabeled Graphs. *)
  module Concrete (V: COMPARABLE) :
    Sig.I with type V.t = V.t and type V.label = V.t and type E.t = V.t * V.t
	  and type E.label = unit

  (** Abstract Imperative Unlabeled Graphs. *)
  module Abstract(V: ANY_TYPE) :
    Sig.IM with type V.label = V.t and type E.label = unit

  (** Imperative Labeled Graphs. *)
  module ConcreteLabeled (V: COMPARABLE)(E: ORDERED_TYPE_DFT) :
    Sig.I with type V.t = V.t and type V.label = V.t
	    and type E.t = V.t * E.t * V.t and type E.label = E.t

  (** Abstract Imperative Labeled Graphs. *)
  module AbstractLabeled (V: ANY_TYPE)(E: ORDERED_TYPE_DFT) :
    Sig.IM with type V.label = V.t and type E.label = E.t

end

(** Imperative Directed Graphs. *)
module Digraph : sig

  include S

  (** {2 Bidirectional graphs}

      Bidirectional graphs use more memory space (at worse the double) that
      standard concrete directional graphs. But accessing predecessors is in
      O(1) amortized instead of O(max(|V|,|E|)) and removing a vertex is in
      O(D*ln(D)) instead of O(|V|*ln(D)). D is the maximal degree of the
      graph. *)

  (** Imperative Unlabeled, bidirectional graph. *)
  module ConcreteBidirectional (V: COMPARABLE) :
    Sig.I with type V.t = V.t and type V.label = V.t and type E.t = V.t * V.t
          and type E.label = unit

  (** Imperative Labeled and bidirectional graph. *)
  module ConcreteBidirectionalLabeled(V:COMPARABLE)(E:ORDERED_TYPE_DFT) :
    Sig.I with type V.t = V.t and type V.label = V.t
          and type E.t = V.t * E.t * V.t and type E.label = E.t

end

(** Imperative Undirected Graphs. *)
module Graph : S

(** Imperative graphs implemented as adjacency matrices. *)
module Matrix : sig

  module type S = sig

    (** Vertices are integers in [0..n-1].
        A vertex label is the vertex itself.
        Edges are unlabeled. *)

    include Sig.I with type V.t = int and type V.label = int
		  and type E.t = int * int

    (** Creation. graphs are not resizeable: size is given at creation time.
        Thus [make] must be used instead of [create]. *)
    val make : int -> t

  (** Note: [add_vertex] and [remove_vertex] have no effect.
      [clear] only removes edges, not vertices. *)

  end

  module Digraph : S
    (** Imperative Directed Graphs implemented with adjacency matrices. *)

  module Graph : S
    (** Imperative Undirected Graphs implemented with adjacency matrices. *)

end

(****
(** Faster implementations for abstract (un)labeled (di)graphs
    when vertices are _not shared_ between different graphs.
    This means that, when using the following implementations, two different
    graphs (created with two calls to [create]) must have disjoint sets of
    vertices. *)
module UV : sig

  (** directed graphs *)
  module Digraph : sig

    module Abstract(V: ANY_TYPE) :
      Sig.IM with type V.label = V.t and type E.label = unit

    module AbstractLabeled (V: ANY_TYPE)(E: ORDERED_TYPE_DFT) :
      Sig.IM with type V.label = V.t and type E.label = E.t

  end

  (** undirected graphs *)
  module Graph : sig

    module Abstract(V: ANY_TYPE) :
      Sig.IM with type V.label = V.t and type E.label = unit

    module AbstractLabeled (V: ANY_TYPE)(E: ORDERED_TYPE_DFT) :
      Sig.IM with type V.label = V.t and type E.label = E.t

  end

end
****)

(*
Local Variables:
compile-command: "make -C .."
End:
*)
end = struct
#0 "graph/imperative.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

open Sig
open Blocks

module type S = sig

  (** Imperative Unlabeled Graphs *)
  module Concrete (V: COMPARABLE) :
    Sig.I with type V.t = V.t and type V.label = V.t and type E.t = V.t * V.t
	  and type E.label = unit

  (** Abstract Imperative Unlabeled Graphs *)
  module Abstract(V: sig type t end) :
    Sig.IM with type V.label = V.t and type E.label = unit
	   and type E.label = unit

  (** Imperative Labeled Graphs *)
  module ConcreteLabeled (V: COMPARABLE)(E: ORDERED_TYPE_DFT) :
    Sig.I with type V.t = V.t and type V.label = V.t
	    and type E.t = V.t * E.t * V.t and type E.label = E.t

  (** Abstract Imperative Labeled Graphs *)
  module AbstractLabeled (V: sig type t end)(E: ORDERED_TYPE_DFT) :
    Sig.IM with type V.label = V.t and type E.label = E.t

end

module I = Make(Make_Hashtbl)

type 'a abstract_vertex = { tag : int; label : 'a; mutable mark : int }

(* Implement module type [MARK]. *)
module Make_Mark
  (X: sig
     type graph
     type label
     val iter_vertex : (label abstract_vertex -> unit) -> graph -> unit
   end) =
struct
  type vertex = X.label abstract_vertex
  type graph = X.graph
  let get v = v.mark
  let set v m = v.mark <- m
  let clear g = X.iter_vertex (fun v -> set v 0) g
end

(* Vertex for abstract imperative graphs:
   comparing to vertex for abstract **persistent** graphs, marks are added. *)
module AbstractVertex(V: sig type t end) = struct
  type label = V.t
  type t = label abstract_vertex
  let compare x y = Pervasives.compare x.tag y.tag
  let hash x = x.tag
  let equal x y = x.tag = y.tag
  let label x = x.label
  let create l =
    if !cpt_vertex = first_value_for_cpt_vertex - 1 then
      invalid_arg "Too much vertices";
    incr cpt_vertex;
    { tag = !cpt_vertex; label = l; mark = 0 }
end

module Digraph = struct

  module Concrete(V: COMPARABLE) = struct
    include I.Digraph.Concrete(V)
    let add_vertex g v = ignore (add_vertex g v)
    let add_edge g v1 v2 = ignore (add_edge g v1 v2)
    let remove_edge g v1 v2 = ignore (remove_edge g v1 v2)
    let remove_edge_e g e = ignore (remove_edge_e g e)
    let add_edge_e g e = ignore (add_edge_e g e)
    let remove_vertex g v =
      if HM.mem v g then begin
	ignore (HM.remove v g);
	HM.iter (fun k s -> ignore (HM.add k (S.remove v s) g)) g
      end
  end

  module ConcreteLabeled(V: COMPARABLE)(E: ORDERED_TYPE_DFT) = struct
    include I.Digraph.ConcreteLabeled(V)(E)
    let add_vertex g v = ignore (add_vertex g v)
    let remove_edge g v1 v2 = ignore (remove_edge g v1 v2)
    let remove_edge_e g e = ignore (remove_edge_e g e)
    let add_edge_e g e = ignore (add_edge_e g e)
    let add_edge g v1 v2 = ignore (add_edge g v1 v2)
    let remove_vertex g v =
      if HM.mem v g then begin
	ignore (HM.remove v g);
	let remove v = S.filter (fun (v2, _) -> not (V.equal v v2)) in
	HM.iter (fun k s -> ignore (HM.add k (remove v s) g)) g
      end
  end

  module ConcreteBidirectional(V: COMPARABLE) = struct

    include I.Digraph.ConcreteBidirectional(V)

    let add_vertex g v = ignore (add_vertex g v)

    let add_edge g v1 v2 =
      add_vertex g v1;
      add_vertex g v2;
      ignore (unsafe_add_edge g v1 v2)

    let add_edge_e g (v1, v2) = add_edge g v1 v2

    let remove_edge g v1 v2 = ignore (remove_edge g v1 v2)
    let remove_edge_e g e = ignore (remove_edge_e g e)

    let remove_vertex g v =
      if HM.mem v g then begin
	iter_pred_e (fun e -> remove_edge_e g e) g v;
	iter_succ_e (fun e -> remove_edge_e g e) g v;
	ignore (HM.remove v g)
      end

  end

  module ConcreteBidirectionalLabeled(V:COMPARABLE)(E:ORDERED_TYPE_DFT) = struct

    include I.Digraph.ConcreteBidirectionalLabeled(V)(E)

    let add_vertex g v = ignore (add_vertex g v)

    let add_edge g v1 v2 =
      add_vertex g v1;
      add_vertex g v2;
      ignore (unsafe_add_edge g v1 v2)

    let add_edge_e g (v1, l, v2) =
      add_vertex g v1;
      add_vertex g v2;
      ignore (unsafe_add_edge_e g (v1, l, v2))

    let remove_edge g v1 v2 = ignore (remove_edge g v1 v2)
    let remove_edge_e g e = ignore (remove_edge_e g e)

    let remove_vertex g v =
      if HM.mem v g then begin
        iter_pred_e (fun e -> remove_edge_e g e) g v;
	iter_succ_e (fun e -> remove_edge_e g e) g v;
        ignore (HM.remove v g)
      end

  end

  module Abstract(V: sig type t end) = struct

    include I.Digraph.Abstract(AbstractVertex(V))

    let add_vertex g v =
      if not (HM.mem v g.edges) then begin
	g.size <- Pervasives.succ g.size;
	ignore (G.unsafe_add_vertex g.edges v)
      end

    let add_edge g v1 v2 =
      add_vertex g v1;
      add_vertex g v2;
      ignore (unsafe_add_edge g.edges v1 v2)

    let add_edge_e g (v1, v2) = add_edge g v1 v2

    let remove_vertex g v =
      if HM.mem v g.edges then
	let e = g.edges in
	ignore (HM.remove v e);
	HM.iter (fun k s -> ignore (HM.add k (S.remove v s) e)) e;
	g.size <- Pervasives.pred g.size

    module Mark =
      Make_Mark
	(struct
	   type graph = t
	   type label = V.label
	   let iter_vertex = iter_vertex
	 end)

    let remove_edge g v1 v2 = ignore (remove_edge g v1 v2)
    let remove_edge_e g e = ignore (remove_edge_e g e)

  end

  module AbstractLabeled(V: sig type t end)(Edge: ORDERED_TYPE_DFT) = struct

    include I.Digraph.AbstractLabeled(AbstractVertex(V))(Edge)

    let add_vertex g v =
      if not (HM.mem v g.edges) then begin
	g.size <- Pervasives.succ g.size;
	ignore (G.unsafe_add_vertex g.edges v)
      end

    let add_edge_e g (v1, l, v2) =
      add_vertex g v1;
      add_vertex g v2;
      ignore (unsafe_add_edge g.edges v1 (v2, l))

    let add_edge g v1 v2 = add_edge_e g (v1, Edge.default, v2)

    let remove_vertex g v =
      if HM.mem v g.edges then
	let remove s =
	  S.fold
	    (fun (v2, _ as e) s -> if not (V.equal v v2) then S.add e s else s)
	    s S.empty
	in
	let e = g.edges in
	ignore (HM.remove v e);
	HM.iter (fun k s -> ignore (HM.add k (remove s) e)) e;
	g.size <- Pervasives.pred g.size

    module Mark =
      Make_Mark
	(struct
	   type graph = t
	   type label = V.label
	   let iter_vertex = iter_vertex
	 end)

    let remove_edge g v1 v2 = ignore (remove_edge g v1 v2)
    let remove_edge_e g e = ignore (remove_edge_e g e)

  end

end

module Graph = struct

  module Concrete(V: COMPARABLE) = struct

    module G = struct include Digraph.Concrete(V) type return = unit end
    include Graph(G)

    (* Redefine the [add_edge] and [remove_edge] operations *)

    let add_edge g v1 v2 =
      G.add_edge g v1 v2;
      assert (G.HM.mem v1 g && G.HM.mem v2 g);
      ignore (G.unsafe_add_edge g v2 v1)

    let add_edge_e g (v1, v2) = add_edge g v1 v2

    let remove_edge g v1 v2 =
      G.remove_edge g v1 v2;
      assert (G.HM.mem v1 g && G.HM.mem v2 g);
      ignore (G.unsafe_remove_edge g v2 v1)

    let remove_edge_e g (v1, v2) = remove_edge g v1 v2

  end

  module ConcreteLabeled (V: COMPARABLE)(Edge: ORDERED_TYPE_DFT) = struct

    module G = struct
      include Digraph.ConcreteLabeled(V)(Edge)
      type return = unit
    end
    include Graph(G)

    (* Redefine the [add_edge] and [remove_edge] operations *)

    let add_edge_e g (v1, l, v2 as e) =
      G.add_edge_e g e;
      assert (G.HM.mem v1 g && G.HM.mem v2 g);
      ignore (G.unsafe_add_edge g v2 (v1, l))

    let add_edge g v1 v2 = add_edge_e g (v1, Edge.default, v2)

    let remove_edge g v1 v2 =
      G.remove_edge g v1 v2;
      assert (G.HM.mem v1 g && G.HM.mem v2 g);
      ignore (G.unsafe_remove_edge g v2 v1)

    let remove_edge_e g (v1, l, v2 as e) =
      G.remove_edge_e g e;
      assert (G.HM.mem v1 g && G.HM.mem v2 g);
      ignore (G.unsafe_remove_edge_e g (v2, l, v1))

  end

  module Abstract(V: sig type t end) = struct

    module G = struct include Digraph.Abstract(V) type return = unit end
    include Graph(G)

    (* Export some definitions of [G] *)
    module Mark = G.Mark

    (* Redefine the [add_edge] and [remove_edge] operations *)

    let add_edge g v1 v2 =
      G.add_edge g v1 v2;
      assert (G.HM.mem v1 g.G.edges && G.HM.mem v2 g.G.edges);
      ignore (G.unsafe_add_edge g.G.edges v2 v1)

    let add_edge_e g (v1, v2) = add_edge g v1 v2

    let remove_edge g v1 v2 =
      G.remove_edge g v1 v2;
      assert (G.HM.mem v1 g.G.edges && G.HM.mem v2 g.G.edges);
      ignore (G.unsafe_remove_edge g.G.edges v2 v1)

    let remove_edge_e g (v1, v2) = remove_edge g v1 v2

  end

  module AbstractLabeled (V: sig type t end)(Edge: ORDERED_TYPE_DFT) = struct

    module G = struct
      include Digraph.AbstractLabeled(V)(Edge)
      type return = unit
    end
    include Graph(G)

    (* Export some definitions of [G] *)
    module Mark = G.Mark

    (* Redefine the [add_edge] and [remove_edge] operations *)

    let add_edge_e g (v1, l, v2 as e) =
      G.add_edge_e g e;
      assert (G.HM.mem v1 g.G.edges && G.HM.mem v2 g.G.edges);
      ignore (G.unsafe_add_edge g.G.edges v2 (v1, l))

    let add_edge g v1 v2 = add_edge_e g (v1, Edge.default, v2)

    let remove_edge g v1 v2 =
      G.remove_edge g v1 v2;
      assert (G.HM.mem v1 g.G.edges && G.HM.mem v2 g.G.edges);
      ignore (G.unsafe_remove_edge g.G.edges v2 v1)

    let remove_edge_e g (v1, l, v2 as e) =
      ignore (G.remove_edge_e g e);
      assert (G.HM.mem v1 g.G.edges && G.HM.mem v2 g.G.edges);
      ignore (G.unsafe_remove_edge_e g.G.edges (v2, l, v1))

  end

end

module Matrix = struct

  module type S = sig
    include Sig.I with type V.t = int and type V.label = int
		  and type E.t = int * int
    val make : int -> t
  end

  module Digraph = struct

    module V = struct
      type t = int
      type label = int
      let compare : t -> t -> int = Pervasives.compare
      let hash = Hashtbl.hash
      let equal = (==)
      let create i = i
      let label i = i
    end

    module E = struct
      type t = V.t * V.t
      type vertex = V.t
      let compare : t -> t -> int = Pervasives.compare
      type label = unit
      let create v1 _ v2 = (v1, v2)
      let src = fst
      let dst = snd
      let label _ = ()
    end

    type t = Bitv.t array
    type vertex = V.t
    type edge = E.t

    let create ?size () =
      failwith
	"[ocamlgraph] do not use Matrix.create; please use Matrix.make instead"

    let make n =
      if n < 0 then invalid_arg "[ocamlgraph] Matrix.make";
      Array.init n (fun _ -> Bitv.create n false)

    let is_directed = true

    let nb_vertex = Array.length
    let is_empty g = nb_vertex g = 0
    let nb_edges =
      Array.fold_left (Bitv.fold_left (fun n b -> if b then n+1 else n)) 0

    let mem_vertex g v = 0 <= v && v < nb_vertex g
    let mem_edge g i j = Bitv.get g.(i) j
    let mem_edge_e g (i,j) = Bitv.get g.(i) j
    let find_edge g i j = if mem_edge g i j then i, j else raise Not_found

    (* constructors *)
    let add_edge g i j = Bitv.set g.(i) j true
    let add_edge_e g (i,j) = Bitv.set g.(i) j true

    let remove_edge g i j = Bitv.set g.(i) j false
    let remove_edge_e g (i,j) = Bitv.set g.(i) j false

    let unsafe_add_edge g i j =
      Bitv.unsafe_set (Array.unsafe_get g i) j true
    let unsafe_remove_edge g i j =
      Bitv.unsafe_set (Array.unsafe_get g i) j false

    let remove_vertex g _ = ()
    let add_vertex g _ = ()

    let clear g =
      Array.iter (fun b -> Bitv.iteri (fun j _ -> Bitv.set b j false) b) g

    let copy g = Array.init (nb_vertex g) (fun i -> Bitv.copy g.(i))

    (* iter/fold on all vertices/edges of a graph *)
    let iter_vertex f g =
      for i = 0 to nb_vertex g - 1 do f i done

    let iter_edges f g =
      for i = 0 to nb_vertex g - 1 do
	Bitv.iteri (fun j b -> if b then f i j) g.(i)
      done

    let fold_vertex f g a =
      let n = nb_vertex g in
      let rec fold i a = if i = n then a else fold (i+1) (f i a) in fold 0 a

    let fold_edges f g a =
      fold_vertex
	(fun i a ->
	   Bitv.foldi_right (fun j b a -> if b then f i j a else a) g.(i) a)
	g a

    (* successors and predecessors of a vertex *)
    let succ g i =
      Bitv.foldi_left (fun l j b -> if b then j::l else l) [] g.(i)

    let pred g i =
      fold_vertex
	(fun j a -> if Bitv.unsafe_get g.(j) i then j :: a else a)
	g []

    (* iter/fold on all successor/predecessor of a vertex. *)
    let iter_succ f g i =
      let si = g.(i) in
      for j = 0 to nb_vertex g - 1 do if Bitv.unsafe_get si j then f j done
      (* optimization w.r.t.
	 [Bitv.iteri (fun j b -> if b then f j) g.(i)]
      *)

    let iter_pred f g i =
      for j = 0 to nb_vertex g - 1 do if Bitv.unsafe_get g.(j) i then f j done

    let fold_succ f g i a =
      Bitv.foldi_right (fun j b a -> if b then f j a else a) g.(i) a

    let fold_pred f g i a =
      fold_vertex
	(fun j a -> if Bitv.unsafe_get g.(j) i then f j a else a)
	g a

    (* degree *)
    let out_degree g i = fold_succ (fun _ n -> n + 1) g i 0

    let in_degree g i = fold_pred (fun _ n -> n + 1) g i 0

    (* map iterator on vertex *)
    let map_vertex f g =
      let n = nb_vertex g in
      let g' = make n in
      iter_edges
	(fun i j ->
	   let fi = f i in
	   let fj = f j in
	   if fi < 0 || fi >= n || fj < 0 || fj >= n then
	     invalid_arg "[ocamlgraph] map_vertex";
	   Bitv.unsafe_set g'.(fi) fj true)
	g;
      g'

    (* labeled edges going from/to a vertex *)
    (* successors and predecessors of a vertex *)
    let succ_e g i =
      Bitv.foldi_left (fun l j b -> if b then (i,j)::l else l) [] g.(i)

    let pred_e g i =
      fold_vertex
	(fun j a -> if Bitv.unsafe_get g.(j) i then (j,i) :: a else a)
	g []

    (* iter/fold on all labeled edges of a graph *)
    let iter_edges_e f g =
      for i = 0 to nb_vertex g - 1 do
	Bitv.iteri (fun j b -> if b then f (i,j)) g.(i)
      done

    let fold_edges_e f g a =
      fold_vertex
	(fun i a ->
	   Bitv.foldi_right (fun j b a -> if b then f (i,j) a else a) g.(i) a)
	g a

    (* iter/fold on all edges going from/to a vertex *)
    let iter_succ_e f g i =
      let si = g.(i) in
      for j = 0 to nb_vertex g - 1 do if Bitv.unsafe_get si j then f (i,j) done

    let iter_pred_e f g i =
      for j = 0 to nb_vertex g - 1 do
	if Bitv.unsafe_get g.(j) i then f (j,i)
      done

    let fold_succ_e f g i a =
      Bitv.foldi_right (fun j b a -> if b then f (i,j) a else a) g.(i) a

    let fold_pred_e f g i a =
      fold_vertex
	(fun j a -> if Bitv.unsafe_get g.(j) i then f (j,i) a else a)
	g a

  end

  module Graph = struct

    module G = struct include Digraph type return = unit end
    include Blocks.Graph(G)

    (* Export some definitions of [G] *)
    let make = G.make

    (* Redefine the [add_edge] and [remove_edge] operations *)

    let add_edge g v1 v2 =
      G.add_edge g v1 v2;
      ignore (G.unsafe_add_edge g v2 v1)

    let add_edge_e g (v1, v2) = add_edge g v1 v2

    let remove_edge g v1 v2 =
      G.remove_edge g v1 v2;
      ignore (G.unsafe_remove_edge g v2 v1)

    let remove_edge_e g (v1, v2) = remove_edge g v1 v2

  end

end

(* Faster implementations when vertices are not shared between graphs. *)
(****

module UV = struct

  let cpt_vertex = ref min_int

  type ('label, 'succ) vertex = {
    tag : int;
    label : 'label;
    mutable mark : int;
    mutable succ : 'succ;
  }

  module Digraph = struct

    module Abstract(L: ANY_TYPE) :
      Sig.IM with type V.label = L.t and type E.label = unit
    =
    struct

      module rec V :
        VERTEX with type label = L.t and type t = (L.t, S.t) vertex  =
      struct
	type label = L.t
	type t = (L.t, S.t) vertex

	let compare x y = compare x.tag y.tag
	let hash x = Hashtbl.hash x.tag
	let equal x y = x.tag = y.tag
	let label x = x.label

	let create l =
	  assert (!cpt_vertex < max_int);
	  incr cpt_vertex;
	  { tag = !cpt_vertex; label = l; mark = 0; succ = S.empty }
      end
      and S : Set.S with type elt = V.t = Set.Make(V)

      type vertex = V.t

      module E = struct
	type t = V.t * V.t
	type vertex = V.t
	let compare = Pervasives.compare
	type label = unit
	let create v1 _ v2 = (v1, v2)
	let src = fst
	let dst = snd
	let label _ = ()
      end

      type edge = E.t

      type t = {
	mutable vertices : S.t;
      }

      let create ?size () = { vertices = S.empty }
      let is_directed = true
      let is_empty g = S.is_empty g.vertices
      let nb_vertex g = S.cardinal g.vertices
      let out_degree _ v = S.cardinal v.succ

      let add_vertex g v = g.vertices <- S.add v g.vertices
      let mem_vertex g v = S.mem v g.vertices
      let iter_vertex f g = S.iter f g.vertices
      let fold_vertex f g = S.fold f g.vertices
      let succ _ v = S.elements v.succ

    end

    module AbstractLabeled (V: ANY_TYPE)(E: ORDERED_TYPE_DFT) :
      Sig.IM with type V.label = V.t and type E.label = E.t
    =
    AbstractLabeled
      (V)(struct type t = unit let compare _ _ = 0 let default = () end)

  end

  module Graph = struct

    module Abstract(V: ANY_TYPE) :
      Sig.IM with type V.label = V.t and type E.label = unit

    module AbstractLabeled (V: ANY_TYPE)(E: ORDERED_TYPE_DFT) :
      Sig.IM with type V.label = V.t and type E.label = E.t

  end

end
*****)

(*
Local Variables:
compile-command: "make -C .."
End:
*)
end
module Delaunay: sig
#0 "graph/delaunay.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: delaunay.mli,v 1.8 2004-02-20 14:37:40 signoles Exp $ *)

(** Delaunay triangulation. *)

(** Delaunay triangulation is available for any CCC system in the sense
    of Knuth's ``Axioms and Hulls'' *)
module type CCC = sig

  type point

  val ccw : point -> point -> point -> bool
    (** The counterclockwise relation [ccw p q r] states that the 
      circle through points [(p,q,r)] is traversed counterclockwise 
      when we encounter the points in cyclic order [p,q,r,p,...] **)

  val in_circle : point -> point -> point -> point -> bool
    (** The relation [in_circle p q r s] states that [s] lies 
      inside the circle [(p,q,r)] if [ccw p q r] is true, or outside that 
      circle if [ccw p q r] is false. *)

end

(** The result of triangulation is an abstract value of type [triangulation].
  Then one can iterate over all edges of the triangulation. *)
module type Triangulation = sig

  module S : CCC

  type triangulation

  val triangulate : S.point array -> triangulation
    (** [triangulate a] computes the Delaunay triangulation of a set of 
      points, given as an array [a]. If [N] is the number of points
      (that is [Array.length a]), then the running time is $O(N \log N)$
      on the average and $O(N^2)$ on the worst-case. The space used is 
      always $O(N)$. *)

  val iter : (S.point -> S.point -> unit) -> triangulation -> unit
    (** [iter f t] iterates over all edges of the triangulation [t]. 
      [f u v] is called once for each undirected edge [(u,v)]. *)

  val fold : (S.point -> S.point -> 'a -> 'a) -> triangulation -> 'a -> 'a

  val iter_triangles : 
    (S.point -> S.point -> S.point -> unit) -> triangulation -> unit

end

(** Generic Delaunay triangulation *)
module Make(S : CCC) : Triangulation with module S = S

(** Points with integer coordinates *)
module IntPoints : CCC with type point = int * int

(** Delaunay triangulation with integer coordinates *)
module Int : Triangulation with module S = IntPoints

(** Points with floating point coordinates *)
module FloatPoints : CCC with type point = float * float

(** Delaunay triangulation with floating point coordinates *)
module Float : Triangulation with module S = FloatPoints
end = struct
#0 "graph/delaunay.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: delaunay.ml,v 1.12 2005-11-02 13:43:35 filliatr Exp $ *)

(** Code follows Don Knuth's algorithm
    from ``Axioms and hulls'' (LNCS 606, Springer-Verlag, 1992), pp. 73-77.

    Some code and comments are taken from the Stanford Graph Base,
    file [gb_plane].
*)

open Printf

module type CCC = sig
  type point
  val ccw : point -> point -> point -> bool
  val in_circle : point -> point -> point -> point -> bool
end

module type Triangulation = sig
  module S : CCC
  type triangulation
  val triangulate : S.point array -> triangulation
  val iter : (S.point -> S.point -> unit) -> triangulation -> unit
  val fold : (S.point -> S.point -> 'a -> 'a) -> triangulation -> 'a -> 'a
  val iter_triangles : 
    (S.point -> S.point -> S.point -> unit) -> triangulation -> unit
end

module Make (S : CCC) = struct

  module S = S

  type point = Point of int | Infinity

  (* Each edge of the current triangulation is represented by two arcs
     pointing in opposite directions; the two arcs are called mates. Each
     arc conceptually has a triangle on its left and a mate on its right. *)

  type arc = { 
    mutable vert : point; 
      (* v, if this arc goes from u to v *)
    mutable next : arc; 
      (* the arc from v that shares a triangle with this one *)
    mutable inst : node ref;
      (* instruction to change when the triangle is modified *)
    mate : int 
  }
  and node = 
    | Branch of int * int * node ref * node ref
    | Terminal of arc

  type triangulation = { 
    points : S.point array; 
    arcs : arc array;
    last_used_arc : int 
  }

  let rec dummy_arc = 
    { vert = Infinity; next = dummy_arc; 
      inst = ref (Terminal dummy_arc); mate = -1 }

  let make_arc n i =
    { vert = Infinity; next = dummy_arc; 
      inst = ref (Terminal dummy_arc); mate = 6 * n - 7 - i }

  let finite = function Point p -> p | Infinity -> assert false

  (* [flip] will be used in both steps T4 and T5 *)
  let flip c d e t'' p n n' =
    let e' = e.next in
    let c' = c.next in
    let c'' = c'.next in
    e.next <- c;
    c.next <- c'';
    c''.next <- e;
    c''.inst <- n; c.inst <- n; e.inst <- n;
    c.vert <- Point p;
    d.next <- e';
    e'.next <- c'; 
    c'.next <- d;
    c'.inst <- n'; e'.inst <- n'; d.inst <- n';
    d.vert <- Point t''

  let triangulate points =
    let ccw p q r = S.ccw points.(p) points.(q) points.(r) in
    let in_circle p q r s = 
      S.in_circle points.(p) points.(q) points.(r) points.(s)
    in
    let n = Array.length points in
    if n < 2 then invalid_arg "triangulate";
    let arcs = Array.init (6 * n - 6) (make_arc n) in
    let mate i = 6 * n - 7 - i in

  (*i DEBUG
  let rec dump d l = 
    eprintf "%s" (String.make (2*d) ' ');
    match !l with
      | Terminal a ->
	  eprintf "T %d\n" (mate a.mate)
      | Branch (u, v, l, r) ->
	  eprintf "N %d %d\n" u v;
	  dump (d+1) l;
	  dump (d+1) r
  in
  i*)

    (* initialization: 
       create a trivial triangulation for the first 2 vertices *)
    let u = 0 in
    let v = 1 in
    let a1 = arcs.(0) in
    let a2 = arcs.(1) in
    let a3 = arcs.(2) in
    let b1 = arcs.(mate 0) in
    let b2 = arcs.(mate 1) in
    let b3 = arcs.(mate 2) in
    let l1 = ref (Terminal a2) in
    let l2 = ref (Terminal b3) in
    a1.vert <- Point v;  a1.next <- a2; a1.inst <- l1;
    a2.vert <- Infinity; a2.next <- a3; a2.inst <- l1;
    a3.vert <- Point u;  a3.next <- a1; a3.inst <- l1;
    b1.vert <- Point u;  b1.next <- b3; b1.inst <- l2;
    b2.vert <- Point v;  b2.next <- b1; b2.inst <- l2;
    b3.vert <- Infinity; b3.next <- b2; b3.inst <- l2;
    let l0 = ref (Branch (u, v, l1, l2)) in
    let j = ref 2 in (* last used arc *)

    (* then for each new vertex [p] *)
    for p = 2 to n - 1 do
      (* Step T1 *)
      let rec step_T1 l p = match !l with
	| Terminal al -> 
	    l, al
	| Branch (pl, ql, al, bl) -> 
	    step_T1 (if ccw pl ql p then al else bl) p
      in
      let l, al = step_T1 l0 p in

      (* Step T2 *)
      let a = al in
      let b = a.next in
      let c = b.next in
      let q = a.vert in
      let r = b.vert in
      let s = c.vert in
      j := !j + 3;
      let aj = arcs.(!j) in
      let aj_1 = arcs.(!j - 1) in
      let aj_2 = arcs.(!j - 2) in
      let bj = arcs.(aj.mate) in
      let bj_1 = arcs.(aj_1.mate) in
      let bj_2 = arcs.(aj_2.mate) in
      let l' = ref (Terminal a) in
      let l'' = ref (Terminal aj) in
      let l''' = ref (Terminal c) in
      aj.vert   <- q;         aj.next <- b;      aj.inst <- l'';
      aj_1.vert <- r;       aj_1.next <- c;    aj_1.inst <- l''';
      aj_2.vert <- s;       aj_2.next <- a;    aj_2.inst <- l';
      bj.vert   <- Point p;   bj.next <- aj_2;   bj.inst <- l';
      bj_1.vert <- Point p; bj_1.next <- aj;   bj_1.inst <- l'';
      bj_2.vert <- Point p; bj_2.next <- aj_1; bj_2.inst <- l''';
      a.next <- bj;   a.inst <- l'; 
      b.next <- bj_1; b.inst <- l'';
      c.next <- bj_2; c.inst <- l''';
      let r = finite r in
      let s = finite s in

      (* steps T3 or T4 depending on [q] *)
      let r = match q with
	| Point q -> (* Step T3 *)
	    let n = ref (Branch (q, p, l', l'')) in
	    let n' = ref (Branch (s, p, l''', l')) in
	    l := Branch (r, p, n, n');
	    r
	| Infinity -> (* Step T4 *)
	    let n = ref (Branch (s, p, l''', l')) in
	    l := Branch (r, p, l'', n);
	    let rec loop m a d s t =
	      if t <> r && ccw p s t then begin
		let n = ref (Terminal d) in
		match !m with
		  | Branch (mu, mv, ml, is_l') -> 
		      assert (is_l' == l');
		      m := Branch (mu, mv, ml, d.inst);
		      d.inst := Branch (t, p, n, l');
		      let m = d.inst in
		      flip a arcs.(a.mate) d t p n l';
		      let a = arcs.(a.mate).next in
		      let d = arcs.(a.mate).next in
		      let s = t in
		      let t = finite d.vert in
		      l' := Terminal a;
		      loop m a d s t
		  | Terminal _ -> 
		      assert false
	      end else begin
		(* at exit of while loop *)
		let n = ref (Terminal d.next) in
		d.inst := Branch (s, p, n, l');
		d.inst <- n; d.next.inst <- n; d.next.next.inst <- n;
		s
	      end
	    in
	    let d = arcs.(a.mate).next in
	    loop n a d s (finite d.vert)
      in

      (* Step T5 *)
      let rec loop c =
	let d = arcs.(c.mate) in
	let e = d.next in
	let t = finite d.vert in
	let t' = finite c.vert in
	let t'' = e.vert in
	if t'' <> Infinity && in_circle (finite t'') t' t p then begin
	  let t'' = finite t'' in
	  let n = ref (Terminal e) in
	  let n' = ref (Terminal d) in
	  c.inst := Branch (t'', p, n, n');
	  d.inst := Branch (t'', p, n, n');
	  flip c d e t'' p n n';
	  loop e
	end else if t' <> r then
	  loop arcs.(c.next.mate).next
	else
	  () (* break *)
      in
      loop c

    done;
    { points = points; arcs = arcs; last_used_arc = !j }

  let iter f t =
    let points = t.points in
    let n = Array.length t.arcs in
    for i = 0 to t.last_used_arc do
      match t.arcs.(i).vert, t.arcs.(n - 1 - i).vert with
	| Point u, Point v -> f points.(u) points.(v)
	| _ -> ()
    done

  let iter_triangles f t =
    let n = Array.length t.arcs in
    let seen_arc = Array.create n false in
    let mate i = n - 1 - i in
    let index a = mate a.mate in
    for i = 0 to n-1 do
      if not seen_arc.(i) then begin
	let a1 = t.arcs.(i) in
	let a2 = a1.next in
	let a3 = a2.next in
	seen_arc.(i) <- true;
	seen_arc.(index a2) <- true;
	seen_arc.(index a3) <- true;
	match a1.vert, a2.vert, a3.vert with
	  | Point i1, Point i2, Point i3 -> 
	      f t.points.(i1) t.points.(i2) t.points.(i3)
	  | _ ->
	      ()
      end
    done

  let fold f t a =
    let points = t.points in
    let n = Array.length t.arcs in
    let rec loop i a =
      if i <= t.last_used_arc then
	match t.arcs.(i).vert, t.arcs.(n - 1 - i).vert with
	  | Point u, Point v -> loop (succ i) (f points.(u) points.(v) a)
	  | _ -> loop (succ i) a
      else
	a
    in
    loop 0 a

end

(** Points with floating point coordinates *)

module FloatPoints = struct

  type point = float * float

  let ( + ) = ( +. )
  let ( - ) = ( -. )
  let ( * ) = ( *. )

  let det = function
    | [| [| a00; a01 |];
	 [| a10; a11 |] |] -> 
	a00 * a11 - a01 * a10
    | [| [| a00; a01; a02 |];
	 [| a10; a11; a12 |];
	 [| a20; a21; a22 |] |] -> 
	a00*a11*a22 - a00*a12*a21 - a10*a01*a22 + 
	a10*a02*a21 + a20*a01*a12 - a20*a02*a11
    | [| [| a00; a01; a02; a03 |];
	 [| a10; a11; a12; a13 |];
	 [| a20; a21; a22; a23 |];
	 [| a30; a31; a32; a33 |] |] -> 
	a00*a11*a22*a33 - a00*a11*a23*a32 - a00*a21*a12*a33 + 
	a00*a21*a13*a32 + a00*a31*a12*a23 - a00*a31*a13*a22 - 
	a10*a01*a22*a33 + a10*a01*a23*a32 + a10*a21*a02*a33 - 
	a10*a21*a03*a32 - a10*a31*a02*a23 + a10*a31*a03*a22 + 
	a20*a01*a12*a33 - a20*a01*a13*a32 - a20*a11*a02*a33 + 
	a20*a11*a03*a32 + a20*a31*a02*a13 - a20*a31*a03*a12 - 
	a30*a01*a12*a23 + a30*a01*a13*a22 + a30*a11*a02*a23 - 
	a30*a11*a03*a22 - a30*a21*a02*a13 + a30*a21*a03*a12
    | _ -> assert false

  let ccw (xu,yu) (xv,yv) (xw,yw) = 
    det [| [| xu; yu; 1.0 |];
	   [| xv; yv; 1.0 |];
	   [| xw; yw; 1.0 |] |] > 0.0

  (*i DEBUG
  let ccw (xu,yu) (xv,yv) (xw,yw) = 
    eprintf "ccw((%.0f,%.0f),(%.0f,%.0f),(%.0f,%.0f)) -> " 
      xu yu xv yv xw yw;
    let r = ccw (xu,yu) (xv,yv) (xw,yw) in
    eprintf "%b\n" r; flush stderr;
    r
  i*)

  let in_circle (xt,yt) (xu,yu) (xv,yv) (xw,yw) = 
    det [| [| xt; yt; (xt * xt + yt * yt); 1.0 |];
	   [| xu; yu; (xu * xu + yu * yu); 1.0 |];
	   [| xv; yv; (xv * xv + yv * yv); 1.0 |];
	   [| xw; yw; (xw * xw + yw * yw); 1.0 |]; |] > 0.0

  (*i DEBUG
  let in_circle (xt,yt) (xu,yu) (xv,yv) (xw,yw) = 
    eprintf "in_circle((%.0f,%.0f),(%.0f,%.0f),(%.0f,%.0f),(%.0f,%.0f)) -> " 
      xt yt xu yu xv yv xw yw;
    let r = in_circle (xt,yt) (xu,yu) (xv,yv) (xw,yw) in
    eprintf "%b\n" r; flush stderr;
    r
  i*)

end

module Float = Make(FloatPoints)

(** Points with integer coordinates.
    We approximate using module [FloatPoints] but this could be made exact
    following Knuth's code in Axioms and Hulls *)

module IntPoints = struct

  type point = int * int

  let ccw (xu,yu) (xv,yv) (xw,yw) = 
    FloatPoints.ccw 
      (float xu, float yu) (float xv, float yv) (float xw, float yw)

  let in_circle (xt,yt) (xu,yu) (xv,yv) (xw,yw) = 
    FloatPoints.in_circle
      (float xt, float yt)
      (float xu, float yu) (float xv, float yv) (float xw, float yw)

end

module Int = Make(IntPoints)

end
module Builder: sig
#0 "graph/builder.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: builder.mli,v 1.13 2004-02-20 14:37:40 signoles Exp $ *)

(** Graph builders in order to persistent/imperative graphs sharing a same
    signature. *)

open Sig

(** {2 Common interface for graph builders}.

   Note: the following functions always return graphs but this is meaningless
   for imperative implementations (the graph is modified in-place).  
   This is just to provide a common interface. *)

module type S = sig
  module G : Sig.G
  val empty : unit -> G.t
  val copy : G.t -> G.t
  val add_vertex : G.t -> G.V.t -> G.t
  val add_edge : G.t -> G.V.t -> G.V.t -> G.t
  val add_edge_e : G.t -> G.E.t -> G.t
end

module type INT = S with type G.V.label = int

(** {1 Builders for the various graph implementations} *)

module P(G : Sig.P) : S with module G = G
  (** Persistent Graphs Builders. *)

module I(G : Sig.I) : S with module G = G
  (** Imperative Graphs Builders. *)
end = struct
#0 "graph/builder.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: builder.ml,v 1.12 2004-02-20 14:37:40 signoles Exp $ *)

open Sig

module type S = sig
  module G : Sig.G
  val empty : unit -> G.t
  val copy : G.t -> G.t
  val add_vertex : G.t -> G.V.t -> G.t
  val add_edge : G.t -> G.V.t -> G.V.t -> G.t
  val add_edge_e : G.t -> G.E.t -> G.t
end

module type INT = S with type G.V.label = int

module P(G : Sig.P) = struct
  module G = G
  let empty () = G.empty
  let copy g = g
  let add_vertex = G.add_vertex
  let add_edge = G.add_edge
  let add_edge_e = G.add_edge_e
end

module I(G : Sig.I) = struct
  module G = G
  let empty () = G.create ~size:997 ()
  let copy = G.copy
  let add_vertex g v = G.add_vertex g v; g
  let add_edge g v1 v2 = G.add_edge g v1 v2; g
  let add_edge_e g e = G.add_edge_e g e; g
end
end
module Classic: sig
#0 "graph/classic.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: classic.mli,v 1.12 2005-02-25 13:54:33 signoles Exp $ *)

(** Some classic graphs *)

module type S = sig

  type graph 

  val divisors : int -> graph
    (** [divisors n] builds the graph of divisors. 
      Vertices are integers from [2] to [n]. [i] is connected to [j] if
      and only if [i] divides [j]. 
      @raise Invalid_argument is [n < 2]. *)

  val de_bruijn : int -> graph
    (** [de_bruijn n] builds the de Bruijn graph of order [n].
      Vertices are bit sequences of length [n] (encoded as their
      interpretation as binary integers). The sequence [xw] is connected
      to the sequence [wy] for any bits [x] and [y] and any bit sequence 
      [w] of length [n-1]. 
      @raise Invalid_argument is [n < 1] or [n > Sys.word_size-1]. *)

  val vertex_only : int -> graph
    (** [vertex_only n] builds a graph with [n] vertices and no edge. *)

  val full : ?self:bool -> int -> graph
    (** [full n] builds a graph with [n] vertices and all possible edges.
      The optional argument [self] indicates if loop edges should be added
      (default value is [true]). *)

end

module P (G : Sig.P with type V.label = int) : S with type graph = G.t
  (** Classic Persistent Graphs *)

module I (G : Sig.I with type V.label = int) : S with type graph = G.t
  (** Classic Imperative Graphs *)
end = struct
#0 "graph/classic.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: classic.ml,v 1.9 2004-02-02 08:11:14 filliatr Exp $ *)

module type S = sig
  type graph 
  val divisors : int -> graph
  val de_bruijn : int -> graph
  val vertex_only : int -> graph
  val full : ?self:bool -> int -> graph
end

module Generic(B : Builder.INT) = struct

  type graph = B.G.t

  let divisors n =
    if n < 2 then invalid_arg "divisors";
    let v = Array.init (n + 1) (fun i -> B.G.V.create i) in
    let rec loop g i =
      let sqrt_i = truncate (sqrt (float i)) in
      let rec loop_i g d =
	if d > sqrt_i then 
	  g 
	else if i mod d == 0 then
	  loop_i (B.add_edge (B.add_edge g v.(i / d) v.(i)) v.(d) v.(i)) (d+1)
	else
	  loop_i g (succ d)
      in
      if i > n then g else loop (loop_i (B.add_vertex g v.(i)) 2) (i+1)
    in
    loop (B.empty ()) 2
	
  let fold_for i0 i1 f =
    let rec loop i v = if i > i1 then v else loop (i + 1) (f v i) in
    loop i0

  let de_bruijn n =
    if n < 1 || n > Sys.word_size - 1 then invalid_arg "de_bruijn";
    let v = Array.init (1 lsl n) (fun i -> B.G.V.create i) in
    let all_1 = 1 lsl n - 1 in (* 11...1 *)
    let g = fold_for 0 all_1 (fun g i -> B.add_vertex g v.(i)) (B.empty ()) in
    let rec loop g i =
      if i > all_1 then
	g
      else 
	let si = (i lsl 1) land all_1 in
	let g = B.add_edge g v.(i) v.(si) in
	let g = B.add_edge g v.(i) v.(si lor 1) in
	loop g (i + 1)
    in
    loop g 0

  let vertex_only n =
    fold_for 1 n (fun g i -> B.add_vertex g (B.G.V.create i)) (B.empty ())

  let full ?(self=true) n =
    let v = Array.init (n + 1) (fun i -> B.G.V.create i) in
    fold_for 1 n
      (fun g i ->
	 fold_for 1 n
	   (fun g j -> if self || i <> j then B.add_edge g v.(i) v.(j) else g)
	   g)
      (fold_for 1 n (fun g i -> B.add_vertex g v.(i)) (B.empty ()))

end

module P (G : Sig.P with type V.label = int) = Generic(Builder.P(G))

module I (G : Sig.I with type V.label = int) = Generic(Builder.I(G))
end
module Rand: sig
#0 "graph/rand.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: rand.mli,v 1.12 2005-03-31 13:32:51 filliatr Exp $ *)

(** Random graph generation. *)

(** {2 Random graphs} *)

module type S = sig

  type graph 
  type vertex
  type edge_label

  val graph : ?loops:bool -> v:int -> e:int -> unit -> graph
    (** [graph v e] generates a random graph with exactly [v] vertices 
      and [e] edges. Vertices are labeled with [0] ... [v-1].
      The boolean [loops] indicates whether loops are allowed; 
      default value is no loop ([false]). 
      @raise Invalid_argument if [e] exceeds the maximal number of edges. *)

  val labeled : 
    (vertex -> vertex -> edge_label) -> 
    ?loops:bool -> v:int -> e:int -> unit -> graph
    (** [labeled f] is similar to [graph] except that edges are labeled
      using function [f].
      @raise Invalid_argument if there are too many edges. *)

  (** The two functions above actually make a choice between two
     different implementations according to the ratio e/(v*v).
     When this ratio is small, [random_few_edges] is selected; 
     otherwise [random_many_edges] is selected. *)

  val random_few_edges : loops:bool -> v:int -> e:int -> graph
  val random_many_edges : loops:bool -> v:int -> e:int -> graph

end

module Make(B: Builder.INT) :
  S with type graph = B.G.t 
    and type vertex = B.G.V.t 
    and type edge_label = B.G.E.label
      (** Random graphs *)

module P (G : Sig.P with type V.label = int) : 
  S with type graph = G.t 
    and type vertex = G.V.t 
    and type edge_label = G.E.label
      (** Random persistent graphs *)

module I (G : Sig.I with type V.label = int) : 
  S with type graph = G.t
    and type vertex = G.V.t     
    and type edge_label = G.E.label
      (** Random imperative graphs *)

(** {2 Random planar graphs} *)

module Planar : sig

  module type S = sig

    type graph 

    val graph : 
      ?loops:bool -> xrange:int*int -> yrange:int*int ->
	prob:float -> int -> graph
      (** [graph xrange yrange prob v] 
        generates a random planar graph with exactly [v] vertices.
        Vertices are labeled with integer coordinates, randomly distributed
        according to [xrange] and [yrange].
        Edges are built as follows: the full Delaunay triangulation is
        constructed and then each edge is discarded with probabiblity [prob]
        (which should lie in [0..1]). In particular [prob = 0.0] gives the 
        full triangulation.
        Edges are labeled with the (rounded) Euclidean distance between
        the two vertices.
        The boolean [loops] indicates whether loops are allowed; 
        default value is no loop ([false]). *)

  end

  module Make
    (B : Builder.S with type G.V.label = int * int and type G.E.label = int) :
    S with type graph = B.G.t 
	(** Random planar graphs *)

  module P (G : Sig.P with type V.label = int * int and type E.label = int) : 
    S with type graph = G.t 
	(** Random persistent planar graphs *)

  module I (G : Sig.I with type V.label = int * int and type E.label = int) : 
    S with type graph = G.t
	(** Random imperative planar graphs *)
			      
end
end = struct
#0 "graph/rand.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: rand.ml,v 1.18 2005-03-31 13:32:51 filliatr Exp $ *)

module type S = sig
  type graph 
  type vertex
  type edge_label
  val graph : ?loops:bool -> v:int -> e:int -> unit -> graph
  val labeled : 
    (vertex -> vertex -> edge_label) -> 
    ?loops:bool -> v:int -> e:int -> unit -> graph
  (* DEBUG *)
  val random_few_edges : loops:bool -> v:int -> e:int -> graph
  val random_many_edges : loops:bool -> v:int -> e:int -> graph
end

module Make(B : Builder.INT) = struct

  open B
  type graph = G.t
  type vertex = G.V.t
  type edge_label = G.E.label

  open Int64

  let max_edges ~loops ~v ~e =
    if v <= 0 || e < 0 then invalid_arg "random";
    let v64 = of_int v in
    let max_e = mul v64 (pred v64) in
    let max_e = if G.is_directed then max_e else div max_e (of_int 2) in
    let max_e = if loops then add max_e v64 else max_e in
    if of_int e > max_e then invalid_arg "random: too many edges";
    max_e

  let fold_for i0 i1 f =
    let rec loop i v = if i > i1 then v else loop (i + 1) (f v i) in
    loop i0

  (* naive implementation: we randomly chose edges up to [e] different edges *)
  let random_few_edges add_edge ~loops ~v ~e =
    let _ = max_edges ~loops ~v ~e in
    let a = Array.init v G.V.create in
    let g = Array.fold_left add_vertex (empty ()) a in
    let rec random_edge g =
      let i = Random.int v in
      let j = Random.int v in
      if (i = j && not loops) || G.mem_edge g a.(i) a.(j) then 
	random_edge g
      else
	add_edge g a.(i) a.(j)
    in
    fold_for 1 e (fun g _ -> random_edge g) g

  (* other implementation in O(v * v); faster when [e] is large *)
  let random_many_edges add_edge ~loops ~v ~e =
    let v64 = of_int v in
    let max_e = max_edges ~loops ~v ~e in
    let a = Array.init v G.V.create in
    let g = Array.fold_left add_vertex (empty ()) a in
    let rec add_edges i j max nb g =
      assert 
	(max >= 0L &&
         max_e = 
	   add max (add (mul (of_int i) v64) 
           (of_int 
  	    (j - 
	    (match G.is_directed, loops with
	       | true, true -> 0
	       | true, false -> if j > i then i + 1 else i
	       | false, true -> i * (i - 1) / 2 + if j > i then i else j
	       | false, false -> i*(i+1)/2 + if j > i then i+1 else j)))));
      if nb = 0 then
	g
      else
	let add_edges = 
	  let i, j = if j = v - 1 then i + 1, 0 else i, j + 1 in
	  add_edges i j 
	in
	if (i = j && not loops) || (not G.is_directed && i > j) then 
	  add_edges max nb g
	else
	  let add_edges = add_edges (pred max) in
	  if Random.int64 max < of_int nb then
	    add_edges (nb - 1) (add_edge g a.(i) a.(j))
	  else
	    add_edges nb g
    in
    add_edges 0 0 max_e e g

  let random ~loops ~v ~e = 
    let r = float e /. (float v *. float v) in
    (if r < 0.4 then random_few_edges else random_many_edges) ~loops ~v ~e

  let graph ?(loops=false) ~v ~e () = random B.add_edge ~loops ~v ~e

  let labeled f ?(loops=false) ~v ~e () = 
    random 
      (fun g v1 v2 -> B.add_edge_e g (G.E.create v1 (f v1 v2) v2)) 
      ~loops ~v ~e

  (* DEBUG *)
  let random_few_edges = random_few_edges B.add_edge
  let random_many_edges = random_many_edges B.add_edge

end

module P (G : Sig.P with type V.label = int) = Make(Builder.P(G))

module I (G : Sig.I with type V.label = int) = Make(Builder.I(G))


(** Random planar graphs *)

module Planar = struct

  module type S = sig
    type graph 
    val graph : 
      ?loops:bool -> xrange:int*int -> yrange:int*int ->
	prob:float -> int -> graph
  end

  module Make
    (B : Builder.S with type G.V.label = int * int and type G.E.label = int) =
  struct

    type graph = B.G.t
    open B.G

    module Point = struct
      type point = V.t
      let ccw v1 v2 v3 = 
	Delaunay.IntPoints.ccw (V.label v1) (V.label v2) (V.label v3)
      let in_circle v1 v2 v3 v4 =
	Delaunay.IntPoints.in_circle 
	  (V.label v1) (V.label v2) (V.label v3) (V.label v4)
      let distance v1 v2 =
	let x1,y1 = V.label v1 in
	let x2,y2 = V.label v2 in
	let sqr x = let x = float x in x *. x in
	truncate (sqrt (sqr (x1 - x2) +. sqr (y1 - y2)))
    end

    module Triangulation = Delaunay.Make(Point)

    let graph ?(loops=false) ~xrange:(xmin,xmax) ~yrange:(ymin,ymax) ~prob v =
      if not (0.0 <= prob && prob <= 1.0) then invalid_arg "Planar.graph";
      if v < 2 then invalid_arg "Planar.graph";
      (* [v] random points and their Delaunay triangulation *)
      let random_point () =
	xmin + Random.int (1 + xmax - xmin),
	ymin + Random.int (1 + ymax - ymin)
      in
      let vertices = Array.init v (fun _ -> V.create (random_point ())) in
      let t = Triangulation.triangulate vertices in
      (* a graph with [v] vertices and random loops if any *)
      let g = Array.fold_left B.add_vertex (B.empty ()) vertices in
      let g = 
	if loops then 
	  Array.fold_left 
	    (fun g v -> 
	       if Random.float 1.0 < prob then 
		 g
	       else
		 let e = E.create v 0 v in B.add_edge_e g e)
	    g vertices
	else 
	  g
      in
      (* we keep some edges from the triangulation according to [prob] *)
      let add_edge v1 v2 g =
	if Random.float 1.0 < prob then 
	  g
	else
	  let e = E.create v1 (Point.distance v1 v2) v2 in B.add_edge_e g e
      in
      Triangulation.fold
	(fun v1 v2 g -> 
	   let g = add_edge v1 v2 g in
	   if is_directed then add_edge v2 v1 g else g)
	t g

  end

  module P (G : Sig.P with type V.label = int * int and type E.label = int) = 
    Make(Builder.P(G))

  module I (G : Sig.I with type V.label = int * int and type E.label = int) = 
    Make(Builder.I(G))

end
end
module Oper: sig
#0 "graph/oper.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: oper.mli,v 1.15 2005-01-18 16:40:14 signoles Exp $ *)

(** Basic operations over graphs *)

(** {2 Basic operations over graphs} *)

module type S = sig

  type g

  val transitive_closure : ?reflexive:bool -> g -> g
    (** [transitive_closure ?reflexive g] returns the transitive closure 
      of [g] (as a new graph). Loops (i.e. edges from a vertex to itself) 
      are added only if [reflexive] is [true] (default is [false]). *)

  val add_transitive_closure : ?reflexive:bool -> g -> g
    (** [add_transitive_closure ?reflexive g] replaces [g] by its
      transitive closure. Meaningless for persistent implementations
      (then acts as [transitive_closure]). *)

  val mirror : g -> g
    (** [mirror g] returns a new graph which is the mirror image of [g]:
	each edge from [u] to [v] has been replaced by an edge from [v] to [u].
	For undirected graphs, it simply returns [g]. 
	Note: Vertices are shared between [g] and [mirror g]; you may need to
	make a copy of [g] before using [mirror] *)

  val complement : g -> g
    (** [complement g] returns a new graph which is the complement of [g]:
      each edge present in [g] is not present in the resulting graph and
      vice-versa. Edges of the returned graph are unlabeled. *)

  val intersect : g -> g -> g
    (** [intersect g1 g2] returns a new graph which is the intersection of [g1]
      and [g2]: each vertex and edge present in [g1] *and* [g2] is present 
      in the resulting graph. *)

  val union : g -> g -> g
    (** [union g1 g2] returns a new graph which is the union of [g1] and [g2]:
      each vertex and edge present in [g1] *or* [g2] is present in the 
      resulting graph. *)
      
end

module Make(B : Builder.S) : S with type g = B.G.t
  (** Basic operations over graphs *)

module P(G : Sig.P) : S with type g = G.t
  (** Basic operations over persistent graphs *)

module I(G : Sig.I) : S with type g = G.t
  (** Basic operations over imperative graphs *)

(** {2 Choose} *)

(** Choose an element in a graph *)
module Choose(G : sig 
		type t 
		type vertex 
		type edge 
		val iter_vertex : (vertex -> unit) -> t -> unit
		val iter_edges_e : (edge -> unit) -> t -> unit
	      end) :
sig

  val choose_vertex : G.t -> G.vertex
    (** [choose_vertex g] returns a vertex from the graph.
      @raise Invalid_argument if the graph is empty. *)

  val choose_edge : G.t -> G.edge
    (** [choose_edge g] returns an edge from the graph.
      @raise Invalid_argument if the graph has no edge. *)

end

(** {2 Neighbourhood} *)

(** Neighbourhood of vertex / vertices *)
module Neighbourhood(G : sig 
		      type t 
		      module V : Sig.COMPARABLE
		      val fold_succ: (V.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
		      val succ: t -> V.t -> V.t list
		    end) :
sig

  module Vertex_Set : Set.S with type elt = G.V.t

  (** The neighbourhood of a vertex [v] is 
    \{ v' | (succ g v) and (v <> v') \} *)

  val list_from_vertex : G.t -> G.V.t -> G.V.t list
    (** Neighbourhood of a vertex as a list. *)

  val set_from_vertex : G.t -> G.V.t -> Vertex_Set.t
    (** Neighbourhood of a vertex as a set. 
      Less efficient that [list_from_vertex]. *)

  (** The neighbourhood of a set [S] of vertices is [U \ S] where
    [U] is the union of neighbourhoods of each vertex of [S]. *)

  val list_from_vertices : G.t -> G.V.t list -> G.V.t list
    (** Neighbourhood of a list of vertices as a list. *)

  val set_from_vertices : G.t -> G.V.t list -> Vertex_Set.t
    (** Neighbourhood of a list of vertices as a set. 
      More efficient that [list_from_vertices]. *)

end
end = struct
#0 "graph/oper.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: oper.ml,v 1.13 2005-06-30 10:48:55 filliatr Exp $ *)

(* Basic operations over graphs *)

module type S = sig
  type g
  val transitive_closure : ?reflexive:bool -> g -> g
  val add_transitive_closure : ?reflexive:bool -> g -> g
  val mirror : g -> g
  val complement : g -> g
  val intersect : g -> g -> g
  val union : g -> g -> g
end

module Make(B : Builder.S) = struct

  open B

  (* Roy-Warshall's algorithm *)

  type g = G.t

  let add_transitive_closure ?(reflexive=false) g0 =
    let phi v g =
      let g = if reflexive then B.add_edge g v v else g in
      G.fold_succ
	(fun sv g -> G.fold_pred (fun pv g -> B.add_edge g pv sv) g v g) 
	g v g
    in
    G.fold_vertex phi g0 g0

  let transitive_closure ?(reflexive=false) g0 = 
    add_transitive_closure ~reflexive (B.copy g0)

  module H = Hashtbl.Make(G.V)

  let mirror g =
    if G.is_directed then begin
      let g' = 
	G.fold_vertex
	  (fun v g' -> B.add_vertex g' v)
	  g (B.empty ())
      in
      G.fold_edges_e
	(fun e g' -> 
	   let v1 = G.E.src e in
	   let v2 = G.E.dst e in
	   B.add_edge_e g' (G.E.create v2 (G.E.label e) v1))
	g g'
    end else
      g

  let complement g =
    G.fold_vertex
      (fun v g' ->
	 G.fold_vertex
	   (fun w g' ->
	      if G.mem_edge g v w then g'
	      else B.add_edge g' v w)
	 g g')
      g (B.empty ())

  let intersect g1 g2 = 
    G.fold_vertex
      (fun v g ->
	 try
	   let succ = G.succ_e g2 v in
	   G.fold_succ_e 
	     (fun e g -> 
		if List.mem e succ 
		then B.add_edge_e g e 
		else g)
	     g1 v (B.add_vertex g v)
	 with Invalid_argument _ -> 
	   (* $v \notin g2$ *)
	   g)
      g1 (B.empty ())

  let union g1 g2 =
    let add g1 g2 = 
      (* add the graph [g1] in [g2] *)
      G.fold_vertex 
	(fun v g -> 
	   G.fold_succ_e (fun e g -> B.add_edge_e g e) g1 v (B.add_vertex g v))
	g1 g2
    in
    add g1 (B.copy g2)

end

module P(G : Sig.P) = Make(Builder.P(G))
module I(G : Sig.I) = Make(Builder.I(G))

module Choose(G : sig
		type t 
		type vertex 
		type edge 
		val iter_vertex : (vertex -> unit) -> t -> unit
		val iter_edges_e : (edge -> unit) -> t -> unit
	      end) =
struct

  exception Found_Vertex of G.vertex
  let choose_vertex g = 
    try
      G.iter_vertex (fun v -> raise (Found_Vertex v)) g;
      invalid_arg "choose_vertex"
    with Found_Vertex v ->
      v

  exception Found_Edge of G.edge
  let choose_edge g =
    try
      G.iter_edges_e (fun v -> raise (Found_Edge v)) g;
      invalid_arg "choose_vertex"
    with Found_Edge v ->
      v

end

module Neighbourhood(G : sig 
		      type t 
		      module V : Sig.COMPARABLE
		      val fold_succ: (V.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
		      val succ: t -> V.t -> V.t list
		    end) =
struct

  module Vertex_Set = Set.Make(G.V)

  let set_from_vertex g v =
    G.fold_succ 
      (fun v' s -> if G.V.equal v v' then s else Vertex_Set.add v' s) 
      g v Vertex_Set.empty 

  let list_from_vertex g v =
    let rec aux = function
      | [] -> []
      | v' :: l ->
	  if G.V.equal v v' then begin
	    assert (not (List.exists (G.V.equal v) l));
	    l
	  end else
	    v' :: aux l
    in
    aux (G.succ g v)

  let set_from_vertices g l =
    let fold_left f = List.fold_left f Vertex_Set.empty l in
    let env_init = fold_left (fun s v -> Vertex_Set.add v s) in
    let add x s = 
      if Vertex_Set.mem x env_init then s else Vertex_Set.add x s 
    in
    fold_left (fun s v -> G.fold_succ add g v s)

  let list_from_vertices g l = Vertex_Set.elements (set_from_vertices g l)

end
end
module Path: sig
#0 "graph/path.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: path.mli,v 1.9 2005-07-18 07:10:35 filliatr Exp $ *)

(** Paths *)

(** Minimal graph signature for Dijkstra's algorithm.
    Sub-signature of {!Sig.G}. *)
module type G = sig
  type t 
  module V : Sig.COMPARABLE 
  module E : sig 
    type t 
    type label 
    val label : t -> label 
    val dst : t -> V.t 
  end 
  val iter_succ_e : (E.t -> unit) -> t -> V.t -> unit
end

(** Signature for edges' weights. *)
module type WEIGHT = sig
  type label
    (** Type for labels of graph edges. *)
  type t
    (** Type of edges' weights. *)
  val weight : label -> t
    (** Get the weight of an edge. *)
  val compare : t -> t -> int
    (** Weights must be ordered. *)
  val add : t -> t -> t
    (** Addition of weights. *)
  val zero : t
    (** Neutral element for {!add}. *)
end

module Dijkstra
  (G: G)
  (W: WEIGHT with type label = G.E.label) : 
sig

  val shortest_path : G.t -> G.V.t -> G.V.t -> G.E.t list * W.t
    (** [shortest_path g v1 v2] computes the shortest path from vertex [v1]
      to vertex [v2] in graph [g]. The path is returned as the list of 
      followed edges, together with the total length of the path. 
      raise [Not_found] if the path from [v1] to [v2] does not exist. 

      Complexity: at most O((V+E)log(V)) *)

end


(** Check for a path. *)
module Check
  (G : sig
     type t
     module V : Sig.COMPARABLE
     val iter_succ : (V.t -> unit) -> t -> V.t -> unit
   end) : 
sig

  type path_checker
    (** the abstract data type of a path checker; this is a mutable data 
	structure *)

  val create : G.t -> path_checker
    (** [create g] builds a new path checker for the graph [g];
        if the graph is mutable, it must not be mutated while this path 
        checker is in use (through the function [check_path] below). *)

  val check_path : path_checker -> G.V.t -> G.V.t -> bool
    (** [check_path pc v1 v2] checks whether there is a path from [v1] to
	[v2] in the graph associated to the path checker [pc].

        Complexity: The path checker contains a cache of all results computed
	so far. This cache is implemented with a hash table so access in this 
	cache is usually O(1). When the result is not in the cache, Dijkstra's
	algorithm is run to check for the path, and all intermediate results
	are cached.

	Note: if checks are to be done for almost all pairs of vertices, it
	may be more efficient to compute the transitive closure of the graph
	(see module [Oper]).
	*)

end
end = struct
#0 "graph/path.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: path.ml,v 1.6 2005-07-18 07:10:35 filliatr Exp $ *)

module type WEIGHT = sig
  type label
  type t
  val weight : label -> t
  val compare : t -> t -> int
  val add : t -> t -> t
  val zero : t
end

module type G = sig
  type t 
  module V : Sig.COMPARABLE 
  module E : sig 
    type t 
    type label 
    val label : t -> label 
    val dst : t -> V.t 
  end 
  val iter_succ_e : (E.t -> unit) -> t -> V.t -> unit
end

module Dijkstra
  (G: G)
  (W: WEIGHT with type label = G.E.label) =
struct

  open G.E

  module H =  Hashtbl.Make(G.V)

  module Elt = struct
    type t = W.t * G.V.t * G.E.t list

    (* weights are compared first, and minimal weights come first in the
       queue *)	       
    let compare (w1,v1,_) (w2,v2,_) =
      let cw = W.compare w2 w1 in
      if cw != 0 then cw else G.V.compare v1 v2
  end

  module PQ = Heap.Imperative(Elt)

  let shortest_path g v1 v2 =
    let visited = H.create 97 in
    let dist = H.create 97 in
    let q = PQ.create 17 in
    let rec loop () = 
      if PQ.is_empty q then raise Not_found;
      let (w,v,p) = PQ.pop_maximum q in
      if G.V.compare v v2 = 0 then 
	List.rev p, w
      else begin
	if not (H.mem visited v) then begin
	  H.add visited v ();
	  G.iter_succ_e
	    (fun e -> 
	       let ev = dst e in
	       if not (H.mem visited ev) then begin
		 let dev = W.add w (W.weight (label e)) in
		 let improvement =
		   try W.compare dev (H.find dist ev) < 0 with Not_found -> true
		 in
		 if improvement then begin
		   H.replace dist ev dev;
		   PQ.add q (dev, ev, e :: p)
		 end
	       end)
	    g v
	end;
	loop ()
      end
    in
    PQ.add q (W.zero, v1, []);
    H.add dist v1 W.zero;
    loop ()

end



module Check 
  (G : 
    sig
      type t
      module V : Sig.COMPARABLE
      val iter_succ : (V.t -> unit) -> t -> V.t -> unit
    end) = 
struct

  module HV = Hashtbl.Make(G.V)
  module HVV = Hashtbl.Make(Util.HTProduct(G.V)(G.V))

  (* the cache contains the path tests already computed *)
  type path_checker = { cache : bool HVV.t; graph : G.t }

  let create g = { cache = HVV.create 97; graph = g }

  let check_path pc v1 v2 =
    try 
      HVV.find pc.cache (v1, v2)
    with Not_found -> 
      (* the path is not in cache; we check it with Dijkstra *)
      let visited = HV.create 97 in
      let q = Queue.create () in
      let rec loop () =
	if Queue.is_empty q then begin
	  HVV.add pc.cache (v1, v2) false;
	  false
	end else begin
	  let v = Queue.pop q in
	  HVV.add pc.cache (v1, v) true;
	  if G.V.compare v v2 = 0 then 
	    true
	  else begin
	    if not (HV.mem visited v) then begin
	      HV.add visited v ();
	      G.iter_succ (fun v' -> Queue.add v' q) pc.graph v
	    end;
	    loop ()
	  end
	end
      in
      Queue.add v1 q;
      loop ()

end
end
module Traverse: sig
#0 "graph/traverse.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(** Graph traversal. *)

(** {2 Dfs and Bfs} *)

(** Minimal graph signature for {!Dfs} and {!Bfs}.
    Sub-signature of {!Sig.G}. *)
module type G = sig
  val is_directed : bool
  type t
  module V : Sig.COMPARABLE
  val iter_vertex : (V.t -> unit) -> t -> unit
  val fold_vertex : (V.t -> 'a -> 'a) -> t  -> 'a -> 'a
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
  val fold_succ : (V.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
end

(** Depth-first search *)
module Dfs(G : G) : sig

  (** {2 Classical big-step iterators} *)

  val iter : ?pre:(G.V.t -> unit) ->
             ?post:(G.V.t -> unit) -> G.t -> unit
      (** [iter pre post g] visits all nodes of [g] in depth-first search,
	 applying [pre] to each visited node before its successors,
	 and [post] after them. Each node is visited exactly once.
         Not tail-recursive. *)

  val prefix : (G.V.t -> unit) -> G.t -> unit
    (** applies only a prefix function; note that this function is more
      efficient than [iter] and is tail-recursive. *)

  val postfix : (G.V.t -> unit) -> G.t -> unit
    (** applies only a postfix function. Not tail-recursive. *)

  (** Same thing, but for a single connected component
      (only [prefix_component] is tail-recursive) *)

  val iter_component : ?pre:(G.V.t -> unit) ->
             ?post:(G.V.t -> unit) -> G.t -> G.V.t -> unit
  val prefix_component : (G.V.t -> unit) -> G.t -> G.V.t -> unit
  val postfix_component : (G.V.t -> unit) -> G.t -> G.V.t -> unit

  (** {2 Step-by-step iterator}

    This is a variant of the iterators above where you can move on
    step by step. The abstract type [iterator] represents the current
    state of the iteration. The [step] function returns the next state.
    In each state, function [get] returns the currently visited vertex.
    On the final state both [get] and [step] raises exception [Exit].

    Note: the iterator type is persistent (i.e. is not modified by the
    [step] function) and thus can be used in backtracking algorithms. *)

  type iterator
  val start : G.t -> iterator
  val step : iterator -> iterator
  val get : iterator -> G.V.t

  (** {2 Cycle detection} *)

  val has_cycle : G.t -> bool
    (** [has_cycle g] checks for a cycle in [g]. Linear in time and space. *)

end

(** Breadth-first search *)
module Bfs(G : G) : sig

  (** {2 Classical big-step iterators} *)

  val iter : (G.V.t -> unit) -> G.t -> unit
  val iter_component : (G.V.t -> unit) -> G.t -> G.V.t -> unit

  (** {2 Step-by-step iterator}
    See module [Dfs] *)

  type iterator
  val start : G.t -> iterator
  val step : iterator -> iterator
  val get : iterator -> G.V.t

end

(** {2 Traversal with marking}

    Provide a more efficient version of depth-first algorithm when graph
    vertices are marked. *)

(** Minimal graph signature for graph traversal with marking.
    Sub-signature of {!Sig.IM}. *)
module type GM = sig
  type t
  module V : sig type t end
  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
  module Mark : sig
    val clear : t -> unit
    val get : V.t -> int
    val set : V.t -> int -> unit
  end
end

(** Graph traversal with marking.
    Only applies to imperative graphs with marks. *)
module Mark(G : GM) : sig

  val dfs : G.t -> unit
    (** [dfs g] traverses [g] in depth-first search, marking all nodes. *)

  val has_cycle : G.t -> bool
    (** [has_cycle g] checks for a cycle in [g]. Modifies the marks.
      Linear time, constant space. *)

end

end = struct
#0 "graph/traverse.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* Graph traversal *)

module type G = sig
  val is_directed : bool
  type t
  module V : Sig.COMPARABLE
  val iter_vertex : (V.t -> unit) -> t -> unit
  val fold_vertex : (V.t -> 'a -> 'a) -> t  -> 'a -> 'a
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
  val fold_succ : (V.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
end

(* depth-first search *)
module Dfs(G : G) = struct
  module H = Hashtbl.Make(G.V)

  let iter ?(pre=fun _ -> ()) ?(post=fun _ -> ()) g =
    let h = H.create 65537 in
    let rec visit v =
      if not (H.mem h v) then begin
	H.add h v ();
	pre v;
	G.iter_succ visit g v;
	post v
      end
    in
    G.iter_vertex visit g

  let postfix post g = iter ~post g

  let iter_component ?(pre=fun _ -> ()) ?(post=fun _ -> ()) g v =
    let h = H.create 65537 in
    let rec visit v =
      H.add h v ();
      pre v;
      G.iter_succ (fun w -> if not (H.mem h w) then visit w) g v;
      post v
    in
    visit v

  let prefix_component pre g = iter_component ~pre g
  let postfix_component post g = iter_component ~post g

  (* invariant: not in [h] means not visited at all; [h v = true] means
     already visited in the current component; [h v = false] means
     already visited in another tree *)
  let has_cycle g =
    let h = H.create 65537 in
    let rec visit v =
      H.add h v true;
      G.iter_succ
	(fun w -> try if H.find h w then raise Exit with Not_found -> visit w)
	g v;
      H.replace h v false
    in
    try G.iter_vertex (fun v -> if not (H.mem h v) then visit v) g; false
    with Exit -> true

  let has_cycle_undirected g =
    let h = H.create 65537 in
    let father = H.create 65537 in
    let is_father u v = (* u is the father of v in the DFS descent *)
      try G.V.equal (H.find father v) u with Not_found -> false
    in
    let rec visit v =
      H.add h v true;
      G.iter_succ
	(fun w ->
	   try if H.find h w && not (is_father w v) then raise Exit
	   with Not_found -> H.add father w v; visit w)
	g v;
      H.remove father v;
      H.replace h v false
    in
    try G.iter_vertex (fun v -> if not (H.mem h v) then visit v) g; false
    with Exit -> true

  let has_cycle g =
    if G.is_directed then has_cycle g else has_cycle_undirected g

  module Tail = struct

    let has_cycle g =
      let h = H.create 65537 in
      let stack = Stack.create () in
      let loop () =
	while not (Stack.is_empty stack) do
	  let v = Stack.top stack in
	  if H.mem h v then begin
	    (* we are now done with node v *)
	    (* assert (H.find h v = true); *)
	    H.replace h v false;
	    ignore (Stack.pop stack)
	  end else begin
	    (* we start DFS from node v *)
	    H.add h v true;
	    G.iter_succ
	      (fun w ->
		 try if H.find h w then raise Exit
		 with Not_found -> Stack.push w stack)
	      g v;
	  end
	done
      in
      try
	G.iter_vertex
	  (fun v ->
	     if not (H.mem h v) then begin Stack.push v stack; loop () end)
	  g;
	false
      with Exit ->
	true

    let has_cycle_undirected g =
      let h = H.create 65537 in
      let father = H.create 65537 in
      let is_father u v = (* u is the father of v in the DFS descent *)
	try G.V.equal (H.find father v) u with Not_found -> false
      in
      let stack = Stack.create () in
      let loop () =
	while not (Stack.is_empty stack) do
	  let v = Stack.top stack in
	  if H.mem h v then begin
	    (* we are now done with node v *)
	    (* assert (H.find h v = true); *)
	    H.remove father v;
	    H.replace h v false;
	    ignore (Stack.pop stack)
	  end else begin
	    (* we start DFS from node v *)
	    H.add h v true;
	    G.iter_succ
	      (fun w ->
		 try if H.find h w && not (is_father w v) then raise Exit
		 with Not_found -> H.add father w v; Stack.push w stack)
	      g v;
	  end
	done
      in
      try
	G.iter_vertex
	  (fun v ->
	     if not (H.mem h v) then begin Stack.push v stack; loop () end)
	  g;
	false
      with Exit ->
	true

    let has_cycle g =
      if G.is_directed then has_cycle g else has_cycle_undirected g

    let iter f g =
      let h = H.create 65537 in
      let stack = Stack.create () in
      let loop () =
	while not (Stack.is_empty stack) do
	  let v = Stack.pop stack in
	  if not (H.mem h v) then begin
	    H.add h v ();
	    f v;
	    G.iter_succ
	      (fun w -> if not (H.mem h w) then Stack.push w stack) g v
	  end
	done
      in
      G.iter_vertex
	(fun v ->
	  if not (H.mem h v) then begin Stack.push v stack; loop () end)
	g

    let iter_component f g v0 =
      let h = H.create 65537 in
      let stack = Stack.create () in
      Stack.push v0 stack;
      while not (Stack.is_empty stack) do
	let v = Stack.pop stack in
	if not (H.mem h v) then begin
	  H.add h v ();
	  f v;
	  G.iter_succ (fun w -> if not (H.mem h w) then Stack.push w stack) g v
	end
      done

  end

  let prefix = Tail.iter
  let has_cycle = Tail.has_cycle
  let prefix_component = Tail.iter_component

  (* step-by-step iterator *)
  module S = Set.Make(G.V)

  type iterator = S.t * G.V.t list * G.t
      (** (h, st, g) where h is the set of marked vertices and st the stack
	  invariant: the first element of st is not in h i.e. to be visited *)

  let start g =
    let st = G.fold_vertex (fun v st -> v :: st) g [] in
    S.empty, st, g

  let get (s,st,_) = match st with
    | [] -> raise Exit
    | v :: _  -> v

  let step (s,st,g) = match st with
    | [] ->
	raise Exit
    | v :: st ->
	let s' = S.add v s in
	let st' = G.fold_succ (fun w st -> w :: st) g v st in
	let rec clean = function
	  | w :: st when S.mem w s' -> clean st
	  | st -> st
	in
	(s', clean st', g)

end

(* breadth-first search *)
module Bfs(G : G) = struct
  module H = Hashtbl.Make(G.V)

  let iter f g =
    let h = H.create 65537 in
    let q = Queue.create () in
    (* invariant: [h] contains exactly the vertices which have been pushed *)
    let push v =
      if not (H.mem h v) then begin H.add h v (); Queue.add v q end
    in
    let loop () =
      while not (Queue.is_empty q) do
	let v = Queue.pop q in
	f v;
	G.iter_succ push g v
      done
    in
    G.iter_vertex (fun v -> push v; loop ()) g

  let iter_component f g v0 =
    let h = H.create 65537 in
    let q = Queue.create () in
    (* invariant: [h] contains exactly the vertices which have been pushed *)
    let push v =
      if not (H.mem h v) then begin H.add h v (); Queue.add v q end
    in
    push v0;
    while not (Queue.is_empty q) do
      let v = Queue.pop q in
      f v;
      G.iter_succ push g v
    done

  (* step-by-step iterator *)

  (* simple, yet O(1)-amortized, persistent queues *)
  module Q = struct
    type 'a t = 'a list * 'a list
    exception Empty
    let empty = [], []
    let is_empty = function [], [] -> true | _ -> false
    let push x (i,o) = (x :: i, o)
    let pop = function
      | i, y :: o -> y, (i,o)
      | [], [] -> raise Empty
      | i, [] -> match List.rev i with
	  | x :: o -> x, ([], o)
	  | [] -> assert false
    let peek q = fst (pop q)
  end

  module S = Set.Make(G.V)

  (* state is [(s,q,g)] : [s] contains elements never been pushed in [q] *)
  type iterator = S.t * G.V.t Q.t * G.t

  let start g =
    let s = G.fold_vertex S.add g S.empty in
    s, Q.empty, g

  let get (s,q,g) =
    if Q.is_empty q then
      if S.is_empty s then raise Exit else S.choose s
    else
      Q.peek q

  let step (s,q,g) =
    let push v (s,q as acc) =
      if S.mem v s then
	S.remove v s, Q.push v q
      else
	acc
    in
    let v,s',q' =
      if Q.is_empty q then begin
	if S.is_empty s then raise Exit;
	let v = S.choose s in
	v, S.remove v s, q
      end else
	let v,q' = Q.pop q in
	v, s, q'
    in
    let s'',q'' = G.fold_succ push g v (s',q') in
    (s'',q'',g)

end


(* Graph traversal with marking. *)

module type GM = sig
  type t
  module V : sig type t end
  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
  module Mark : sig
    val clear : t -> unit
    val get : V.t -> int
    val set : V.t -> int -> unit
  end
end

module Mark(G : GM) = struct

  let dfs g =
    G.Mark.clear g;
    let n = ref 0 in
    let rec visit v =
      if G.Mark.get v = 0 then begin
	incr n;
	G.Mark.set v !n;
	G.iter_succ visit g v
      end
    in
    G.iter_vertex visit g

  (* invariant: [h v = 0] means not visited at all; [h v = 1] means
     already visited in the current component; [h v = 2] means
     already visited in another tree *)
  let has_cycle g =
    G.Mark.clear g;
    let rec visit v =
      G.Mark.set v 1;
      G.iter_succ
	(fun w ->
	   let m = G.Mark.get w in
	   if m = 1 then raise Exit;
	   if m = 0 then visit w)
	g v;
      G.Mark.set v 2
    in
    try G.iter_vertex (fun v -> if G.Mark.get v = 0 then visit v) g; false
    with Exit -> true

end

end
module Coloring: sig
#0 "graph/coloring.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(** [k]-coloring of undirected graphs.

    A [k]-coloring of a graph [g] is a mapping [c] from nodes to [\{1,...,k\}]
    such that [c(u) <> c(v)] for any edge [u-v] in [g]. *)

(** {2 Graph coloring for graphs without marks} *)

(** Minimal graph signature for {!Make}.
    Sub-signature of {!Sig.G}. *)
module type G = sig
  val is_directed : bool
  type t
  val nb_vertex : t -> int
  module V : Sig.COMPARABLE
  val out_degree : t -> V.t -> int
  val iter_vertex : (V.t -> unit) -> t -> unit
  val fold_vertex : (V.t -> 'a -> 'a) -> t  -> 'a -> 'a
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
  val fold_succ : (V.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
end

(** Provide a function for [k]-coloring a graph. *)
module Make(G: G) : sig

  module H : Hashtbl.S with type key = G.V.t
    (** Hash tables used to store the coloring *)

  val coloring : G.t -> int -> int H.t
    (** [coloring g k] colors the graph [g] with [k] colors and returns the
        coloring as a hash table mapping nodes to their colors. *)

end

(** {2 Graph coloring for graph with integer marks} *)

(** Minimal graph signature for {!Mark}.
    Sub-signature of {!Sig.IM}. *)
module type GM = sig
  val is_directed : bool
  type t
  val nb_vertex : t -> int
  module V : Sig.COMPARABLE
  val out_degree : t -> V.t -> int
  val iter_vertex : (V.t -> unit) -> t -> unit
  val fold_vertex : (V.t -> 'a -> 'a) -> t  -> 'a -> 'a
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
  val fold_succ : (V.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
  module Mark : sig
    val get : V.t -> int
    val set : V.t -> int -> unit
  end
end

(** Provide a function for [k]-coloring a graph with integer marks. 
    The provided function is more efficient that the one provided by functor
    {!Make} above. *)
module Mark(G : GM) : sig

  exception NoColoring

  val coloring : G.t -> int -> unit
    (** [coloring g k] colors the nodes of graph [g] using k colors,
	assigning the marks integer values between 1 and k.
        raises [NoColoring] when there is no possible coloring.

        The graph marks may be partially set before starting; the meaning of
        initial values is as follows:
	- 0: a node to be colored
	- any value between 1 and k: a color already assigned
	- any value greater than k: a node to be ignored 

	@raise NoColoring if [g] cannot be [k]-colored. *)

end
end = struct
#0 "graph/coloring.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

module type GM = sig
  val is_directed : bool
  type t
  val nb_vertex : t -> int
  module V : Sig.COMPARABLE
  val out_degree : t -> V.t -> int
  val iter_vertex : (V.t -> unit) -> t -> unit
  val fold_vertex : (V.t -> 'a -> 'a) -> t  -> 'a -> 'a
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
  val fold_succ : (V.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
  module Mark : sig
    val get : V.t -> int
    val set : V.t -> int -> unit
  end
end

(** Graph coloring with marking. 
    Only applies to imperative graphs with marks. *)
module Mark(G : GM) = struct

  exception NoColoring

  module Bfs = Traverse.Bfs(G)
  
  let coloring g k =
    (* first step: we eliminate vertices with less than [k] successors *)
    let stack = Stack.create () in
    let nb_to_color = ref (G.nb_vertex g) in
    let count = ref 1 in
    while !count > 0 do 
      count := 0;
      let erase v = incr count; G.Mark.set v (k+1); Stack.push v stack in
      G.iter_vertex 
	(fun v -> if G.Mark.get v = 0 && G.out_degree g v < k then erase v) 
	g;
      (*Format.printf "eliminating %d nodes@." !count;*)
      nb_to_color := !nb_to_color - !count
    done;
    (* second step: we k-color the remaining of the graph *)
    (* [try_color v i] tries to assign color [i] to vertex [v] *)
    let try_color v i =
      G.Mark.set v i;
      G.iter_succ (fun w -> if G.Mark.get w = i then raise NoColoring) g v
    in
    let uncolor v = G.Mark.set v 0 in
    if !nb_to_color > 0 then begin
      let rec iterate iter =
	let v = Bfs.get iter in
	let m = G.Mark.get v in
	if m > 0 then
	  iterate (Bfs.step iter)
	else begin
	  for i = 1 to k do
	    try try_color v i; iterate (Bfs.step iter)
	    with NoColoring -> ()
	  done;
	  uncolor v;
	  raise NoColoring
	end
      in
      try iterate (Bfs.start g) with Exit -> ()
    end;
    (* third step: we color the eliminated vertices, in reverse order *)
    Stack.iter
      (fun v -> 
	 try 
	   for i = 1 to k do 
	     try try_color v i; raise Exit with NoColoring -> ()
	   done;
	   raise NoColoring (* it may still fail on a self edge v->v *)
	 with Exit -> ())
      stack

end

(** Graph coloring for graphs without marks: we use an external hashtbl *)

module type G = sig
  val is_directed : bool
  type t
  val nb_vertex : t -> int
  module V : Sig.COMPARABLE
  val out_degree : t -> V.t -> int
  val iter_vertex : (V.t -> unit) -> t -> unit
  val fold_vertex : (V.t -> 'a -> 'a) -> t  -> 'a -> 'a
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
  val fold_succ : (V.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
end

module Make(G: G) = struct

  module H = Hashtbl.Make(G.V)

  let coloring g k =
    let h = H.create 97 in
    let module M = 
      Mark(struct
	     include G
	     module Mark = struct
	       let get v = try H.find h v with Not_found -> 0
	       let set v n = H.replace h v n
	     end
	   end )
    in
    M.coloring g k;
    h

end
end
module Topological: sig
#0 "graph/topological.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(** Topological order.

    This functor provides functions which allow iterating over a graph in
    topological order. *)

(** Minimal graph signature to provide.
    Sub-signature of {!Sig.G}. *)
module type G = sig
  type t
  module V : Sig.HASHABLE
  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
  val in_degree : t -> V.t -> int
end

(** Functor providing topological iterators over a graph. *)
module Make(G: G) : sig

  val fold : (G.V.t -> 'a -> 'a) -> G.t -> 'a -> 'a
    (** [fold action g seed] allows iterating over the graph [g]
      in topological order. [action node accu] is called repeatedly,
      where [node] is the node being visited, and [accu] is the result of
      the [action]'s previous invocation, if any, and [seed] otherwise.
      If [g] contains cycles, the order is unspecified inside the cycles and
      every node in the cycles will be presented exactly once. *)

  val iter : (G.V.t -> unit) -> G.t -> unit
    (** [iter action] calls [action node] repeatedly. Nodes are (again)
        presented to [action] in topological order.
        The order is the same as for [fold]. *)

end


end = struct
#0 "graph/topological.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

module type G = sig
  type t
  module V : Sig.HASHABLE
  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
  val in_degree : t -> V.t -> int
end

module Make(G: G) = struct

  module H = Hashtbl.Make(G.V)

  let fold f g acc =
    let degree = H.create 997 in
    let todo = Queue.create () in
    let push x =
      H.remove degree x;
      Queue.push x todo
    in
    let rec walk acc =
      if Queue.is_empty todo then
        (* let's find any node of minimal degree *)
	let min =
	  H.fold
	    (fun v d acc ->
	       match acc with
	       | None -> Some (v, d)
	       | Some(_, min) -> if d < min then Some (v, d) else acc)
	    degree
	    None
	in
	match min with
	| None -> acc
	| Some(v, _) -> push v; walk acc
      else
	let v = Queue.pop todo in
	let acc = f v acc in
	G.iter_succ
	  (fun x->
             try
               let d = H.find degree x in
	       if d = 1 then push x else H.replace degree x (d-1)
             with Not_found ->
	       (* [x] already visited *)
	       ())
	  g v;
	walk acc
    in
    G.iter_vertex
      (fun v ->
	 let d = G.in_degree g v in
	 if d = 0 then Queue.push v todo
	 else H.add degree v d)
      g;
    walk acc

  let iter f g = fold (fun v () -> f v) g ()

end
end
module Components: sig
#0 "graph/components.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: components.mli,v 1.12 2004-10-22 14:42:06 signoles Exp $ *)

(** Strongly connected components. *)

open Util

(** Minimal graph signature required by {!Make}.
    Sub-signature of {!Sig.G}. *)
module type G = sig
  type t
  module V : Sig.COMPARABLE
  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
end

(** Functor providing functions to compute strongly connected components of a
    graph. *)
module Make (G: G) : sig

  val scc : G.t -> int * (G.V.t -> int)
    (** [scc g] computes the strongly connected components of [g].
	The result is a pair [(n,f)] where [n] is the number of
	components. Components are numbered from [0] to [n-1], and
	[f] is a function mapping each vertex to its component
	number. In particular, [f u = f v] if and only if [u] and
	[v] are in the same component. Another property of the
	numbering is that components are numbered in a topological
	order: if there is an arc from [u] to [v], then [f u >= f u] *)

  val scc_array : G.t -> G.V.t list array
    (** [scc_array] computes the strongly connected components of [g].
	Components are stored in the resulting array, indexed with a
	numbering with the same properties as for [scc] above. *)

  val scc_list : G.t -> G.V.t list list
    (** [scc_list] computes the strongly connected components of [g].
	The result is a partition of the set of the vertices of [g]. *)

end
end = struct
#0 "graph/components.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: components.ml,v 1.9 2004-10-22 14:42:06 signoles Exp $ *)

open Util

module type G = sig
  type t
  module V : Sig.COMPARABLE
  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
end

module Make(G: G) = struct

  module H = Hashtbl.Make(G.V)
  module S = Set.Make(G.V)

  let scc g =
    let root = H.create 997 in
    let hashcomp = H.create 997 in
    let stack = ref [] in
    let numdfs = ref 0 in
    let numcomp = ref 0 in
    let rec pop x c = function
      | (y, w) :: l when y > x -> 
	  H.add hashcomp w !numcomp; 
	  pop x (S.add w c) l
      | l -> c,l
    in
    let rec visit v = 
      if not (H.mem root v) then
	begin
	  let n = incr numdfs; !numdfs in
	  H.add root v n; 
	  G.iter_succ 
	    (fun w -> 
	       visit w;
	       if not (H.mem hashcomp w) then 
		 H.replace root v (min (H.find root v) (H.find root w)))
	    g v;
	  if H.find root v = n then 
	    (H.add hashcomp v !numcomp;
	     let comp,s = pop n (S.add v S.empty) !stack in 
	     stack:= s;
	     incr numcomp)
	  else stack := (n,v)::!stack;
	end
    in 
    G.iter_vertex visit g;
    (!numcomp,(fun v -> H.find hashcomp v))

  let scc_array g =
    let n,f = scc g in
    let t = Array.make n [] in
    G.iter_vertex 
      (fun v -> let i = f v in t.(i) <- v::t.(i)) g;
    t

  let scc_list g =
    let _,scc = scc g in
    let tbl = Hashtbl.create 97 in
    G.iter_vertex 
      (fun v -> 
	 let n = scc v in
	 try
	   let l = Hashtbl.find tbl n in
	   l := v :: !l
	 with Not_found ->
	   Hashtbl.add tbl n (ref [ v ]))
      g;
    Hashtbl.fold (fun _ v l -> !v :: l) tbl []


end
end
module Kruskal: sig
#0 "graph/kruskal.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: kruskal.mli,v 1.5 2005-06-30 10:48:55 filliatr Exp $ *)

(** Kruskal's minimum-spanning-tree algorithm. *)

(** Minimal graph signature for Kruskal.
    Sub-signature of {!Sig.G}. *)
module type G = sig
  type t 
  module V : Sig.COMPARABLE 
  module E : sig 
    type t 
    type label 
    val label : t -> label 
    val dst : t -> V.t 
    val src : t -> V.t
  end 
  val fold_vertex : (V.t -> 'a -> 'a) -> t -> 'a -> 'a
  val iter_edges_e : (E.t -> unit) -> t ->  unit
end

(** Functor providing an implementation of Kruskal's minimum-spanning-tree 
    algorithm. 
    Parameter [W] ensures that label on edges are comparable. *)
module Make(G: G)(W: Sig.ORDERED_TYPE with type t = G.E.label) : sig
  val spanningtree : G.t -> G.E.t list
end  

(** {2 Generic version where union-find implementation is provided} *)

(** Signature of union-find. *)
module type UNIONFIND = sig
  type elt
  type t
  val init : elt list -> t
  val find : elt -> t -> elt
  val union : elt -> elt -> t -> unit
end

(** Functor providing an implementation of Kruskal's minimum-spanning-tree 
    algorithm using a user-defined union-find algorithm.
    Parameter [W] ensures that label on edges are comparable. *)
module Generic
  (G: G)
  (W: Sig.ORDERED_TYPE with type t = G.E.label)
  (UF: UNIONFIND with type elt = G.V.t) : 
sig
  val spanningtree : G.t -> G.E.t list
end  
end = struct
#0 "graph/kruskal.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: kruskal.ml,v 1.5 2005-06-30 10:48:55 filliatr Exp $ *)

open Util

module type UNIONFIND = sig
  type elt
  type t
  val init : elt list -> t
  val find : elt -> t -> elt
  val union : elt -> elt -> t -> unit
end

module type G = sig
  type t 
  module V : Sig.COMPARABLE 
  module E : sig 
    type t 
    type label 
    val label : t -> label 
    val dst : t -> V.t 
    val src : t -> V.t
  end 
  val fold_vertex : (V.t -> 'a -> 'a) -> t -> 'a -> 'a
  val iter_edges_e : (E.t -> unit) -> t ->  unit
end

module Generic
  (G: G)
  (W : Sig.ORDERED_TYPE with type t = G.E.label)
  (UF: UNIONFIND with type elt = G.V.t) =
struct
    
  let spanningtree g =   
    let vertices = G.fold_vertex (fun v a -> v :: a) g [] in
    let uf = UF.init vertices in
    let edges = 
      let l = ref [] in
      G.iter_edges_e (fun e -> l := e :: !l) g;
      List.sort (fun e e'-> W.compare (G.E.label e) (G.E.label e')) !l
    in
    let s = ref [] in
    let cover e =
      let u, v = G.E.src e, G.E.dst e in
      if G.V.compare (UF.find u uf) (UF.find v uf) <> 0 then begin
	UF.union u v uf; 
	s := e :: !s
      end
    in
    List.iter cover edges;
    !s

end

module Make(G: G)(W : Sig.ORDERED_TYPE with type t=G.E.label) = 
  Generic(G)(W)(Unionfind.Make(G.V))

end
module Flow: sig
#0 "graph/flow.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(** Algorithms on flows 

    The following flow algorithms only apply to networks, that are
    directed graphs together with a source (a 0 in-degree vertex) and a 
    terminal (a 0 out-degree vertex). *)

(** {1 Maximum flow algorithms} *)

(** Signature for edges' flow. *)
module type FLOW = sig

  type t
    (** Type of edges. *)

  type label
    (** Type of labels on edges. *)

  (** Maximum and minimum capacities for a label on an edge. *)

  val max_capacity : label -> t
  val min_capacity : label -> t

  (** Current flow for a label on an edge. *)

  val flow : label -> t

  (** [+] and [-] on flows. *)

  val add : t -> t -> t
  val sub : t -> t -> t

  (** Neutral element for [add] and [sub]. *)

  val zero : t

  (** A total ordering over flows. *)

  val compare : t -> t -> int

end

(**  {2 Goldberg maximal flow algorithm} *)

(** Minimal graph signature for Goldberg.
    Sub-signature of {!Sig.G}. *)
module type G_GOLDBERG = sig
  type t
  module V : Sig.COMPARABLE
  module E : Sig.EDGE with type vertex = V.t
  val nb_vertex : t -> int
  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_edges_e : (E.t -> unit) -> t -> unit
  val fold_succ_e : (E.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
  val fold_pred_e : (E.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
end

module Goldberg(G: G_GOLDBERG)(F: FLOW with type label = G.E.label) : sig
      
  val maxflow : G.t -> G.V.t -> G.V.t -> (G.E.t -> F.t) * F.t
    (** [maxflow g v1 v2] searchs the maximal flow from source [v1] to
	terminal [v2] using the Goldberg algorithm. It returns the new
	flows on each edges and the growth of the flow. *)

end

(**  {2 Ford-Fulkerson maximal flow algorithm} *)

(** Minimal digraph signature for Ford-Fulkerson.
    Sub-signature of {!Sig.G}. *)
module type G_FORD_FULKERSON = sig
  type t
  module V : Sig.HASHABLE
  module E : sig
    type t
    type label
    val src : t -> V.t
    val dst : t -> V.t
    val label : t -> label
  end
  val iter_succ_e : (E.t -> unit) -> t -> V.t -> unit
  val iter_pred_e : (E.t -> unit) -> t -> V.t -> unit
end

module Ford_Fulkerson
  (G: G_FORD_FULKERSON)
  (F: FLOW with type label = G.E.label) :
sig

  val maxflow : G.t -> G.V.t -> G.V.t -> (G.E.t -> F.t) * F.t
      (** [maxflow g v1 v2] searchs the maximal flow from source [v1]
	  to terminal [v2] using the Ford-Fulkerson algorithm. It
	  returns the new flows on each edges and the growth of the
	  flow. *)

end
end = struct
#0 "graph/flow.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

module type FLOW = sig
  type t
  type label
  val max_capacity : label -> t
  val min_capacity : label -> t
  val flow : label -> t
  val add : t -> t -> t
  val sub : t -> t -> t
  val zero : t
  val compare : t -> t -> int
end

module type G_GOLDBERG = sig
  type t
  module V : Sig.COMPARABLE
  module E : Sig.EDGE with type vertex = V.t
  val nb_vertex : t -> int
  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_edges_e : (E.t -> unit) -> t -> unit
  val fold_succ_e : (E.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
  val fold_pred_e : (E.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
end

module Goldberg(G: G_GOLDBERG)(F: FLOW with type label = G.E.label) = 
struct
  
  module V = Hashtbl.Make(G.V)
  module E = Hashtbl.Make(Util.HTProduct(G.V)(G.V)) 
  module Se = Set.Make(G.E)
  module Sv = Set.Make(G.V)

  let excedents = V.create 997
  let hauteur = V.create 997
  let flot = E.create 997

  let fold_booleen f = List.fold_left (fun r x->(f x) or r) false

  let capacite_restante g e = 
    F.sub (F.max_capacity (G.E.label e)) (E.find flot (G.E.src e, G.E.dst e))

  let reste_excedent x = F.compare (V.find excedents x) F.zero > 0 
      
  let flux_et_reflux g x = 
    let s = 
      G.fold_succ_e 
	(fun e s->
	   if F.compare 
	     (capacite_restante g e) (F.min_capacity (G.E.label e))
	     > 0 
	   then e::s else s) 
	g x [] 
    in 
    G.fold_pred_e 
      (fun e s -> 
	 if F.compare 
	   (E.find flot (G.E.src e, G.E.dst e)) (F.min_capacity (G.E.label e))
	   > 0 
	 then (G.E.create (G.E.dst e) (G.E.label e) (G.E.src e))::s else s)
      g x s

  let pousser g e l =
    let x, y = G.E.src e, G.E.dst e in
    let ex = V.find excedents x in
    let cxy = capacite_restante g e in
    if F.compare ex F.zero > 0 &&
      F.compare cxy (F.min_capacity (G.E.label e)) > 0 &&
      V.find hauteur x = (V.find hauteur y + 1)
    then
      let d = if F.compare ex cxy < 0 then ex else cxy in
      let fxy = E.find flot (x,y) in
      let ex = V.find excedents x in
      let ey = V.find excedents y in
      E.replace flot (x,y) (F.add fxy d);
      E.replace flot (y,x) (F.sub F.zero (F.add fxy d));
      V.replace excedents x (F.sub ex d);
      V.replace excedents y (F.add ey d);
      if reste_excedent x then l:=Sv.add x !l;
      if reste_excedent y then l:=Sv.add y !l;
      true
    else 
      (if F.compare ex F.zero > 0 then l:=Sv.add x !l; 
       false)

  let elever g p x = 
    let u = flux_et_reflux g x in
    reste_excedent x
    && not (G.V.equal x p) 
    && 
    List.for_all 
      (fun e -> (V.find hauteur (G.E.src e)) <= (V.find hauteur (G.E.dst e))) u
    && 
    (let min = 
       List.fold_left (fun m e -> min (V.find hauteur (G.E.dst e)) m) max_int u
     in
     V.replace hauteur x (1+min); 
     true)

  let init_preflot g s p = 
    G.iter_vertex (fun x -> V.add excedents x F.zero; V.add hauteur x 0) g;
    G.iter_edges_e 
      (fun e -> 
	 let x,y = G.E.src e, G.E.dst e in 
	 E.add flot (x,y) (F.flow (G.E.label e)); 
	 E.add flot (y,x) (F.sub F.zero (F.flow (G.E.label e))))
      g;
    V.add hauteur s (G.nb_vertex g);
    G.fold_succ_e 
      (fun e l -> 
	 let y = G.E.dst e in
	 let c = F.max_capacity (G.E.label e) in 
	 E.add flot (s,y) c;
	 E.add flot (y,s) (F.sub F.zero c);
	 V.add excedents y c;
	 y::l)
      g s []
      
  let maxflow g s p = 
    let push_and_pull l x = 
      G.fold_succ_e (fun e r->pousser g e l or r) g x false
      or G.fold_pred_e (fun e r->pousser g e l or r) g x false
    in
    let todo = ref (init_preflot g s p) in
    while 
      (fold_booleen (elever g p) !todo) or 
      (let l = ref Sv.empty in 
       let r = fold_booleen (push_and_pull l) !todo in
       todo:=Sv.elements !l; r)
    do () done;
    let flot_max = 
      G.fold_pred_e (fun e f -> F.add (E.find flot (G.E.src e,p)) f) g p F.zero
    in
    let flot_init = 
      G.fold_pred_e (fun e f -> F.add (F.flow (G.E.label e)) f) g p F.zero
    in
    let f e = 
      let x,y = G.E.src e, G.E.dst e in 
      try E.find flot (x,y) 
      with Not_found -> F.flow (G.E.label e)
    in
    f, F.sub flot_max flot_init
end

(*****************************************************************************)

module type G_FORD_FULKERSON = sig
  type t
  module V : Sig.HASHABLE
  module E : sig
    type t
    type label
    val src : t -> V.t
    val dst : t -> V.t
    val label : t -> label
  end
  val iter_succ_e : (E.t -> unit) -> t -> V.t -> unit
  val iter_pred_e : (E.t -> unit) -> t -> V.t -> unit
end

module Ford_Fulkerson
  (G: G_FORD_FULKERSON)
  (F: FLOW with type label = G.E.label) =
struct

  (* redefinition of F *)
  module F = struct
    include F

    type u =
      | Flow of F.t
      | Infinity

    let min x y = match x, y with
      | Flow _, Infinity -> x
      | Flow fx, Flow fy when F.compare fx fy < 0 -> x
      | (Infinity, _) | (Flow _, Flow _) -> y
  end

  module Mark = struct
    module H = Hashtbl.Make(G.V)
    type mark = Plus | Minus

    let marked = H.create 997
    let unvisited = Queue.create ()

    let clear () = H.clear marked

    let mem = H.mem marked

    let set s e tag = 
      assert (not (mem s));
      H.add marked s (e, tag);
      Queue.add s unvisited

    let get s : G.E.t * mark =
      let e, tag = H.find marked s in
      (match e with None -> assert false | Some e -> e), tag

    exception Empty = Queue.Empty
    let next () = Queue.pop unvisited
  end

  module Result = struct
    module H = 
      Hashtbl.Make
	(struct
	   open G
	   type t = E.t
	   module U = Util.HTProduct(V)(V)
	   let equal e1 e2 = U.equal (E.src e1, E.dst e1) (E.src e2, E.dst e2)
	   let hash e = U.hash (E.src e, E.dst e)
	 end)

    let create () = H.create 997

    let find = H.find

    let flow r e = 
      try
	find r e
      with Not_found ->
	let f = F.flow (G.E.label e) in
	H.add r e f;
	f

    let change op r e f =
      try
	H.replace r e (op (find r e) f);
      with Not_found ->
	assert false

    let grow = change F.add
    let reduce = change F.sub
  end

  let is_full r e =
    F.compare (F.max_capacity (G.E.label e)) (Result.flow r e) = 0

  let is_empty r e =
    F.compare (F.min_capacity (G.E.label e)) (Result.flow r e) = 0

  let set_flow r s t a =
    let rec loop t =
      if not (G.V.equal s t) then
	let e, tag = Mark.get t in
	match tag with 
	  | Mark.Plus -> Result.grow r e a; loop (G.E.src e)
	  | Mark.Minus -> Result.reduce r e a; loop (G.E.dst e)
    in
    loop t

  let grow_flow r s t a =
    let rec loop u b =
      if G.V.equal s u then begin
	match b with
	  | F.Infinity -> (* source = destination *)
	      assert (G.V.equal s t); 
	      a
	  | F.Flow f ->
	      set_flow r s t f;
	      F.add a f
      end else
	let e, tag = Mark.get u in
	let l = G.E.label e in
	match tag with
	  | Mark.Plus -> 
	      loop 
	        (G.E.src e) 
	        (F.min b (F.Flow (F.sub (F.max_capacity l) (Result.flow r e))))
	  | Mark.Minus -> 
	      loop 
	        (G.E.dst e) 
	        (F.min b (F.Flow (F.sub (Result.flow r e) (F.min_capacity l))))
    in
    loop t F.Infinity

  let maxflow g s t =
    let r = Result.create () in
    let succ s = 
      G.iter_succ_e
	(fun e ->
	   assert (G.V.equal s (G.E.src e));
	   let t = G.E.dst e in
	   if not (Mark.mem t || is_full r e) then 
	     Mark.set t (Some e) Mark.Plus)
	g s
    in
    let pred s = 
      G.iter_pred_e
	(fun e ->
	   assert (G.V.equal s (G.E.dst e));
	   let t = G.E.src e in
	   if not (Mark.mem t || is_empty r e) then
	     Mark.set t (Some e) Mark.Minus)
	g s
    in
    let internal_loop a =
      try
	while true do let s = Mark.next () in succ s; pred s done;
	assert false
      with Mark.Empty ->
	if Mark.mem t then grow_flow r s t a else a
    in
    let rec external_loop a =
      Mark.clear ();
      Mark.set s None Mark.Plus;
      let a' = internal_loop a in
      if a = a' then a else external_loop a'
    in
    let a = external_loop F.zero in
    (fun e -> try Result.find r e with Not_found -> F.flow (G.E.label e)), a

end
end
module Graphviz: sig
#0 "graph/graphviz.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(** Interface with {i GraphViz}

    This module provides a basic interface with dot and neato,
    two programs of the GraphViz toolbox.
    These tools are available at the following URLs:
    - {v http://www.graphviz.org v}
    - {v http://www.research.att.com/sw/tools/graphviz v} *)

open Format

(***************************************************************************)
(** {2 Common stuff} *)

(** Because the neato and dot engines present a lot of common points -
    in particular in the graph description language, large parts of
    the code is shared.  The [CommonAttributes] module defines
    attributes of graphs, vertices and edges that are understood by the
    two engines.  Then module [DotAttributes] and [NeatoAttributes]
    define attributes specific to dot and neato respectively. *)

(*-------------------------------------------------------------------------*)
(** {3 Common types and signatures} *)

type color = int

type color_with_transparency = int32
  (** The two least significant bytes encode the transparency information;
      the six most signification are the standard RGB color *)

val color_to_color_with_transparency: color -> color_with_transparency


type arrow_style =
  [ `None | `Normal | `Inv | `Dot | `Odot | `Invdot | `Invodot ]

(** The [ATTRIBUTES] module type defines the interface for the engines. *)
module type ATTRIBUTES = sig

  type graph  (** Attributes of graphs. *)

  type vertex (** Attributes of vertices. *)

  type edge   (** Attributes of edges. *)

  (** Attributes of (optional) boxes around vertices. *)
  type subgraph = {
    sg_name : string;            (** Box name. *)
    sg_attributes : vertex list; (** Box attributes. *)
  }

end

(*-------------------------------------------------------------------------*)
(** {3 Common attributes} *)

(** The [CommonAttributes] module defines attributes for graphs, vertices and
    edges that are available in the two engines, dot and neato. *)
module CommonAttributes : sig

  (** Attributes of graphs. *)
  type graph =
    [ `Center of bool
        (** Centers the drawing on the page.  Default value is [false]. *)
    | `Fontcolor of color
        (** Sets the font color.  Default value is [black]. *)
    | `Fontname of string
        (** Sets the font family name.  Default value is ["Times-Roman"]. *)
    | `Fontsize of int
        (** Sets the type size (in points).  Default value is [14]. *)
    | `Label of string
        (** Caption for graph drawing. *)
    | `Orientation of [ `Portrait | `Landscape ]
        (** Sets the page orientation.  Default value is [`Portrait]. *)
    | `Page of float * float
        (** Sets the PostScript pagination unit, e.g [8.5, 11.0]. *)
    | `Pagedir of [ `TopToBottom | `LeftToRight ]
        (** Traversal order of pages.  Default value is [`TopToBottom]. *)
    | `Size of float * float
        (** Sets the bounding box of drawing (in inches). *)
    | `OrderingOut
        (** Constrains  order of out-edges in a subgraph according to
          their file sequence *)
    ]

  (** Attributes of vertices. *)
  type vertex =
    [ `Color of color
        (** Sets the color of the border of the vertex.
	  Default value is [black] *)
    | `ColorWithTransparency of color_with_transparency
        (** Sets the color of the border of the vertex with a transparency
            component. Default value is fully opaque [black] *)
    | `Fontcolor of color
        (** Sets the label font color.  Default value is [black]. *)
    | `Fontname of string
        (** Sets the label font family name.  Default value is
            ["Times-Roman"]. *)
    | `Fontsize of int
        (** Sets the label type size (in points).  Default value is [14].
         *)
    | `Height of float
        (** Sets the minimum height.  Default value is [0.5]. *)
    | `Label of string
        (** Sets the label printed in the vertex.
	    The string may include escaped
            newlines [\n], [\l], or [\r] for center, left, and right justified
	    lines.
            Record labels may contain recursive box lists delimited by { | }.
	*)
    | `Orientation of float
        (** Vertex rotation angle, in degrees.  Default value is [0.0]. *)
    | `Peripheries of int
        (** Sets  the  number  of periphery lines drawn around the polygon. *)
    | `Regular of bool
        (** If [true], then the polygon is made regular, i.e. symmetric about
	    the x and y axis, otherwise  the polygon   takes   on   the  aspect
	    ratio of the label.  Default value is [false]. *)
    | `Shape of
        [`Ellipse | `Box | `Circle | `Doublecircle | `Diamond
        | `Plaintext | `Record | `Polygon of int * float]
        (** Sets the shape of the vertex.  Default value is [`Ellipse].
            [`Polygon (i, f)] draws a polygon with [n] sides and a skewing
            of [f]. *)
    | `Style of [ `Filled | `Solid | `Dashed | `Dotted | `Bold | `Invis ]
        (** Sets the layout style of the vertex.
	    Several styles may be combined simultaneously. *)
    | `Width of float
        (** Sets the minimum width.  Default value is [0.75]. *)
    ]

  (** Attributes of edges. *)
  type edge =
    [ `Color of color
        (** Sets the edge stroke color.  Default value is [black]. *)
    | `ColorWithTransparency of color_with_transparency
        (** Sets the edge stroke color with a transparency
            component. Default value is fully opaque [black] *)
    | `Decorate of bool
        (** If [true], draws a line connecting labels with their edges. *)
    | `Dir of [ `Forward | `Back | `Both | `None ]
        (** Sets arrow direction.  Default value is [`Forward]. *)
    | `Fontcolor of color
        (** Sets the label font color.  Default value is [black]. *)
    | `Fontname of string
        (** Sets the label font family name.  Default value is
	    ["Times-Roman"]. *)
    | `Fontsize of int
        (** Sets the label type size (in points).  Default value is [14]. *)
    | `Label of string
        (** Sets the label to be attached to the edge.  The string may include
	    escaped newlines [\n], [\l], or [\r] for centered, left, or right
	    justified lines. *)
    | `Labelfontcolor of color
        (** Sets the font color for head and tail labels.  Default value is
            [black]. *)
    | `Labelfontname of string
        (** Sets the font family name for head and tail labels.  Default
            value is ["Times-Roman"]. *)
    | `Labelfontsize of int
        (** Sets the font size for head and tail labels (in points).
            Default value is [14]. *)
    | `Style of [ `Solid | `Dashed | `Dotted | `Bold | `Invis ]
        (** Sets the layout style of the edge.  Several styles may be combined
            simultaneously. *)
    ]

end

(***************************************************************************)
(** {2 Interface with the dot engine} *)

(** [DotAttributes] extends [CommonAttributes] and implements [ATTRIBUTES]. *)
module DotAttributes : sig

  (** Attributes of graphs.  They include all common graph attributes and
      several specific ones.  All attributes described in the "dot User's
      Manual, February 4, 2002" are handled, excepted: clusterank, color,
      compound, labeljust, labelloc, ordering, rank, remincross, rotate,
      searchsize and style. *)
  type graph =
    [ CommonAttributes.graph
    | `Bgcolor of color
        (** Sets the background color and the inital fill color. *)
    | `BgcolorWithTransparency of color_with_transparency
        (** Sets the background color and the inital fill color with
            a transparency component. *)
    | `Comment of string
        (** Comment string. *)
    | `Concentrate of bool
        (** If [true], enables edge concentrators.  Default value is [false]. *)
    | `Fontpath of string
        (** List of directories for fonts. *)
    | `Layers of string list
        (** List of layers. *)
    | `Margin of float
        (** Sets the page margin (included in the page size).  Default value is
            [0.5]. *)
    | `Mclimit of float
        (** Scale factor for mincross iterations.  Default value is [1.0]. *)
    | `Nodesep of float
        (** Sets the minimum separation between nodes, in inches.  Default
            value is [0.25]. *)
    | `Nslimit of int
        (** If set of [f], bounds network simplex iterations by [f *
            <number of nodes>] when ranking nodes. *)
    | `Nslimit1 of int
        (** If set of [f], bounds network simplex iterations by [f *
            <number of nodes>] when setting x-coordinates. *)
    | `Ranksep of float
        (** Sets the minimum separation between ranks. *)
    | `Quantum of float
        (** If not [0.0], node label dimensions will be rounded to integral
	    multiples of it.  Default value is [0.0]. *)
    | `Rankdir of [ `TopToBottom | `LeftToRight ]
        (** Direction of rank ordering.  Default value is [`TopToBottom]. *)
    | `Ratio of [ `Float of float | `Fill | `Compress| `Auto ]
        (** Sets the aspect ratio. *)
    | `Samplepoints of int
        (** Number of points used to represent ellipses and circles on output.
	    Default value is [8]. *)
    | `Url of string
        (** URL associated with graph (format-dependent). *)
    ]

  (** Attributes of nodes.  They include all common node attributes and
      several specific ones.  All attributes described in the "dot User's
      Manual, February 4, 2002" are handled, excepted: bottomlabel, group,
      shapefile and toplabel. *)
  type vertex =
    [ CommonAttributes.vertex
    | `Comment of string
        (** Comment string. *)
    | `Distortion of float
        (* TEMPORARY *)
    | `Fillcolor of color
        (** Sets the fill color (used when `Style filled).  Default value
            is [lightgrey]. *)
    | `FillcolorWithTransparency of color_with_transparency
        (** Sets the fill color (used when `Style filled) with a transparency
            component.  Default value is fully opaque [lightgrey]. *)
    | `Fixedsize of bool
        (** If [true], forces the given dimensions to be the actual ones.
            Default value is [false]. *)
    | `Layer of string
        (** Overlay. *)
    | `Url of string
        (** The  default  url  for  image  map  files; in PostScript files,
            the base URL for all relative URLs, as recognized by Acrobat
	    Distiller 3.0 and up. *)
    | `Z of float
        (** z coordinate for VRML output. *)
    ]

  (** Attributes of edges.  They include all common edge attributes and
      several specific ones.  All attributes described in the "dot User's
      Manual, February 4, 2002" are handled, excepted: lhead and ltail. *)
  type edge =
    [ CommonAttributes.edge
    | `Arrowhead of arrow_style
        (** Sets the style of the head arrow.  Default value is [`Normal]. *)
    | `Arrowsize of float
        (** Sets the scaling factor of arrowheads.  Default value is [1.0]. *)
    | `Arrowtail of arrow_style
        (** Sets the style of the tail arrow.  Default value is [`Normal]. *)
    | `Comment of string
        (** Comment string. *)
    | `Constraint of bool
        (** If [false], causes an edge to be ignored for rank assignment.
            Default value is [true]. *)
    | `Headlabel of string
        (** Sets the label attached to the head arrow. *)
    | `Headport of [ `N | `NE | `E | `SE | `S | `SW | `W | `NW ]
        (* TEMPORARY *)
    | `Headurl of string
        (** Url attached to head label if output format is ismap. *)
    | `Labelangle of float
        (** Angle in degrees which head or tail label is rotated off edge.
            Default value is [-25.0]. *)
    | `Labeldistance of float
        (** Scaling factor for distance of head or tail label from node.
            Default value is [1.0]. *)
    | `Labelfloat of bool
        (** If [true], lessen constraints on edge label placement.
            Default value is [false]. *)
    | `Layer of string
        (** Overlay. *)
    | `Minlen of int
        (** Minimum rank distance between head an tail.
	    Default value is [1]. *)
    | `Samehead of string
        (** Tag for head node; edge heads with the same tag are merged onto the
	    same port. *)
    | `Sametail of string
        (** Tag for tail node; edge tails with the same tag are merged onto the
	    same port. *)
    | `Taillabel of string
        (** Sets the label attached to the tail arrow. *)
    | `Tailport of [ `N | `NE | `E | `SE | `S | `SW | `W | `NW ]
        (* TEMPORARY *)
    | `Tailurl of string
        (** Url attached to tail label if output format is ismap. *)
    | `Weight of int
        (** Sets the integer cost of stretching the edge.  Default value is
            [1]. *)
    ]

  (** Subgraphs have a name and some vertices. *)
  type subgraph = {
    sg_name : string;
    sg_attributes : vertex list;
  }

end

(** Graph module with dot attributes *)
module type GraphWithDotAttrs = sig

  include Sig.G

  val graph_attributes: t -> DotAttributes.graph list

  (** Vertex attributes *)

  val default_vertex_attributes: t -> DotAttributes.vertex list
  val vertex_name : V.t -> string
  val vertex_attributes: V.t -> DotAttributes.vertex list

  (** Edge attributes *)

  val default_edge_attributes: t -> DotAttributes.edge list
  val edge_attributes: E.t -> DotAttributes.edge list

  val get_subgraph : V.t -> DotAttributes.subgraph option
    (** The box (if exists) which the vertex belongs to. Boxes with same
	   names are not distinguished and so they should have the same
	   attributes. *)

end

module Dot
  (X : sig

     (** Graph implementation. Sub-signature of {!Sig.G} *)

     type t
     module V : sig type t end
     module E : sig type t val src : t -> V.t val dst : t -> V.t end
     val iter_vertex : (V.t -> unit) -> t -> unit
     val iter_edges_e : (E.t -> unit) -> t -> unit

     (** Graph, vertex and edge attributes. *)

     val graph_attributes: t -> DotAttributes.graph list

     val default_vertex_attributes: t -> DotAttributes.vertex list
     val vertex_name : V.t -> string
     val vertex_attributes: V.t -> DotAttributes.vertex list

     val get_subgraph : V.t -> DotAttributes.subgraph option
       (** The box (if exists) which the vertex belongs to. Boxes with same
	   names are not distinguished and so they should have the same
	   attributes. *)

     val default_edge_attributes: t -> DotAttributes.edge list
     val edge_attributes: E.t -> DotAttributes.edge list

   end) :
sig

  val fprint_graph: formatter -> X.t -> unit
    (** [fprint_graph ppf graph] pretty prints the graph [graph] in
	the CGL language on the formatter [ppf]. *)

  val output_graph: out_channel -> X.t -> unit
    (** [output_graph oc graph] pretty prints the graph [graph] in the dot
	language on the channel [oc]. *)

end

(***************************************************************************)
(** {2 The neato engine} *)

module NeatoAttributes : sig

  (** Attributes of graphs.  They include all common graph attributes and
      several specific ones.  All attributes described in the "Neato User's
      manual, April 10, 2002" are handled. *)
  type graph =
    [ CommonAttributes.graph
    | `Margin of float * float
        (** Sets the page margin (included in the page size).  Default value is
            [0.5, 0.5]. *)
    | `Start of int
        (** Seed for random number generator. *)
    | `Overlap of bool
	(** Default value is [true]. *)
    | `Spline of bool
	(** [true] makes edge splines if nodes don't overlap.
	    Default value is [false]. *)
    | `Sep of float
	(** Edge spline separation factor from nodes.  Default value
	    is [0.0]. *)
    ]

  (** Attributes of nodes.  They include all common node attributes and
      several specific ones.  All attributes described in the "Neato User's
      manual, April 10, 2002" are handled. *)
  type vertex =
    [ CommonAttributes.vertex
    | `Pos of float * float
        (** Initial coordinates of the vertex. *)
    ]

  (** Attributes of edges.  They include all common edge attributes and
      several specific ones.  All attributes described in the "Neato User's
      manual, April 10, 2002" are handled. *)
  type edge =
    [ CommonAttributes.edge
    | `Id of string
        (** Optional value to distinguish multiple edges. *)
    | `Len of float
        (** Preferred length of edge.  Default value is [1.0]. *)
    | `Weight of float
        (** Strength of edge spring.  Default value is [1.0]. *)
    ]

  (** Subgraphs have a name and some vertices. *)
  type subgraph = {
    sg_name : string;
    sg_attributes : vertex list;
  }

end

module Neato
  (X : sig

     (** Graph implementation. Sub-signature of {!Sig.G}. *)

     type t
     module V : sig type t end
     module E : sig type t val src : t -> V.t val dst : t -> V.t end

     val iter_vertex : (V.t -> unit) -> t -> unit
     val iter_edges_e : (E.t -> unit) -> t -> unit

     (** Graph, vertex and edge attributes. *)

     val graph_attributes: t -> NeatoAttributes.graph list

     val default_vertex_attributes: t -> NeatoAttributes.vertex list
     val vertex_name : V.t -> string
     val vertex_attributes: V.t -> NeatoAttributes.vertex list

     val get_subgraph : V.t -> NeatoAttributes.subgraph option
       (** The box (if exists) which the vertex belongs to. Boxes with same
	   names are not distinguished and so they should have the same
	   attributes. *)

     val default_edge_attributes: t -> NeatoAttributes.edge list
     val edge_attributes: E.t -> NeatoAttributes.edge list

   end) :
sig

  val set_command: string -> unit
    (** Several functions provided by this module run the external program
	{i neato}.  By default, this command is supposed to be in the default
	path and is invoked by {i neato}.  The function
	[set_command] allows to set an alternative path at run time. *)

  exception Error of string
  val handle_error: ('a -> 'b) -> 'a -> 'b

  val fprint_graph: formatter -> X.t -> unit
    (** [fprint_graph ppf graph] pretty prints the graph [graph] in
	the CGL language on the formatter [ppf]. *)

  val output_graph: out_channel -> X.t -> unit
    (** [output_graph oc graph] pretty prints the graph [graph] in the dot
	language on the channel [oc]. *)

end

(*
Local Variables:
compile-command: "make -C .."
End:
*)
end = struct
#0 "graph/graphviz.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(** Interface with {i GraphViz}

    This module provides a basic interface with dot and neato,
    two programs of the GraphViz toolbox.
    These tools are available at the following URLs:
      http://www.graphviz.org/
      http://www.research.att.com/sw/tools/graphviz/ *)

open Format
open Pervasives (* for compatibility with ocaml 3.12.0+dev17
		   (incoming ocaml3.12) *)

(***************************************************************************)
(** {2 Common stuff} *)

(** Because the neato and dot engines present a lot of common points -
    in particular in the graph description language, large parts of
    the code is shared.  First, the [!CommonAttributes] module defines
    attributes of graphs, nodes and edges that are understood by the
    two engines.  Second, given a module (of type [!ENGINE])
    describing an engine the [!MakeEngine] functor provides suitable
    interface function for it. *)

(*-------------------------------------------------------------------------*)
(** {3 Common attributes} *)

type color = int

type color_with_transparency = int32

let color_to_color_with_transparency color =
  Int32.add (Int32.shift_left (Int32.of_int color) 8) 0xFFl

let fprint_color ppf color =
  fprintf ppf "\"#%06X\"" color

let fprint_color_with_transparency ppf color =
  fprintf ppf "\"#%08lX\"" color

let fprint_string ppf s = fprintf ppf "\"%s\"" s
(*  let s' = String.escaped s in
  if s' = s && s <> ""
  then fprintf ppf "%s" s
  else fprintf ppf "\"%s\"" s'*)

let fprint_string_user ppf s =
(*  let s = String.escaped s in*)
    fprintf ppf "\"%s\"" s

type arrow_style =
  [ `None | `Normal | `Inv | `Dot | `Odot | `Invdot | `Invodot ]

let fprint_arrow_style ppf = function
    `None -> fprintf ppf "none"
  | `Normal -> fprintf ppf "normal"
  | `Inv -> fprintf ppf "inv"
  | `Dot -> fprintf ppf "dot"
  | `Odot -> fprintf ppf "odot"
  | `Invdot -> fprintf ppf "invdot"
  | `Invodot -> fprintf ppf "invodot"

let fprint_dir ppf = function
    `TopToBottom -> fprintf ppf "TB"
  | `LeftToRight -> fprintf ppf "LR"

(** The [ATTRIBUTES] module type defines the interface for the engines. *)
module type ATTRIBUTES = sig

  type graph  (** Attributes of graphs. *)

  type vertex (** Attributes of vertices. *)

  type edge   (** Attributes of edges. *)

  (** Attributes of (optional) boxes around vertices. *)
  type subgraph = {
    sg_name : string;            (** Box name. *)
    sg_attributes : vertex list; (** Box attributes. *)
  }

end

(** The [CommonAttributes] module defines attributes for graphs, nodes and
    edges that are available in the two engines, dot and neato. *)
module CommonAttributes = struct

  (** Attributes of graphs. *)
  type graph =
    [ `Center of bool
        (** Centers the drawing on the page.  Default value is [false]. *)
    | `Fontcolor of color
        (** Sets the font color.  Default value is [black]. *)
    | `Fontname of string
        (** Sets the font family name.  Default value is ["Times-Roman"]. *)
    | `Fontsize of int
        (** Sets the type size (in points).  Default value is [14]. *)
    | `Label of string
        (** Caption for graph drawing. *)
    | `Orientation of [ `Portrait | `Landscape ]
        (** Sets the page orientation.  Default value is [`Portrait]. *)
    | `Page of float * float
        (** Sets the PostScript pagination unit, e.g [8.5, 11.0]. *)
    | `Pagedir of [ `TopToBottom | `LeftToRight ]
        (** Traversal order of pages.  Default value is [`TopToBottom]. *)
    | `Size of float * float
        (** Sets the bounding box of drawing (in inches). *)
    | `OrderingOut
        (** Constrains  order of out-edges in a subgraph according to
          their file sequence *)
    ]

  (** Attributes of nodes. *)
  type vertex =
    [ `Color of color
        (** Sets the color of the border of the node. Default value is [black]
         *)
    | `ColorWithTransparency of color_with_transparency
        (** Sets the color of the border of the vertex with a transparency
            component. Default value is fully opaque [black] *)
    | `Fontcolor of color
        (** Sets the label font color.  Default value is [black]. *)
    | `Fontname of string
        (** Sets the label font family name.  Default value is
            ["Times-Roman"]. *)
    | `Fontsize of int
        (** Sets the label type size (in points).  Default value is [14]. *)
    | `Height of float
        (** Sets the minimum height.  Default value is [0.5]. *)
    | `Label of string
        (** Sets the label printed in the node. The string may include escaped
            newlines [\n], [\l], or [\r] for center, left, and right justified
	    lines.
            Record labels may contain recursive box lists delimited by { | }.
	*)
    | `Orientation of float
        (** Node rotation angle, in degrees.  Default value is [0.0]. *)
    | `Peripheries of int
        (** Sets  the  number  of periphery lines drawn around the polygon. *)
    | `Regular of bool
        (** If [true], then the polygon is made regular, i.e. symmetric about
	    the x and y axis, otherwise  the polygon   takes   on   the  aspect
	    ratio of the label.  Default value is [false]. *)
    | `Shape of
        [`Ellipse | `Box | `Circle | `Doublecircle | `Diamond
        | `Plaintext | `Record | `Polygon of int * float]
        (** Sets the shape of the node.  Default value is [`Ellipse].
            [`Polygon (i, f)] draws a polygon with [n] sides and a skewing
            of [f]. *)
    | `Style of [ `Filled | `Solid | `Dashed | `Dotted | `Bold | `Invis ]
        (** Sets the layout style of the node.  Several styles may be combined
            simultaneously. *)
    | `Width of float
        (** Sets the minimum width.  Default value is [0.75]. *)
    ]

  (** Attributes of edges. *)
  type edge =
    [ `Color of color
        (** Sets the edge stroke color.  Default value is [black]. *)
    | `ColorWithTransparency of color_with_transparency
        (** Sets the color of the border of the vertex with a transparency
            component. Default value is fully opaque [black] *)
    | `Decorate of bool
        (** If [true], draws a line connecting labels with their edges. *)
    | `Dir of [ `Forward | `Back | `Both | `None ]
        (** Sets arrow direction.  Default value is [`Forward]. *)
    | `Fontcolor of color
        (** Sets the label font color.  Default value is [black]. *)
    | `Fontname of string
        (** Sets the label font family name.  Default value is
	    ["Times-Roman"]. *)
    | `Fontsize of int
        (** Sets the label type size (in points).  Default value is [14]. *)
    | `Label of string
        (** Sets the label to be attached to the edge.  The string may include
	    escaped newlines [\n], [\l], or [\r] for centered, left, or right
	    justified lines. *)
    | `Labelfontcolor of color
        (** Sets the font color for head and tail labels.  Default value is
            [black]. *)
    | `Labelfontname of string
        (** Sets the font family name for head and tail labels.  Default
            value is ["Times-Roman"]. *)
    | `Labelfontsize of int
        (** Sets the font size for head and tail labels (in points).
            Default value is [14]. *)
    | `Style of [ `Solid | `Dashed | `Dotted | `Bold | `Invis ]
        (** Sets the layout style of the edge.  Several styles may be combined
            simultaneously. *)
    ]

  (** Pretty-print. *)

  let fprint_orientation ppf = function
      `Portrait -> fprintf ppf "portrait"
    | `Landscape -> fprintf ppf "landscape"

  let fprint_graph ppf = function
      `Center b -> fprintf ppf "center=%i" (if b then 1 else 0)
    | `Fontcolor a -> fprintf ppf "fontcolor=%a" fprint_color a
    | `Fontname s -> fprintf ppf "fontname=%a" fprint_string s
    | `Fontsize i -> fprintf ppf "fontsize=%i" i
    | `Label s -> fprintf ppf "label=%a" fprint_string_user s
    | `Orientation a -> fprintf ppf "orientation=%a" fprint_orientation a
    | `Page (x, y) -> fprintf ppf "page=\"%f,%f\"" x y
    | `Pagedir a -> fprintf ppf "pagedir=%a" fprint_dir a
    | `Size (x, y) -> fprintf ppf "size=\"%f,%f\"" x y
    | `OrderingOut -> fprintf ppf "ordering=out"

  let fprint_shape ppf = function
    | `Ellipse -> fprintf ppf "ellipse"
    | `Box -> fprintf ppf "box"
    | `Circle -> fprintf ppf "circle"
    | `Doublecircle -> fprintf ppf "doublecircle"
    | `Diamond -> fprintf ppf "diamond"
    | `Plaintext -> fprintf ppf "plaintext"
    | `Record -> fprintf ppf "record"
    | `Polygon (i, f) -> fprintf ppf "polygon, sides=%i, skew=%f" i f

  let fprint_node_style ppf = function
      `Filled -> fprintf ppf "filled"
    | `Solid -> fprintf ppf "solid"
    | `Dashed -> fprintf ppf "dashed"
    | `Dotted -> fprintf ppf "dotted"
    | `Bold -> fprintf ppf "bold"
    | `Invis -> fprintf ppf "invis"

  let fprint_vertex ppf = function
    | `Color a -> fprintf ppf "color=%a" fprint_color a
    | `ColorWithTransparency a ->
        fprintf ppf "color=%a" fprint_color_with_transparency a
    | `Fontcolor a -> fprintf ppf "fontcolor=%a" fprint_color a
    | `Fontname s -> fprintf ppf "fontname=%a"  fprint_string s
    | `Fontsize i -> fprintf ppf "fontsize=%i" i
    | `Height f -> fprintf ppf "height=%f" f
    | `Label s -> fprintf ppf "label=%a" fprint_string_user s
    | `Orientation f -> fprintf ppf "orientation=%f" f
    | `Peripheries i -> fprintf ppf "peripheries=%i" i
    | `Regular b -> fprintf ppf "regular=%b" b
    | `Shape a -> fprintf ppf "shape=%a" fprint_shape a
    | `Style a -> fprintf ppf "style=%a" fprint_node_style a
    | `Width f -> fprintf ppf "width=%f" f

  let fprint_edge_style =
    fprint_node_style

  let fprint_arrow_direction ppf = function
      `Forward -> fprintf ppf "forward"
    | `Back -> fprintf ppf "back"
    | `Both -> fprintf ppf "both"
    | `None -> fprintf ppf "none"

  let fprint_edge ppf = function
    | `Color a -> fprintf ppf "color=%a" fprint_color a
    | `ColorWithTransparency a ->
        fprintf ppf "color=%a" fprint_color_with_transparency a
    | `Decorate b -> fprintf ppf "decorate=%b" b
    | `Dir a -> fprintf ppf "dir=%a" fprint_arrow_direction a
    | `Fontcolor a -> fprintf ppf "fontcolor=%a" fprint_color a
    | `Fontname s -> fprintf ppf "fontname=%a" fprint_string s
    | `Fontsize i -> fprintf ppf "fontsize=%i" i
    | `Label s -> fprintf ppf "label=%a" fprint_string_user s
    | `Labelfontcolor a -> fprintf ppf "labelfontcolor=%a" fprint_color a
    | `Labelfontname s -> fprintf ppf "labelfontname=\"%s\"" s
	(* (String.escaped s) *)
    | `Labelfontsize i -> fprintf ppf "labelfontsize=%i" i
    | `Style a -> fprintf ppf "style=%a" fprint_edge_style a

end


(*-------------------------------------------------------------------------*)
(** {3 The [MakeEngine] functor} *)

(** An engine is described by a module of the following signature. *)
module type ENGINE = sig

  module Attributes : sig
    include ATTRIBUTES
    val fprint_graph:formatter -> graph -> unit
    val fprint_vertex: formatter -> vertex -> unit
    val fprint_edge: formatter -> edge -> unit
  end

  (** The litteral name of the engine. *)
  val name: string

  (** The keyword for graphs ("digraph" for dot, "graph" for neato) *)
  val opening: string

  (** The litteral for edge arrows ("->" for dot, "--" for neato) *)
  val edge_arrow: string

end

module type GRAPH = sig

end

module MakeEngine
  (EN: ENGINE)
  (X : sig
     type t
     module V : sig type t end
     module E : sig type t val src : t -> V.t val dst : t -> V.t end

     val iter_vertex : (V.t -> unit) -> t -> unit
     val iter_edges_e : (E.t -> unit) -> t -> unit

     val graph_attributes: t -> EN.Attributes.graph list

     val default_vertex_attributes: t -> EN.Attributes.vertex list
     val vertex_name : V.t -> string
     val vertex_attributes: V.t -> EN.Attributes.vertex list

     val default_edge_attributes: t -> EN.Attributes.edge list
     val edge_attributes: E.t -> EN.Attributes.edge list
     val get_subgraph : V.t -> EN.Attributes.subgraph option
   end) =
struct

  let command = ref EN.name
  let set_command cmd =
    command := cmd

  exception Error of string

  let handle_error f arg =
    try
      f arg
    with
	Error msg ->
	  Printf.eprintf "%s: %s failure\n   %s\n"
	  Sys.argv.(0) EN.name msg;
	  flush stderr;
	  exit 2

    (** [fprint_graph_attributes ppf list] pretty prints a list of
        graph attributes on the formatter [ppf].  Attributes are separated
        by a ";". *)
    let fprint_graph_attributes ppf list =
       List.iter (function att ->
	 fprintf ppf "%a;@ " EN.Attributes.fprint_graph att
       ) list

   (** [fprint_graph_attribute printer ppf list] pretty prints a list of
       attributes on the formatter [ppf], using the printer [printer] for
       each attribute.  The list appears between brackets and attributes
       are speparated by ",".  If the list is empty, nothing is printed. *)
    let fprint_attributes fprint_attribute ppf = function
	[] -> ()
      | hd :: tl ->
	  let rec fprint_attributes_rec ppf = function
	      [] -> ()
	    | hd' :: tl' ->
		fprintf ppf ",@ %a%a"
		  fprint_attribute hd'
		  fprint_attributes_rec tl'
	  in
	  fprintf ppf " [@[<hov>%a%a@]]"
	    fprint_attribute hd
	    fprint_attributes_rec tl

    (** [fprint_graph_attributes ppf list] pretty prints a list of
        node attributes using the format of [fprint_attributes]. *)
    let fprint_node_attributes ppf list =
      fprint_attributes EN.Attributes.fprint_vertex ppf list

    (** [fprint_graph_attributes ppf list] pretty prints a list of
        edge attributes using the format of [fprint_attributes]. *)
    let fprint_edge_attributes ppf list =
      fprint_attributes EN.Attributes.fprint_edge ppf list

    (** [fprint_graph ppf graph] pretty prints the graph [graph] in
        the CGL language on the formatter [ppf]. *)
    let fprint_graph ppf graph =
      let subgraphs = Hashtbl.create 7 in

      (* Printing nodes. *)

      let print_nodes ppf =

	let default_node_attributes = X.default_vertex_attributes graph in
	if default_node_attributes  <> [] then
	  fprintf ppf "node%a;@ "
	    fprint_node_attributes default_node_attributes;

	X.iter_vertex
          (function node ->
             begin match X.get_subgraph node with
             | None -> ()
             | Some sg ->
                 try
                   let (sg,nodes) =
		     Hashtbl.find subgraphs sg.EN.Attributes.sg_name
		   in
                   Hashtbl.replace subgraphs
		     sg.EN.Attributes.sg_name (sg,node::nodes)
                 with Not_found ->
                   Hashtbl.add subgraphs sg.EN.Attributes.sg_name (sg,[node])
             end;
	     fprintf ppf "%s%a;@ "
	       (X.vertex_name node)
	       fprint_node_attributes (X.vertex_attributes node))
          graph

      in

      (* Printing subgraphs *)

      let print_subgraphs ppf =

        Hashtbl.iter
          (fun name (sg,nodes) ->
             fprintf ppf "@[<v 2>subgraph cluster_%s { %t%t };@]@\n"
               name

               (fun ppf ->
                  (List.iter
                     (fun n ->
			fprintf ppf "%a;@\n" EN.Attributes.fprint_vertex n)
                     sg.EN.Attributes.sg_attributes))

               (fun ppf ->
                  (List.iter
		     (fun n -> fprintf ppf "%s;" (X.vertex_name n))
                     nodes))
          )
          subgraphs

      in

      (* Printing edges *)

      let print_edges ppf =

	let default_edge_attributes = X.default_edge_attributes graph in
	if default_edge_attributes <> [] then
	  fprintf ppf "edge%a;@ "
	    fprint_edge_attributes default_edge_attributes;

	X.iter_edges_e (function edge ->
	                  fprintf ppf "%s %s %s%a;@ "
	                    (X.vertex_name (X.E.src edge))
	                    EN.edge_arrow
	                    (X.vertex_name (X.E.dst edge))
	                    fprint_edge_attributes (X.edge_attributes edge)
                       ) graph

      in

      fprintf ppf "@[<v>%s G {@ @[<v 2>  %a"
	EN.opening
	fprint_graph_attributes (X.graph_attributes graph);
      fprintf ppf "%t@ " print_nodes;
      fprintf ppf "%t@ " print_subgraphs;
      fprintf ppf "%t@ " print_edges;
      fprintf ppf "@]}@]"

    (** [output_graph oc graph] pretty prints the graph [graph] in the dot
	language on the channel [oc]. *)
    let output_graph oc graph =
      let ppf = formatter_of_out_channel oc in
      fprint_graph ppf graph;
      pp_print_flush ppf ()

  end

(***************************************************************************)
(** {2 Interface with the dot engine} *)

(** The [DotAttributes] module defines attributes for graphs, nodes and edges
    that are available in the dot engine. *)
module DotAttributes = struct

  (** Attributes of graphs.  They include all common graph attributes and
      several specific ones.  All attributes described in the "dot User's
      Manual, February 4, 2002" are handled, excepted: clusterank, color,
      compound, labeljust, labelloc, ordering, rank, remincross, rotate,
      searchsize and style.
   *)
  type graph =
    [ CommonAttributes.graph
    | `Bgcolor of color
        (** Sets the background color and the inital fill color. *)
    | `BgcolorWithTransparency of color_with_transparency
        (** Sets the background color and the inital fill color with
            a transparency component. *)
    | `Comment of string
        (** Comment string. *)
    | `Concentrate of bool
        (** If [true], enables edge concentrators.  Default value is [false]. *)
    | `Fontpath of string
        (** List of directories for fonts. *)
    | `Layers of string list
        (** List of layers. *)
    | `Margin of float
        (** Sets the page margin (included in the page size).  Default value is
            [0.5]. *)
    | `Mclimit of float
        (** Scale factor for mincross iterations.  Default value is [1.0]. *)
    | `Nodesep of float
        (** Sets the minimum separation between nodes, in inches.  Default
            value is [0.25]. *)
    | `Nslimit of int
        (** If set of [f], bounds network simplex iterations by [f *
            <number of nodes>] when ranking nodes. *)
    | `Nslimit1 of int
        (** If set of [f], bounds network simplex iterations by [f *
            <number of nodes>] when setting x-coordinates. *)
    | `Ranksep of float
        (** Sets the minimum separation between ranks. *)
    | `Quantum of float
        (** If not [0.0], node label dimensions will be rounded to integral
	    multiples of it.  Default value is [0.0]. *)
    | `Rankdir of [ `TopToBottom | `LeftToRight ]
        (** Direction of rank ordering.  Default value is [`TopToBottom]. *)
    | `Ratio of [ `Float of float | `Fill | `Compress| `Auto ]
        (** Sets the aspect ratio. *)
    | `Samplepoints of int
        (** Number of points used to represent ellipses and circles on output.
	    Default value is [8]. *)
    | `Url of string
        (** URL associated with graph (format-dependent). *)
    ]

  (** Attributes of nodes.  They include all common node attributes and
      several specific ones.  All attributes described in the "dot User's
      Manual, February 4, 2002" are handled, excepted: bottomlabel, group,
      shapefile and toplabel.
   *)
  type vertex =
    [ CommonAttributes.vertex
    | `Comment of string
        (** Comment string. *)
    | `Distortion of float
        (* TEMPORARY *)
    | `Fillcolor of color
        (** Sets the fill color (used when `Style filled).  Default value
            is [lightgrey]. *)
    | `FillcolorWithTransparency of color_with_transparency
        (** Sets the fill color (used when `Style filled) with a transparency
            component.  Default value is fully opaque [lightgrey]. *)
    | `Fixedsize of bool
        (** If [true], forces the given dimensions to be the actual ones.
            Default value is [false]. *)
    | `Layer of string
        (** Overlay. *)
    | `Url of string
        (** The  default  url  for  image  map  files; in PostScript files,
            the base URL for all relative URLs, as recognized by Acrobat
	    Distiller 3.0 and up. *)
    | `Z of float
        (** z coordinate for VRML output. *)
    ]

  (** Attributes of edges.  They include all common edge attributes and
      several specific ones.  All attributes described in the "dot User's
      Manual, February 4, 2002" are handled, excepted: lhead and ltail.
   *)
  type edge =
    [ CommonAttributes.edge
    | `Arrowhead of arrow_style
        (** Sets the style of the head arrow.  Default value is [`Normal]. *)
    | `Arrowsize of float
        (** Sets the scaling factor of arrowheads.  Default value is [1.0]. *)
    | `Arrowtail of arrow_style
        (** Sets the style of the tail arrow.  Default value is [`Normal]. *)
    | `Comment of string
        (** Comment string. *)
    | `Constraint of bool
        (** If [false], causes an edge to be ignored for rank assignment.
            Default value is [true]. *)
    | `Headlabel of string
        (** Sets the label attached to the head arrow. *)
    | `Headport of [ `N | `NE | `E | `SE | `S | `SW | `W | `NW ]
        (* TEMPORARY *)
    | `Headurl of string
        (** Url attached to head label if output format is ismap. *)
    | `Labelangle of float
        (** Angle in degrees which head or tail label is rotated off edge.
            Default value is [-25.0]. *)
    | `Labeldistance of float
        (** Scaling factor for distance of head or tail label from node.
            Default value is [1.0]. *)
    | `Labelfloat of bool
        (** If [true], lessen constraints on edge label placement.
            Default value is [false]. *)
    | `Layer of string
        (** Overlay. *)
    | `Minlen of int
        (** Minimum rank distance between head an tail.  Default value is [1]. *)
    | `Samehead of string
        (** Tag for head node; edge heads with the same tag are merged onto the
	    same port. *)
    | `Sametail of string
        (** Tag for tail node; edge tails with the same tag are merged onto the
	    same port. *)
    | `Taillabel of string
        (** Sets the label attached to the tail arrow. *)
    | `Tailport of [ `N | `NE | `E | `SE | `S | `SW | `W | `NW ]
        (* TEMPORARY *)
    | `Tailurl of string
        (** Url attached to tail label if output format is ismap. *)
    | `Weight of int
        (** Sets the integer cost of stretching the edge.  Default value is
            [1]. *)
    ]

    type subgraph = {
      sg_name : string;
      sg_attributes : vertex list;
    }

    (** {4 Pretty-print of attributes} *)

    let rec fprint_string_list ppf = function
      [] -> ()
      | [hd] -> fprintf ppf "%s" hd
      | hd :: tl -> fprintf ppf "%s,%a" hd fprint_string_list tl

    let fprint_ratio ppf = function
	`Float f -> fprintf ppf "%f" f
      | `Fill -> fprintf ppf "fill"
      | `Compress -> fprintf ppf "compress"
      | `Auto -> fprintf ppf "auto"

    let fprint_graph ppf = function
	#CommonAttributes.graph as att -> CommonAttributes.fprint_graph ppf att
      | `Bgcolor a -> fprintf ppf "bgcolor=%a" fprint_color a
      | `BgcolorWithTransparency a ->
          fprintf ppf "bcolor=%a" fprint_color_with_transparency a
      | `Comment s -> fprintf ppf "comment=%a" fprint_string s
      | `Concentrate b -> fprintf ppf "concentrate=%b" b
      | `Fontpath s -> fprintf ppf "fontpath=%a" fprint_string s
      | `Layers s -> fprintf ppf "layers=%a" fprint_string_list s
      | `Margin f -> fprintf ppf "margin=%f" f
      | `Mclimit f -> fprintf ppf "mclimit=%f" f
      | `Nodesep f -> fprintf ppf "nodesep=%f" f
      | `Nslimit i -> fprintf ppf "nslimit=%i" i
      | `Nslimit1 i -> fprintf ppf "nslimit1=%i" i
      | `Ranksep f -> fprintf ppf "ranksep=%f" f
      | `Quantum f -> fprintf ppf "quantum=%f" f
      | `Rankdir a -> fprintf ppf "rankdir=%a" fprint_dir a
      | `Ratio a -> fprintf ppf "ratio=%a" fprint_ratio a
      | `Samplepoints i -> fprintf ppf "samplepoints=%i" i
      | `Url s -> fprintf ppf "URL=\"%s\"" s (*(String.escaped s)*)

    let fprint_vertex ppf = function
	#CommonAttributes.vertex as att ->
	  CommonAttributes.fprint_vertex ppf att
      | `Comment s -> fprintf ppf "comment=%a" fprint_string s
      | `Distortion f -> fprintf ppf "distortion=%f" f
      | `Fillcolor a -> fprintf ppf "fillcolor=%a" fprint_color a
      | `FillcolorWithTransparency a ->
          fprintf ppf "fillcolor=%a" fprint_color_with_transparency a
      | `Fixedsize b -> fprintf ppf "fixedsize=%b" b
      | `Layer s -> fprintf ppf "layer=%a" fprint_string s
      | `Url s -> fprintf ppf "URL=\"%s\"" s (*(String.escaped s)*)
      | `Z f -> fprintf ppf "z=%f" f

    let fprint_port ppf = function
	`N -> fprintf ppf "n"
      | `NE -> fprintf ppf "ne"
      | `E -> fprintf ppf "e"
      | `SE -> fprintf ppf "se"
      | `S -> fprintf ppf "s"
      | `SW -> fprintf ppf "sw"
      | `W -> fprintf ppf "w"
      | `NW -> fprintf ppf "nw"

    let fprint_edge ppf = function
	#CommonAttributes.edge as att -> CommonAttributes.fprint_edge ppf att
      | `Arrowhead a -> fprintf ppf "arrowhead=%a" fprint_arrow_style a
      | `Arrowsize f -> fprintf ppf "arrowsize=%f" f
      | `Arrowtail a -> fprintf ppf "arrowtail=%a" fprint_arrow_style a
      | `Comment s -> fprintf ppf "comment=%a" fprint_string s
      | `Constraint b -> fprintf ppf "constraint=%b" b
      | `Headlabel s -> fprintf ppf "headlabel=%a" fprint_string s
      | `Headport a -> fprintf ppf "headport=%a" fprint_port a
      | `Headurl s -> fprintf ppf "headURL=%a" fprint_string s
      | `Labelangle f -> fprintf ppf "labelangle=%f" f
      | `Labeldistance f -> fprintf ppf "labeldistance=%f" f
      | `Labelfloat b -> fprintf ppf "labelfloat=%b" b
      | `Layer s -> fprintf ppf "layer=%a" fprint_string s
      | `Minlen i -> fprintf ppf "minlen=%i" i
      | `Samehead s -> fprintf ppf "samehead=%a" fprint_string s
      | `Sametail s -> fprintf ppf "sametail=%a" fprint_string s
      | `Taillabel s -> fprintf ppf "taillabel=%a" fprint_string s
      | `Tailport a -> fprintf ppf "tailport=%a" fprint_port a
      | `Tailurl s -> fprintf ppf "tailURL=%a" fprint_string s
      | `Weight i -> fprintf ppf "weight=%i" i

end

(** Graph modules with dot attributes *)
module type GraphWithDotAttrs = sig
  include Sig.G

 (** Graph, vertex and edge attributes. *)
  val graph_attributes: t -> DotAttributes.graph list

  (** Vertex attributes *)
  val default_vertex_attributes: t -> DotAttributes.vertex list
  val vertex_name : V.t -> string
  val vertex_attributes: V.t -> DotAttributes.vertex list

  (** Edge attributes *)
  val default_edge_attributes: t -> DotAttributes.edge list
  val edge_attributes: E.t -> DotAttributes.edge list

  val get_subgraph : V.t -> DotAttributes.subgraph option
    (** The box (if exists) which the vertex belongs to. Boxes with same
	   names are not distinguished and so they should have the same
	   attributes. *)
end

module Dot =
  MakeEngine (struct
		module Attributes = DotAttributes
		let name = "dot"
		let opening = "digraph"
		let edge_arrow = "->"
	      end)

(***************************************************************************)
(** {2 Interface with the neato engine} *)

(** The [NeatoAttributes] module defines attributes for graphs, nodes and edges
    that are available in the neato engine. *)
module NeatoAttributes = struct

  (** Attributes of graphs.  They include all common graph attributes and
      several specific ones.  All attributes described in the "Neato User's
      manual, April 10, 2002" are handled. *)
  type graph =
    [ CommonAttributes.graph
    | `Margin of float * float
        (** Sets the page margin (included in the page size).  Default value is
            [0.5, 0.5]. *)
    | `Start of int
        (** Seed for random number generator. *)
    | `Overlap of bool
	(** Default value is [true]. *)
    | `Spline of bool
	(** [true] makes edge splines if nodes don't overlap.
	    Default value is [false]. *)
    | `Sep of float
	(** Edge spline separation factor from nodes.  Default value
	    is [0.0]. *)
    ]

  (** Attributes of nodes.  They include all common node attributes and
      several specific ones.  All attributes described in the "Neato User's
      manual, April 10, 2002" are handled. *)
  type vertex =
    [ CommonAttributes.vertex
    | `Pos of float * float
        (** Initial coordinates of the node. *)
    ]

  (** Attributes of edges.  They include all common edge attributes and
      several specific ones.  All attributes described in the "Neato User's
      manual, April 10, 2002" are handled. *)
  type edge =
    [ CommonAttributes.edge
    | `Id of string
        (** Optional value to distinguish multiple edges. *)
    | `Len of float
        (** Preferred length of edge.  Default value is [1.0]. *)
    | `Weight of float
        (** Strength of edge spring.  Default value is [1.0]. *)
    ]

    type subgraph = {
      sg_name : string;
      sg_attributes : vertex list;
    }

  (** {4 Pretty-print of attributes} *)

    let fprint_graph ppf = function
	#CommonAttributes.graph as att -> CommonAttributes.fprint_graph ppf att
      | `Margin (f1, f2) -> fprintf ppf "margin=\"%f,%f\"" f1 f2
      | `Start i -> fprintf ppf "start=%i" i
      | `Overlap b -> fprintf ppf "overlap=%b" b
      | `Spline b -> fprintf ppf "spline=%b" b
      | `Sep f -> fprintf ppf "sep=%f" f

    let fprint_vertex ppf = function
	#CommonAttributes.vertex as att ->
	  CommonAttributes.fprint_vertex ppf att
      | `Pos (f1, f2) -> fprintf ppf "pos=\"%f,%f\"" f1 f2

    let fprint_edge ppf = function
	#CommonAttributes.edge as att -> CommonAttributes.fprint_edge ppf att
      | `Id s -> fprintf ppf "id=%a" fprint_string s
      | `Len f -> fprintf ppf "len=%f" f
      | `Weight f -> fprintf ppf "weight=%f" f

end

module Neato =
  MakeEngine (struct
		module Attributes = NeatoAttributes
		let name = "neato"
		let opening = "graph"
		let edge_arrow = "--"
	      end)

(*
Local Variables:
compile-command: "make -C .."
End:
*)
end
module Gml: sig
#0 "graph/gml.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: gml.mli,v 1.3 2005-07-06 13:20:31 conchon Exp $ *)

(** Parser and pretty-printer for GML file format. *)

type value = 
  | Int of int 
  | Float of float
  | String of string
  | List of value_list
      
and value_list = (string * value) list

(** {2 Parser} *)

(** Provide a parser for GML file format. *)
module Parse 
  (B : Builder.S)
  (L : sig 
     val node : value_list -> B.G.V.label
       (** How to build the node label out of the set of GML attributes.
	   For example {v node [ id 12 label "foo" ] v}  will call this
	   function with [["id", Int 12; "label", String "foo"]] *) 
     val edge : value_list -> B.G.E.label 
       (** How to build the edge label out of the set of GML attributes *)
   end) :
sig
  val parse : string -> B.G.t
end

(** {2 Pretty-printer} *)

(** Signature for graph required by {!Print}.
    Sub-signature of {!Sig.G}. *)
module type G = sig
  module V : sig
    type t
    val hash : t -> int
    val equal : t -> t -> bool
    type label
    val label : t -> label
  end
  module E : sig
    type t
    type label
    val src : t -> V.t
    val dst : t -> V.t
    val label : t -> label
  end
  type t
  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_edges_e : (E.t -> unit) -> t -> unit
end

(** Provide a pretty-printer for GML file format. *)
module Print
  (G: G)
  (L: sig
     val node : G.V.label -> value_list
     val edge : G.E.label -> value_list
   end) :
sig
  val print : Format.formatter -> G.t -> unit
end


end = struct
#0 "graph/gml.ml"
# 20 "src/gml.mll"
  

  open Lexing

  type value = 
    | Int of int 
    | Float of float
    | String of string
    | List of value_list

  and value_list = (string * value) list


# 16 "src/gml.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\252\255\253\255\114\000\002\000\007\000\228\000\086\001\
    \252\255\253\255\200\001\009\000\014\000\058\002\002\000\251\255\
    \252\255\001\000\080\000\102\000\194\000\216\000\052\001\071\001\
    \253\255\006\000";
  Lexing.lex_backtrk = 
   "\255\255\255\255\255\255\003\000\000\000\001\000\255\255\255\255\
    \255\255\255\255\003\000\000\000\001\000\255\255\255\255\255\255\
    \255\255\004\000\001\000\000\000\004\000\255\255\001\000\255\255\
    \255\255\255\255";
  Lexing.lex_default = 
   "\001\000\000\000\000\000\255\255\255\255\255\255\255\255\008\000\
    \000\000\000\000\255\255\255\255\255\255\255\255\015\000\000\000\
    \000\000\025\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\025\000";
  Lexing.lex_trans = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\004\000\004\000\004\000\004\000\004\000\000\000\004\000\
    \005\000\005\000\011\000\011\000\005\000\000\000\011\000\012\000\
    \012\000\000\000\000\000\012\000\000\000\000\000\000\000\000\000\
    \004\000\000\000\004\000\024\000\017\000\000\000\000\000\005\000\
    \024\000\011\000\000\000\000\000\000\000\020\000\012\000\020\000\
    \018\000\000\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\000\000\000\000\000\000\000\000\
    \000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\000\000\000\000\016\000\000\000\000\000\
    \000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\005\000\005\000\000\000\000\000\005\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\005\000\000\000\018\000\021\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\005\000\005\000\000\000\
    \018\000\005\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\000\000\000\000\000\000\000\000\
    \002\000\255\255\255\255\023\000\005\000\023\000\255\255\000\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\011\000\
    \011\000\000\000\000\000\011\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\011\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\000\000\000\000\009\000\000\000\000\000\000\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\012\000\012\000\000\000\000\000\012\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\012\000\012\000\000\000\000\000\012\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\255\255\000\000\
    \000\000\000\000\012\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000";
  Lexing.lex_check = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\004\000\004\000\000\000\255\255\004\000\
    \005\000\005\000\011\000\011\000\005\000\255\255\011\000\012\000\
    \012\000\255\255\255\255\012\000\255\255\255\255\255\255\255\255\
    \000\000\255\255\004\000\017\000\014\000\255\255\255\255\005\000\
    \025\000\011\000\255\255\255\255\255\255\014\000\012\000\014\000\
    \014\000\255\255\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\255\255\255\255\014\000\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\003\000\003\000\255\255\255\255\003\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\003\000\255\255\019\000\018\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \255\255\255\255\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\006\000\006\000\255\255\
    \020\000\006\000\020\000\020\000\020\000\020\000\020\000\020\000\
    \020\000\020\000\020\000\020\000\255\255\255\255\255\255\255\255\
    \000\000\017\000\014\000\021\000\006\000\021\000\025\000\255\255\
    \021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\
    \021\000\021\000\255\255\255\255\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\007\000\
    \007\000\255\255\255\255\007\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\007\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\255\255\255\255\007\000\255\255\255\255\255\255\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\010\000\010\000\255\255\255\255\010\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \010\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\013\000\013\000\255\255\255\255\013\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\007\000\255\255\
    \255\255\255\255\013\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255";
  Lexing.lex_base_code = 
   "\000\000\000\000\000\000\075\000\000\000\000\000\150\000\208\000\
    \000\000\000\000\027\001\000\000\000\000\102\001\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000";
  Lexing.lex_backtrk_code = 
   "\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000";
  Lexing.lex_default_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000";
  Lexing.lex_trans_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_check_code = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\255\255\255\255\255\255\255\255\255\255\255\255\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\255\255\255\255\255\255\255\255\255\255\255\255\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255";
  Lexing.lex_code = 
   "\255\001\255\255\000\001\255";
}

let rec file lexbuf =
  lexbuf.Lexing.lex_mem <- Array.create 2 (-1) ;   __ocaml_lex_file_rec lexbuf 0
and __ocaml_lex_file_rec lexbuf __ocaml_lex_state =
  match Lexing.new_engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 45 "src/gml.mll"
      ( file lexbuf )
# 425 "src/gml.ml"

  | 1 ->
let
# 46 "src/gml.mll"
              key
# 431 "src/gml.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_mem.(0) in
# 47 "src/gml.mll"
      ( let v = value lexbuf in
	(key, v) :: file lexbuf )
# 436 "src/gml.ml"

  | 2 ->
# 50 "src/gml.mll"
      ( [] )
# 441 "src/gml.ml"

  | 3 ->
let
# 51 "src/gml.mll"
         c
# 447 "src/gml.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 52 "src/gml.mll"
      ( failwith ("Gml: invalid character " ^ String.make 1 c) )
# 451 "src/gml.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_file_rec lexbuf __ocaml_lex_state

and value_list lexbuf =
  lexbuf.Lexing.lex_mem <- Array.create 2 (-1) ;   __ocaml_lex_value_list_rec lexbuf 7
and __ocaml_lex_value_list_rec lexbuf __ocaml_lex_state =
  match Lexing.new_engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 56 "src/gml.mll"
      ( value_list lexbuf )
# 462 "src/gml.ml"

  | 1 ->
let
# 57 "src/gml.mll"
              key
# 468 "src/gml.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_mem.(0) in
# 58 "src/gml.mll"
      ( let v = value lexbuf in
	(key, v) :: value_list lexbuf )
# 473 "src/gml.ml"

  | 2 ->
# 61 "src/gml.mll"
      ( [] )
# 478 "src/gml.ml"

  | 3 ->
let
# 62 "src/gml.mll"
         c
# 484 "src/gml.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 63 "src/gml.mll"
      ( failwith ("Gml: invalid character " ^ String.make 1 c) )
# 488 "src/gml.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_value_list_rec lexbuf __ocaml_lex_state

and value lexbuf =
    __ocaml_lex_value_rec lexbuf 14
and __ocaml_lex_value_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
let
# 66 "src/gml.mll"
               i
# 500 "src/gml.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 67 "src/gml.mll"
      ( Int (int_of_string i) )
# 504 "src/gml.ml"

  | 1 ->
let
# 68 "src/gml.mll"
            r
# 510 "src/gml.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 69 "src/gml.mll"
      ( Float (float_of_string r) )
# 514 "src/gml.ml"

  | 2 ->
let
# 70 "src/gml.mll"
                      s
# 520 "src/gml.ml"
= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 1) (lexbuf.Lexing.lex_curr_pos + -1) in
# 71 "src/gml.mll"
      ( String s )
# 524 "src/gml.ml"

  | 3 ->
# 73 "src/gml.mll"
      ( let l = value_list lexbuf in List l )
# 529 "src/gml.ml"

  | 4 ->
let
# 74 "src/gml.mll"
         c
# 535 "src/gml.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 75 "src/gml.mll"
      ( failwith ("Gml: invalid character " ^ String.make 1 c) )
# 539 "src/gml.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_value_rec lexbuf __ocaml_lex_state

;;

# 77 "src/gml.mll"
 

  let parse f =
    let c = open_in f in
    let lb = from_channel c in
    let v = file lb in
    close_in c;
    v

  module Parse
    (B : Builder.S)
    (L : sig val node : value_list -> B.G.V.label
	     val edge : value_list -> B.G.E.label end) = 
  struct

    let create_graph l =
      let nodes = Hashtbl.create 97 in
      let g = B.empty () in
      (* 1st pass: create the nodes *)
      let g =
	List.fold_left 
	  (fun g v -> match v with
	     | "node", List l ->
		 let n = B.G.V.create (L.node l) in
		 begin 
		   try 
		     let id = List.assoc "id" l in Hashtbl.add nodes id n
		   with Not_found -> 
		     ()
		 end;
		 B.add_vertex g n
	     | _ -> 
		 g)
	  g l
      in
      (* 2nd pass: add the edges *)
      List.fold_left
	(fun g v -> match v with
	   | "edge", List l ->
	       begin try
		 let source = List.assoc "source" l in
		 let target = List.assoc "target" l in
		 let nsource = Hashtbl.find nodes source in
		 let ntarget = Hashtbl.find nodes target in
		 let e = B.G.E.create nsource (L.edge l) ntarget in
		 B.add_edge_e g e
	       with Not_found ->
		 g
	       end
	   | _ ->
	       g)
	g l
	
    let parse f =
      match parse f with
	| ["graph", List l] -> create_graph l
	| _ -> invalid_arg "Gml.Parse.parse: not a graph file"
      
  end

  module type G = sig
    module V : sig
      type t
      val hash : t -> int
      val equal : t -> t -> bool
      type label
      val label : t -> label
    end
    module E : sig
      type t
      type label
      val src : t -> V.t
      val dst : t -> V.t
      val label : t -> label
    end
    type t
    val iter_vertex : (V.t -> unit) -> t -> unit
    val iter_edges_e : (E.t -> unit) -> t -> unit
  end

  module Print
    (G : G)
    (L : sig
       val node : G.V.label -> value_list
       val edge : G.E.label -> value_list
     end) =
  struct

    open Format

    module H = Hashtbl.Make(G.V)

    let print fmt g =
      let nodes = H.create 97 in
      let cpt = ref 0 in
      let id n = 
	try H.find nodes n
	with Not_found -> incr cpt; let id = !cpt in H.add nodes n id; id
      in
      fprintf fmt "@[graph [@\n";
      let rec value fmt = function
	| Int n -> fprintf fmt "%d" n
	| Float f -> fprintf fmt "%f" f
	| String s -> fprintf fmt "\"%s\"" s
	| List l -> fprintf fmt "[@\n  @[%a@]@\n]" value_list l
      and value_list fmt = function
	| [] -> ()
	| [s,v] -> fprintf fmt "%s %a" s value v
	| (s,v) :: l -> fprintf fmt "%s %a@\n" s value v; value_list fmt l
      in
      G.iter_vertex
	(fun v -> 
	   fprintf fmt "  @[node [@\n  id %d@\n  @[%a@]@\n]@]@\n" 
	     (id v) value_list (L.node (G.V.label v)))
	g;
      G.iter_edges_e
	(fun e ->
	   fprintf fmt 
	     "  @[edge [@\n  source %d@\n  target %d@\n  @[%a@]@\n]@]@\n"
	     (id (G.E.src e)) (id (G.E.dst e)) 
	     value_list (L.edge (G.E.label e)))
	g;
      fprintf fmt "]@\n"

  end


# 673 "src/gml.ml"
end
module Dot_parser: sig
#0 "graph/dot_parser.mli"
type token =
  | ID of (Dot_ast.id)
  | COLON
  | COMMA
  | EQUAL
  | SEMICOLON
  | EDGEOP
  | STRICT
  | GRAPH
  | DIGRAPH
  | LBRA
  | RBRA
  | LSQ
  | RSQ
  | NODE
  | EDGE
  | SUBGRAPH
  | EOF

val file :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Dot_ast.file
end = struct
#0 "graph/dot_parser.ml"
type token =
  | ID of (Dot_ast.id)
  | COLON
  | COMMA
  | EQUAL
  | SEMICOLON
  | EDGEOP
  | STRICT
  | GRAPH
  | DIGRAPH
  | LBRA
  | RBRA
  | LSQ
  | RSQ
  | NODE
  | EDGE
  | SUBGRAPH
  | EOF

open Parsing;;
# 23 "src/dot_parser.mly"
  open Dot_ast
  open Parsing

  let compass_pt = function
    | Ident "n" -> N
    | Ident "ne" -> Ne
    | Ident "e" -> E
    | Ident "se" -> Se
    | Ident "s" -> S
    | Ident "sw" -> Sw
    | Ident "w" -> W
    | Ident "nw" -> Nw
    | _ -> invalid_arg "compass_pt"

# 37 "src/dot_parser.ml"
let yytransl_const = [|
  258 (* COLON *);
  259 (* COMMA *);
  260 (* EQUAL *);
  261 (* SEMICOLON *);
  262 (* EDGEOP *);
  263 (* STRICT *);
  264 (* GRAPH *);
  265 (* DIGRAPH *);
  266 (* LBRA *);
  267 (* RBRA *);
  268 (* LSQ *);
  269 (* RSQ *);
  270 (* NODE *);
  271 (* EDGE *);
  272 (* SUBGRAPH *);
    0 (* EOF *);
    0|]

let yytransl_block = [|
  257 (* ID *);
    0|]

let yylhs = "\255\255\
\001\000\002\000\002\000\003\000\003\000\005\000\005\000\006\000\
\006\000\008\000\008\000\007\000\007\000\007\000\007\000\007\000\
\009\000\010\000\011\000\011\000\011\000\016\000\018\000\018\000\
\015\000\015\000\013\000\019\000\019\000\020\000\020\000\014\000\
\014\000\017\000\017\000\004\000\004\000\021\000\021\000\022\000\
\022\000\023\000\023\000\012\000\012\000\012\000\012\000\000\000"

let yylen = "\002\000\
\007\000\000\000\001\000\001\000\001\000\000\000\001\000\002\000\
\003\000\000\000\001\000\001\000\001\000\001\000\003\000\001\000\
\002\000\003\000\002\000\002\000\002\000\003\000\000\000\003\000\
\001\000\001\000\002\000\000\000\001\000\002\000\004\000\000\000\
\001\000\003\000\004\000\000\000\001\000\002\000\003\000\001\000\
\003\000\000\000\001\000\002\000\005\000\004\000\003\000\002\000"

let yydefred = "\000\000\
\000\000\000\000\003\000\048\000\000\000\004\000\005\000\000\000\
\037\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\007\000\000\000\012\000\013\000\014\000\000\000\
\000\000\000\000\000\000\000\000\027\000\029\000\000\000\019\000\
\000\000\020\000\021\000\000\000\000\000\000\000\011\000\000\000\
\017\000\033\000\000\000\000\000\000\000\015\000\000\000\000\000\
\000\000\047\000\000\000\000\000\001\000\009\000\000\000\026\000\
\025\000\000\000\018\000\000\000\000\000\000\000\043\000\000\000\
\000\000\046\000\000\000\022\000\031\000\041\000\035\000\039\000\
\045\000\000\000\024\000"

let yydgoto = "\002\000\
\004\000\005\000\008\000\010\000\018\000\019\000\020\000\040\000\
\021\000\022\000\023\000\024\000\025\000\041\000\026\000\044\000\
\042\000\068\000\029\000\030\000\048\000\049\000\064\000"

let yysindex = "\009\000\
\024\255\000\000\000\000\000\000\000\255\000\000\000\000\031\255\
\000\000\029\255\131\255\011\255\033\255\131\255\033\255\033\255\
\051\255\040\255\000\000\048\255\000\000\000\000\000\000\000\000\
\033\255\050\255\057\255\067\255\000\000\000\000\069\255\000\000\
\062\255\000\000\000\000\070\255\131\255\091\000\000\000\131\255\
\000\000\000\000\018\255\033\255\090\255\000\000\099\255\081\255\
\101\255\000\000\131\255\095\255\000\000\000\000\107\255\000\000\
\000\000\110\255\000\000\114\255\117\255\033\255\000\000\069\255\
\111\255\000\000\018\255\000\000\000\000\000\000\000\000\000\000\
\000\000\110\255\000\000"

let yyrindex = "\000\000\
\074\255\000\000\000\000\000\000\000\000\000\000\000\000\116\255\
\000\000\000\000\118\255\006\255\000\000\118\255\000\000\000\000\
\000\000\000\000\000\000\120\255\000\000\000\000\000\000\049\255\
\061\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\073\255\118\255\000\000\000\000\122\255\
\000\000\000\000\000\000\097\255\032\255\000\000\023\255\000\000\
\022\255\000\000\118\255\000\000\000\000\000\000\006\255\000\000\
\000\000\085\255\000\000\000\000\000\000\109\255\000\000\124\255\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\085\255\000\000"

let yygindex = "\000\000\
\000\000\000\000\000\000\000\000\246\255\087\000\000\000\000\000\
\000\000\000\000\000\000\214\255\218\255\094\000\219\255\000\000\
\243\255\066\000\000\000\000\000\078\000\000\000\000\000"

let yytablesize = 147
let yytable = "\032\000\
\056\000\034\000\035\000\033\000\057\000\058\000\028\000\006\000\
\007\000\001\000\028\000\028\000\027\000\028\000\028\000\028\000\
\028\000\028\000\055\000\028\000\028\000\028\000\042\000\040\000\
\056\000\040\000\052\000\014\000\057\000\074\000\003\000\009\000\
\030\000\017\000\042\000\040\000\030\000\030\000\011\000\030\000\
\065\000\030\000\030\000\030\000\031\000\030\000\030\000\030\000\
\071\000\016\000\038\000\036\000\039\000\016\000\026\000\043\000\
\016\000\045\000\016\000\016\000\037\000\032\000\016\000\016\000\
\016\000\032\000\025\000\046\000\032\000\047\000\032\000\032\000\
\050\000\044\000\032\000\032\000\032\000\044\000\044\000\051\000\
\044\000\002\000\002\000\044\000\044\000\023\000\044\000\044\000\
\044\000\023\000\053\000\060\000\023\000\062\000\023\000\023\000\
\023\000\032\000\023\000\023\000\023\000\032\000\061\000\063\000\
\032\000\066\000\032\000\032\000\027\000\034\000\032\000\032\000\
\032\000\034\000\069\000\067\000\034\000\070\000\034\000\034\000\
\010\000\073\000\034\000\034\000\034\000\036\000\054\000\010\000\
\006\000\010\000\010\000\012\000\008\000\010\000\010\000\010\000\
\038\000\059\000\013\000\075\000\014\000\072\000\000\000\000\000\
\015\000\016\000\017\000"

let yycheck = "\013\000\
\043\000\015\000\016\000\014\000\043\000\043\000\001\001\008\001\
\009\001\001\000\005\001\006\001\002\001\008\001\004\001\010\001\
\011\001\012\001\001\001\014\001\015\001\016\001\001\001\001\001\
\067\000\003\001\037\000\010\001\067\000\067\000\007\001\001\001\
\001\001\016\001\013\001\013\001\005\001\006\001\010\001\008\001\
\051\000\010\001\011\001\012\001\012\001\014\001\015\001\016\001\
\062\000\001\001\011\001\001\001\005\001\005\001\006\001\006\001\
\008\001\001\001\010\001\011\001\010\001\001\001\014\001\015\001\
\016\001\005\001\006\001\001\001\008\001\001\001\010\001\011\001\
\011\001\001\001\014\001\015\001\016\001\005\001\006\001\010\001\
\008\001\008\001\009\001\011\001\012\001\001\001\014\001\015\001\
\016\001\005\001\000\000\002\001\008\001\013\001\010\001\011\001\
\012\001\001\001\014\001\015\001\016\001\005\001\004\001\003\001\
\008\001\011\001\010\001\011\001\002\001\001\001\014\001\015\001\
\016\001\005\001\001\001\006\001\008\001\001\001\010\001\011\001\
\001\001\011\001\014\001\015\001\016\001\010\001\040\000\008\001\
\011\001\010\001\011\001\001\001\011\001\014\001\015\001\016\001\
\013\001\044\000\008\001\074\000\010\001\064\000\255\255\255\255\
\014\001\015\001\016\001"

let yynames_const = "\
  COLON\000\
  COMMA\000\
  EQUAL\000\
  SEMICOLON\000\
  EDGEOP\000\
  STRICT\000\
  GRAPH\000\
  DIGRAPH\000\
  LBRA\000\
  RBRA\000\
  LSQ\000\
  RSQ\000\
  NODE\000\
  EDGE\000\
  SUBGRAPH\000\
  EOF\000\
  "

let yynames_block = "\
  ID\000\
  "

let yyact = [|
  (fun _ -> failwith "parser")
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'strict_opt) in
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'graph_or_digraph) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'id_opt) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'stmt_list) in
    Obj.repr(
# 49 "src/dot_parser.mly"
    ( { strict = _1; digraph = _2; id = _3; stmts = _5 } )
# 199 "src/dot_parser.ml"
               : Dot_ast.file))
; (fun __caml_parser_env ->
    Obj.repr(
# 53 "src/dot_parser.mly"
                ( false )
# 205 "src/dot_parser.ml"
               : 'strict_opt))
; (fun __caml_parser_env ->
    Obj.repr(
# 54 "src/dot_parser.mly"
                ( true )
# 211 "src/dot_parser.ml"
               : 'strict_opt))
; (fun __caml_parser_env ->
    Obj.repr(
# 58 "src/dot_parser.mly"
          ( false )
# 217 "src/dot_parser.ml"
               : 'graph_or_digraph))
; (fun __caml_parser_env ->
    Obj.repr(
# 59 "src/dot_parser.mly"
          ( true )
# 223 "src/dot_parser.ml"
               : 'graph_or_digraph))
; (fun __caml_parser_env ->
    Obj.repr(
# 63 "src/dot_parser.mly"
                ( [] )
# 229 "src/dot_parser.ml"
               : 'stmt_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'list1_stmt) in
    Obj.repr(
# 64 "src/dot_parser.mly"
                ( _1 )
# 236 "src/dot_parser.ml"
               : 'stmt_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'stmt) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'semicolon_opt) in
    Obj.repr(
# 68 "src/dot_parser.mly"
                     ( [_1] )
# 244 "src/dot_parser.ml"
               : 'list1_stmt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'stmt) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'semicolon_opt) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'list1_stmt) in
    Obj.repr(
# 69 "src/dot_parser.mly"
                                ( _1 :: _3 )
# 253 "src/dot_parser.ml"
               : 'list1_stmt))
; (fun __caml_parser_env ->
    Obj.repr(
# 73 "src/dot_parser.mly"
                ( () )
# 259 "src/dot_parser.ml"
               : 'semicolon_opt))
; (fun __caml_parser_env ->
    Obj.repr(
# 74 "src/dot_parser.mly"
                ( () )
# 265 "src/dot_parser.ml"
               : 'semicolon_opt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'node_stmt) in
    Obj.repr(
# 78 "src/dot_parser.mly"
            ( _1 )
# 272 "src/dot_parser.ml"
               : 'stmt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'edge_stmt) in
    Obj.repr(
# 79 "src/dot_parser.mly"
            ( _1 )
# 279 "src/dot_parser.ml"
               : 'stmt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'attr_stmt) in
    Obj.repr(
# 80 "src/dot_parser.mly"
            ( _1 )
# 286 "src/dot_parser.ml"
               : 'stmt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Dot_ast.id) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Dot_ast.id) in
    Obj.repr(
# 81 "src/dot_parser.mly"
              ( Equal (_1, _3) )
# 294 "src/dot_parser.ml"
               : 'stmt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'subgraph) in
    Obj.repr(
# 82 "src/dot_parser.mly"
            ( Subgraph _1 )
# 301 "src/dot_parser.ml"
               : 'stmt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'node_id) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attr_list_opt) in
    Obj.repr(
# 86 "src/dot_parser.mly"
                        ( Node_stmt (_1, _2) )
# 309 "src/dot_parser.ml"
               : 'node_stmt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'node) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'edge_rhs) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attr_list_opt) in
    Obj.repr(
# 90 "src/dot_parser.mly"
                              ( Edge_stmt (_1, _2, _3) )
# 318 "src/dot_parser.ml"
               : 'edge_stmt))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attr_list) in
    Obj.repr(
# 94 "src/dot_parser.mly"
                  ( Attr_graph _2 )
# 325 "src/dot_parser.ml"
               : 'attr_stmt))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attr_list) in
    Obj.repr(
# 95 "src/dot_parser.mly"
                  ( Attr_node _2 )
# 332 "src/dot_parser.ml"
               : 'attr_stmt))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attr_list) in
    Obj.repr(
# 96 "src/dot_parser.mly"
                  ( Attr_edge _2 )
# 339 "src/dot_parser.ml"
               : 'attr_stmt))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'node) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'edge_rhs_opt) in
    Obj.repr(
# 100 "src/dot_parser.mly"
                           ( _2 :: _3 )
# 347 "src/dot_parser.ml"
               : 'edge_rhs))
; (fun __caml_parser_env ->
    Obj.repr(
# 104 "src/dot_parser.mly"
                ( [] )
# 353 "src/dot_parser.ml"
               : 'edge_rhs_opt))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'node) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'edge_rhs_opt) in
    Obj.repr(
# 105 "src/dot_parser.mly"
                           ( _2 :: _3 )
# 361 "src/dot_parser.ml"
               : 'edge_rhs_opt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'node_id) in
    Obj.repr(
# 109 "src/dot_parser.mly"
           ( NodeId _1 )
# 368 "src/dot_parser.ml"
               : 'node))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'subgraph) in
    Obj.repr(
# 110 "src/dot_parser.mly"
           ( NodeSub _1 )
# 375 "src/dot_parser.ml"
               : 'node))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : Dot_ast.id) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'port_opt) in
    Obj.repr(
# 114 "src/dot_parser.mly"
              ( _1, _2 )
# 383 "src/dot_parser.ml"
               : 'node_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 118 "src/dot_parser.mly"
                ( None )
# 389 "src/dot_parser.ml"
               : 'port_opt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'port) in
    Obj.repr(
# 119 "src/dot_parser.mly"
                ( Some _1 )
# 396 "src/dot_parser.ml"
               : 'port_opt))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : Dot_ast.id) in
    Obj.repr(
# 123 "src/dot_parser.mly"
           ( try PortC (compass_pt _2)
             with Invalid_argument _ -> PortId (_2, None) )
# 404 "src/dot_parser.ml"
               : 'port))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : Dot_ast.id) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : Dot_ast.id) in
    Obj.repr(
# 126 "src/dot_parser.mly"
      ( let cp = 
  	  try compass_pt _4 with Invalid_argument _ -> raise Parse_error 
	in
	PortId (_2, Some cp) )
# 415 "src/dot_parser.ml"
               : 'port))
; (fun __caml_parser_env ->
    Obj.repr(
# 133 "src/dot_parser.mly"
                ( [] )
# 421 "src/dot_parser.ml"
               : 'attr_list_opt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'attr_list) in
    Obj.repr(
# 134 "src/dot_parser.mly"
               ( _1 )
# 428 "src/dot_parser.ml"
               : 'attr_list_opt))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'a_list) in
    Obj.repr(
# 138 "src/dot_parser.mly"
                 ( [_2] )
# 435 "src/dot_parser.ml"
               : 'attr_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'a_list) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'attr_list) in
    Obj.repr(
# 139 "src/dot_parser.mly"
                           ( _2 :: _4 )
# 443 "src/dot_parser.ml"
               : 'attr_list))
; (fun __caml_parser_env ->
    Obj.repr(
# 143 "src/dot_parser.mly"
                ( None )
# 449 "src/dot_parser.ml"
               : 'id_opt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Dot_ast.id) in
    Obj.repr(
# 144 "src/dot_parser.mly"
                ( Some _1 )
# 456 "src/dot_parser.ml"
               : 'id_opt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'equality) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'comma_opt) in
    Obj.repr(
# 148 "src/dot_parser.mly"
                     ( [_1] )
# 464 "src/dot_parser.ml"
               : 'a_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'equality) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'comma_opt) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'a_list) in
    Obj.repr(
# 149 "src/dot_parser.mly"
                            ( _1 :: _3 )
# 473 "src/dot_parser.ml"
               : 'a_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Dot_ast.id) in
    Obj.repr(
# 153 "src/dot_parser.mly"
     ( _1, None )
# 480 "src/dot_parser.ml"
               : 'equality))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Dot_ast.id) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Dot_ast.id) in
    Obj.repr(
# 154 "src/dot_parser.mly"
              ( _1, Some _3 )
# 488 "src/dot_parser.ml"
               : 'equality))
; (fun __caml_parser_env ->
    Obj.repr(
# 158 "src/dot_parser.mly"
                ( () )
# 494 "src/dot_parser.ml"
               : 'comma_opt))
; (fun __caml_parser_env ->
    Obj.repr(
# 159 "src/dot_parser.mly"
                ( () )
# 500 "src/dot_parser.ml"
               : 'comma_opt))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : Dot_ast.id) in
    Obj.repr(
# 164 "src/dot_parser.mly"
              ( SubgraphId _2 )
# 507 "src/dot_parser.ml"
               : 'subgraph))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : Dot_ast.id) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'stmt_list) in
    Obj.repr(
# 165 "src/dot_parser.mly"
                                  ( SubgraphDef (Some _2, _4) )
# 515 "src/dot_parser.ml"
               : 'subgraph))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'stmt_list) in
    Obj.repr(
# 166 "src/dot_parser.mly"
                               ( SubgraphDef (None, _3) )
# 522 "src/dot_parser.ml"
               : 'subgraph))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'stmt_list) in
    Obj.repr(
# 167 "src/dot_parser.mly"
                      ( SubgraphDef (None, _2) )
# 529 "src/dot_parser.ml"
               : 'subgraph))
(* Entry file *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
|]
let yytables =
  { Parsing.actions=yyact;
    Parsing.transl_const=yytransl_const;
    Parsing.transl_block=yytransl_block;
    Parsing.lhs=yylhs;
    Parsing.len=yylen;
    Parsing.defred=yydefred;
    Parsing.dgoto=yydgoto;
    Parsing.sindex=yysindex;
    Parsing.rindex=yyrindex;
    Parsing.gindex=yygindex;
    Parsing.tablesize=yytablesize;
    Parsing.table=yytable;
    Parsing.check=yycheck;
    Parsing.error_function=parse_error;
    Parsing.names_const=yynames_const;
    Parsing.names_block=yynames_block }
let file (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 1 lexfun lexbuf : Dot_ast.file)
end
module Dot_lexer = struct
#0 "graph/dot_lexer.ml"
# 20 "src/dot_lexer.mll"
 
  open Lexing
  open Dot_ast
  open Dot_parser

  let string_buf = Buffer.create 1024

  let keyword =
    let h = Hashtbl.create 17 in
    List.iter 
      (fun (s,k) -> Hashtbl.add h s k)
      [
	"strict", STRICT;
	"graph", GRAPH;
	"digraph", DIGRAPH;
	"subgraph", SUBGRAPH;
	"node", NODE;
	"edge", EDGE;
      ];
    fun s -> let s = String.lowercase s in Hashtbl.find h s


# 25 "src/dot_lexer.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\238\255\239\255\240\255\241\255\078\000\088\000\098\000\
    \176\000\245\255\246\255\247\255\248\255\249\255\250\255\251\255\
    \252\255\114\000\001\000\005\000\254\255\002\000\253\255\191\000\
    \244\255\211\000\221\000\157\000\252\255\253\255\002\000\255\255\
    \254\255\032\000\252\255\253\255\254\255\255\255\054\000\253\255\
    \254\255\015\000\255\255";
  Lexing.lex_backtrk = 
   "\255\255\255\255\255\255\255\255\255\255\013\000\017\000\012\000\
    \017\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\017\000\017\000\000\000\255\255\255\255\255\255\255\255\
    \255\255\013\000\013\000\255\255\255\255\255\255\002\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\001\000\255\255";
  Lexing.lex_default = 
   "\001\000\000\000\000\000\000\000\000\000\255\255\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\255\255\021\000\255\255\000\000\021\000\000\000\255\255\
    \000\000\255\255\255\255\029\000\000\000\000\000\255\255\000\000\
    \000\000\035\000\000\000\000\000\000\000\000\000\040\000\000\000\
    \000\000\255\255\000\000";
  Lexing.lex_trans = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\019\000\019\000\020\000\020\000\019\000\019\000\019\000\
    \000\000\000\000\019\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \019\000\000\000\004\000\018\000\032\000\019\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\015\000\008\000\006\000\017\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\016\000\014\000\003\000\013\000\042\000\000\000\
    \000\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\010\000\036\000\009\000\037\000\007\000\
    \041\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\012\000\026\000\011\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\
    \025\000\025\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\022\000\000\000\000\000\000\000\
    \000\000\021\000\000\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\000\000\000\000\031\000\
    \000\000\007\000\000\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\024\000\023\000\000\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\000\000\000\000\000\000\000\000\024\000\025\000\
    \025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\
    \025\000\030\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \002\000\255\255\255\255\025\000\025\000\025\000\025\000\025\000\
    \025\000\025\000\025\000\025\000\025\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \034\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\039\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\028\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_check = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\018\000\021\000\000\000\019\000\019\000\
    \255\255\255\255\019\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\000\000\000\000\030\000\019\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\041\000\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\033\000\000\000\033\000\000\000\
    \038\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\005\000\000\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\017\000\255\255\255\255\255\255\
    \255\255\017\000\255\255\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\255\255\255\255\027\000\
    \255\255\007\000\255\255\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\008\000\008\000\255\255\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\255\255\255\255\255\255\255\255\008\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\027\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\018\000\021\000\025\000\025\000\025\000\025\000\025\000\
    \025\000\025\000\025\000\025\000\025\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \033\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\038\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\027\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255";
  Lexing.lex_base_code = 
   "";
  Lexing.lex_backtrk_code = 
   "";
  Lexing.lex_default_code = 
   "";
  Lexing.lex_trans_code = 
   "";
  Lexing.lex_check_code = 
   "";
  Lexing.lex_code = 
   "";
}

let rec token lexbuf =
    __ocaml_lex_token_rec lexbuf 0
and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 52 "src/dot_lexer.mll"
      ( token lexbuf )
# 191 "src/dot_lexer.ml"

  | 1 ->
# 54 "src/dot_lexer.mll"
      ( token lexbuf )
# 196 "src/dot_lexer.ml"

  | 2 ->
# 56 "src/dot_lexer.mll"
      ( comment lexbuf; token lexbuf )
# 201 "src/dot_lexer.ml"

  | 3 ->
# 58 "src/dot_lexer.mll"
      ( COLON )
# 206 "src/dot_lexer.ml"

  | 4 ->
# 60 "src/dot_lexer.mll"
      ( COMMA )
# 211 "src/dot_lexer.ml"

  | 5 ->
# 62 "src/dot_lexer.mll"
      ( SEMICOLON )
# 216 "src/dot_lexer.ml"

  | 6 ->
# 64 "src/dot_lexer.mll"
      ( EQUAL )
# 221 "src/dot_lexer.ml"

  | 7 ->
# 66 "src/dot_lexer.mll"
      ( LBRA )
# 226 "src/dot_lexer.ml"

  | 8 ->
# 68 "src/dot_lexer.mll"
      ( RBRA )
# 231 "src/dot_lexer.ml"

  | 9 ->
# 70 "src/dot_lexer.mll"
      ( LSQ )
# 236 "src/dot_lexer.ml"

  | 10 ->
# 72 "src/dot_lexer.mll"
      ( RSQ )
# 241 "src/dot_lexer.ml"

  | 11 ->
# 74 "src/dot_lexer.mll"
      ( EDGEOP )
# 246 "src/dot_lexer.ml"

  | 12 ->
let
# 75 "src/dot_lexer.mll"
             s
# 252 "src/dot_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 76 "src/dot_lexer.mll"
      ( try keyword s with Not_found -> ID (Ident s) )
# 256 "src/dot_lexer.ml"

  | 13 ->
let
# 77 "src/dot_lexer.mll"
              s
# 262 "src/dot_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 78 "src/dot_lexer.mll"
      ( ID (Number s) )
# 266 "src/dot_lexer.ml"

  | 14 ->
# 80 "src/dot_lexer.mll"
      ( Buffer.clear string_buf; 
	let s = string lexbuf in
	ID (String s) )
# 273 "src/dot_lexer.ml"

  | 15 ->
# 84 "src/dot_lexer.mll"
      ( Buffer.clear string_buf; 
	html lexbuf; 
	ID (Html (Buffer.contents string_buf)) )
# 280 "src/dot_lexer.ml"

  | 16 ->
# 88 "src/dot_lexer.mll"
      ( EOF )
# 285 "src/dot_lexer.ml"

  | 17 ->
let
# 89 "src/dot_lexer.mll"
         c
# 291 "src/dot_lexer.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 90 "src/dot_lexer.mll"
      ( failwith ("Dot_lexer: invalid character " ^ String.make 1 c) )
# 295 "src/dot_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_token_rec lexbuf __ocaml_lex_state

and string lexbuf =
    __ocaml_lex_string_rec lexbuf 27
and __ocaml_lex_string_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 94 "src/dot_lexer.mll"
      ( Buffer.contents string_buf )
# 306 "src/dot_lexer.ml"

  | 1 ->
# 96 "src/dot_lexer.mll"
      ( Buffer.add_char string_buf '"';
	string lexbuf )
# 312 "src/dot_lexer.ml"

  | 2 ->
let
# 98 "src/dot_lexer.mll"
         c
# 318 "src/dot_lexer.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 99 "src/dot_lexer.mll"
      ( Buffer.add_char string_buf c;
	string lexbuf )
# 323 "src/dot_lexer.ml"

  | 3 ->
# 102 "src/dot_lexer.mll"
      ( failwith ("Dot_lexer: unterminated string literal") )
# 328 "src/dot_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_string_rec lexbuf __ocaml_lex_state

and html lexbuf =
    __ocaml_lex_html_rec lexbuf 33
and __ocaml_lex_html_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 106 "src/dot_lexer.mll"
      ( () )
# 339 "src/dot_lexer.ml"

  | 1 ->
# 108 "src/dot_lexer.mll"
      ( Buffer.add_char string_buf '<'; html lexbuf;
	Buffer.add_char string_buf '>'; html lexbuf )
# 345 "src/dot_lexer.ml"

  | 2 ->
let
# 110 "src/dot_lexer.mll"
         c
# 351 "src/dot_lexer.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 111 "src/dot_lexer.mll"
      ( Buffer.add_char string_buf c;
	html lexbuf )
# 356 "src/dot_lexer.ml"

  | 3 ->
# 114 "src/dot_lexer.mll"
      ( failwith ("Dot_lexer: unterminated html literal") )
# 361 "src/dot_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_html_rec lexbuf __ocaml_lex_state

and comment lexbuf =
    __ocaml_lex_comment_rec lexbuf 38
and __ocaml_lex_comment_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 118 "src/dot_lexer.mll"
      ( () )
# 372 "src/dot_lexer.ml"

  | 1 ->
# 120 "src/dot_lexer.mll"
      ( comment lexbuf )
# 377 "src/dot_lexer.ml"

  | 2 ->
# 122 "src/dot_lexer.mll"
      ( failwith "Dot_lexer: unterminated comment" )
# 382 "src/dot_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_comment_rec lexbuf __ocaml_lex_state

;;

end
module Dot: sig
#0 "graph/dot.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(** Parser for DOT file format. *)

open Dot_ast

val parse_dot_ast : string -> Dot_ast.file

type clusters_hash = (string, attr list) Hashtbl.t

(** Provide a parser for DOT file format. *)
module Parse 
  (B : Builder.S)
  (L : sig 
     val node : node_id -> attr list -> B.G.V.label
       (** How to build the node label out of the set of attributes *)
     val edge : attr list -> B.G.E.label 
       (** How to build the edge label out of the set of attributes *)
   end) :
sig

  (** Parses a dot file *)
  val parse : string -> B.G.t

  (** Parses a dot file and returns the graph, its bounding box and 
      a hash table from clusters to dot attributes *)
  val parse_bounding_box_and_clusters :
    string -> B.G.t * string * clusters_hash

end
end = struct
#0 "graph/dot.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(** Parser for DOT file format *)

open Dot_ast

let parse_dot_ast_from_chan c =
  let lb = Lexing.from_channel c in
  let dot =
    try
      Dot_parser.file Dot_lexer.token lb
    with Parsing.Parse_error ->
      let n = Lexing.lexeme_start lb in
      failwith (Printf.sprintf "Dot.parse: parse error character %d" n)
  in
  close_in c;
  dot

let parse_dot_ast f =
  let c = open_in f in
  parse_dot_ast_from_chan c

type clusters_hash = (string, attr list) Hashtbl.t

let get_string = function
  | String s -> s
  | Ident s -> s
  | Number s -> s
  | Html s -> s

module Parse
  (B : Builder.S)
  (L : sig
     val node : node_id -> attr list -> B.G.V.label
       (** how to build the node label out of the set of attributes *)
     val edge : attr list -> B.G.E.label
       (** how to build the edge label out of the set of attributes *)
   end) =
struct

  module Attr = struct
    module M = 
      Map.Make
        (struct
           type t = id
           let compare : t -> t -> int = Pervasives.compare
         end)
    type t = id option M.t
    let empty = M.empty
    let add = List.fold_left (fun a (x,v) -> M.add x v a)
    let addl = List.fold_left add
    let list a = M.fold (fun x v l -> (x,v) :: l) a []
  end

    let create_graph_and_clusters dot =
    (* pass 1*)

    (* collect node attributes *)
    let def_node_attr = ref Attr.empty in
    let node_attr = Hashtbl.create 97 in

    (* collect cluster attributes *)
    let def_clust_attr = ref Attr.empty in
    let clust_attr = Hashtbl.create 97 in

    (* collect clusters nodes *)
    let clust_nodes = Hashtbl.create 97 in

    let add_node_attr id al =
      let l = try Hashtbl.find node_attr id
              with Not_found -> !def_node_attr in
      Hashtbl.replace node_attr id (Attr.addl l al) in

    let add_clust_attr id_opt al =
      match id_opt with
	| Some id ->
	    let s = get_string id in
	    let l = try Hashtbl.find clust_attr s
                    with Not_found -> !def_clust_attr in
	    Hashtbl.replace clust_attr s (Attr.addl l al)
	| _ -> () in

    let add_clust_node id_cluster id_node =
      let id_nodes = try Hashtbl.find clust_nodes id_cluster
      with Not_found -> [] in
      Hashtbl.add clust_nodes id_cluster (id_node :: id_nodes) in

    let rec collect_node_attr cluster_op stmts =
      List.iter (
        function
          | Node_stmt (id, al) ->
	      add_node_attr id al;
	      begin match cluster_op with
		| Some id_cluster -> add_clust_node id_cluster id
		| _ -> ()
	      end
          | Attr_node al -> def_node_attr := Attr.addl !def_node_attr al
          | Edge_stmt (NodeId id, nl, _) ->
              add_node_attr id [];
              List.iter (function | NodeId id -> add_node_attr id []
			          | _ -> ()) nl
          | Subgraph (SubgraphDef (id, stmts)) ->
	      collect_node_attr (Some id) stmts
	  | Attr_graph al ->
	      begin match cluster_op with
		| Some id -> add_clust_attr id al
		| None -> ()
	      end
          | _ -> ()
      ) stmts
    in
    collect_node_attr None dot.stmts;

    (* pass 2: build the graph and the clusters *)
    let def_edge_attr = ref Attr.empty in
    let nodes = Hashtbl.create 97 in
    let node g id l =
      try
	g, Hashtbl.find nodes id
      with Not_found ->
	let l = try Hashtbl.find node_attr id with Not_found -> Attr.empty in
	let n = B.G.V.create (L.node id [Attr.list l]) in
	Hashtbl.add nodes id n;
	B.add_vertex g n, n
    in
    let rec add_stmts g stmts =
      List.fold_left
        (fun g s -> match s with
           | Node_stmt (id, al) ->
               let g,_ = node g id al in g
           | Edge_stmt (NodeId id, nl, al) ->
               let al = Attr.addl !def_edge_attr al in
               let el = L.edge [Attr.list al] in
               let g,vn = node g id [] in
                 List.fold_left
                   (fun g m -> match m with
                      | NodeId idm ->
                          let g,vm = node g idm [] in
                          let e = B.G.E.create vn el vm in
                            B.add_edge_e g e
                      | NodeSub _ ->
                          g)
                   g nl
           | Attr_edge al ->
               def_edge_attr := Attr.addl !def_edge_attr al; g
           | Subgraph (SubgraphDef (_, stmts)) ->
               add_stmts g stmts
           | _ -> g
        )
        g stmts in

    let graph = add_stmts (B.empty ()) dot.stmts in

    let clusters_hash =
      let h = Hashtbl.create 30 in
      Hashtbl.iter (fun k a -> Hashtbl.add h k [Attr.list a]) clust_attr;
      h in

    graph, clusters_hash

  let get_graph_bb stmts =
    let graph_bb = ref None in
    let read_attr = function
      | (Ident "bb" , Some (String bb)) -> graph_bb := Some bb
      | _ -> () in
    let read_stmt = function
      | Attr_graph attrs -> List.iter (List.iter read_attr) attrs
      | _ -> () in
    List.iter read_stmt stmts;
    !graph_bb

  let parse_dot_from_chan c =
    let lb = Lexing.from_channel c in
    let dot =
      try
	Dot_parser.file Dot_lexer.token lb
      with Parsing.Parse_error ->
	let n = Lexing.lexeme_start lb in
	failwith (Printf.sprintf "Dot.parse: parse error character %d" n)
    in
    close_in c;
    dot

  let parse_dot f =
    let c = open_in f in
    parse_dot_from_chan c

  let parse f =
    fst (create_graph_and_clusters (parse_dot f))

  let parse_with_bb_from_chan c =
    let dot = parse_dot_from_chan c in
    create_graph_and_clusters dot, get_graph_bb dot.stmts

  let parse_bounding_box_and_clusters f =
    let dot = parse_dot f in
    let graph, clusters = create_graph_and_clusters dot in
    match get_graph_bb dot.stmts with
      | Some bounding_box ->
	  graph, bounding_box, clusters
      | None ->
	  failwith "Cannot read bounding box in xdot file"

end
end
module Pack: sig
#0 "graph/pack.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: pack.mli,v 1.1 2004-02-04 11:52:02 filliatr Exp $ *)

(** {b Immediate access to the library}: provides implementation of imperative
    graphs labeled with integer as well as algorithms on such graphs. 

    So if you bother functors, you can use this module. *)

(** Directed imperative graphs with edges and vertices labeled with integer. *)
module Digraph : Sig_pack.S

(** Undirected imperative graphs with edges and vertices labeled with
    integer. *)
module Graph : Sig_pack.S


end = struct
#0 "graph/pack.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: pack.ml,v 1.13 2006-05-12 14:07:16 filliatr Exp $ *)

module Generic(G : Sig.IM with type V.label = int and type E.label = int) = 
struct

  include G

  exception Found of V.t
  let find_vertex g i =
    try 
      iter_vertex (fun v -> if V.label v = i then raise (Found v)) g;
      raise Not_found
    with Found v -> 
      v

  module Builder = Builder.I(G)

  module Dfs = Traverse.Dfs(G)
  module Bfs = Traverse.Bfs(G)
  module Marking = Traverse.Mark(G)

  module Classic = Classic.I(G)

  module Rand = Rand.I(G)

  module Components = Components.Make(G)

  module W = struct 
    type label = int
    type t = int
    let weight x = x
    let zero = 0
    let add = (+)
    let compare : t -> t -> int = Pervasives.compare
  end

  include Path.Dijkstra(G)(W)

  module F = struct
    type label = int
    type t = int
    let max_capacity x = x
    let min_capacity _ = 0
    let flow _ = 0
    let add = (+)
    let sub = (-)
    let compare : t -> t -> int = Pervasives.compare
    let max = max_int
    let min = 0
    let zero = 0
  end

  module FF = Flow.Ford_Fulkerson(G)(F)
  let ford_fulkerson g = 
    if not G.is_directed then 
      invalid_arg "ford_fulkerson: not a directed graph";
    FF.maxflow g

  module Goldberg = Flow.Goldberg(G)(F)
  let goldberg g = 
    if not G.is_directed then invalid_arg "goldberg: not a directed graph";
    Goldberg.maxflow g

  include Oper.Make(Builder)

  module PathCheck = Path.Check(G)

  module Topological = Topological.Make(G)

  module Int = struct
    type t = int
    let compare : t -> t -> int = Pervasives.compare
  end

  include Kruskal.Make(G)(Int)

  module Display = struct
    include G
    let vertex_name v = string_of_int (V.label v)
    let graph_attributes _ = []
    let default_vertex_attributes _ = []
    let vertex_attributes _ = []
    let default_edge_attributes _ = []
    let edge_attributes _ = []
    let get_subgraph _ = None
  end
  module Dot_ = Graphviz.Dot(Display)
  module Neato = Graphviz.Neato(Display)

  let dot_output g f = 
    let oc = open_out f in
    if is_directed then Dot_.output_graph oc g else Neato.output_graph oc g;
    close_out oc

  let display_with_gv g =
    let tmp = Filename.temp_file "graph" ".dot" in
    dot_output g tmp;
    ignore (Sys.command ("dot -Tps " ^ tmp ^ " | gv -"));
    Sys.remove tmp

  module GmlParser = 
    Gml.Parse
      (Builder)
      (struct 
	 let node l = 
	   try match List.assoc "id" l with Gml.Int n -> n | _ -> -1
	   with Not_found -> -1
	 let edge _ =
	   0
       end)

  let parse_gml_file = GmlParser.parse

  module DotParser =
    Dot.Parse
      (Builder)
      (struct
 	 let nodes = Hashtbl.create 97
	 let new_node = ref 0
	 let node (id,_) _ = 
	   try 
	     Hashtbl.find nodes id
	   with Not_found -> 
	     incr new_node;
	     Hashtbl.add nodes id !new_node;
	     !new_node
	 let edge _ =
	   0
      end)

  let parse_dot_file = DotParser.parse

  open Format

  module GmlPrinter =
    Gml.Print
      (G)
      (struct
	 let node n = ["label", Gml.Int n]
	 let edge n = ["label", Gml.Int n]
       end)

  let print_gml_file g f =
    let c = open_out f in
    let fmt = formatter_of_out_channel c in
    fprintf fmt "%a@." GmlPrinter.print g;
    close_out c

end

module I = struct
  type t = int 
  let compare : t -> t -> int = Pervasives.compare
  let hash = Hashtbl.hash 
  let equal = (=)
  let default = 0
end

module Digraph = Generic(Imperative.Digraph.AbstractLabeled(I)(I))

module Graph = Generic(Imperative.Graph.AbstractLabeled(I)(I))


end
module Gmap: sig
#0 "graph/gmap.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: gmap.mli,v 1.1 2004-10-20 09:59:56 signoles Exp $ *)

(** Graph mapping. Map a graph to another one. *)

(** {2 Mapping of vertices} *)

(** Signature for the source graph. *)
module type V_SRC = sig
  type t
  module V : Sig.HASHABLE
  val fold_vertex : (V.t -> 'a -> 'a) -> t -> 'a -> 'a
end

(** Signature for the destination graph. *)
module type V_DST = sig
  type t
  type vertex
  val empty : unit -> t
  val add_vertex : t -> vertex -> t
end

(** Provide a mapping function from a mapping of vertices. *)
module Vertex(G_Src : V_SRC)(G_Dst : V_DST) : sig

  val map : (G_Src.V.t -> G_Dst.vertex) -> G_Src.t -> G_Dst.t
    (** [map f g] applies [f] to each vertex of [g] and so builds a new graph
	based on [g] *)

end

(** {2 Mapping of edges} *)

(** Signature for the source graph. *)
module type E_SRC = sig
  type t
  module E : Sig.HASHABLE
  val fold_edges_e : (E.t -> 'a -> 'a) -> t -> 'a -> 'a
end

(** Signature for the destination graph. *)
module type E_DST = sig
  type t
  type edge
  val empty : unit -> t
  val add_edge_e : t -> edge -> t
end

(** Provide a mapping function from a mapping of edges. *)
module Edge(G_Src: E_SRC)(G_Dst: E_DST) : sig

  val map : (G_Src.E.t -> G_Dst.edge) -> G_Src.t -> G_Dst.t
    (** [map f g] applies [f] to each edge of [g] and so builds a new graph
	based on [g] *)

end
end = struct
#0 "graph/gmap.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: gmap.ml,v 1.1 2004-10-20 09:59:56 signoles Exp $ *)

(** {2 Mapping of vertices} *)

module type V_SRC = sig
  type t
  module V : Sig.HASHABLE
  val fold_vertex : (V.t -> 'a -> 'a) -> t -> 'a -> 'a
end

module type V_DST = sig
  type t
  type vertex
  val empty : unit -> t
  val add_vertex : t -> vertex -> t
end

module Vertex(G_Src : V_SRC)(G_Dst : V_DST ) = struct
  
  module H = Hashtbl.Make(G_Src.V)
  let vertices = H.create 97

  let convert_vertex f x =
    try 
      H.find vertices x
    with Not_found ->
      let x' = f x in
      H.add vertices x x';
      x'

  let map f g =
    H.clear vertices;
    G_Src.fold_vertex
      (fun x g -> G_Dst.add_vertex g (convert_vertex f x)) 
      g (G_Dst.empty ())

end

(** {2 Mapping of edges} *)

module type E_SRC = sig
  type t
  module E : Sig.HASHABLE
  val fold_edges_e : (E.t -> 'a -> 'a) -> t -> 'a -> 'a
end

module type E_DST = sig
  type t
  type edge
  val empty : unit -> t
  val add_edge_e : t -> edge -> t
end

module Edge(G_Src: E_SRC)(G_Dst: E_DST) =
  Vertex
    (struct include G_Src module V = E let fold_vertex = fold_edges_e end)
    (struct include G_Dst type vertex = edge let add_vertex = add_edge_e end)
end
module Minsep: sig
#0 "graph/minsep.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(*i $Id: minsep.mli,v 1.4 2004-10-22 16:31:03 conchon Exp $ i*)

(**
  Minimal separators of a graph
  
  Based on the article:
  Generating all the minimal separators of a graph.
  by A. Berry, J.-P. Bordat and O.Cogis
  http://www.isima.fr/berry/generating.html
  
  A set [S] of vertices is a minimal separator if it exists 2 distinct
  connected components [C] and [D] in [G \ S] such that each vertex of [S] has
  a successor in [C] and [D]. *)

(** Minimal signature for computing the minimal separators *)
module type G = sig
  type t
  module V : Sig.COMPARABLE
  val succ: t -> V.t -> V.t list
  val iter_succ: (V.t -> unit) -> t -> V.t -> unit
  val fold_succ: (V.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
  val iter_vertex: (V.t -> unit) -> t -> unit
  val fold_vertex: (V.t -> 'a -> 'a) -> t -> 'a -> 'a
end

module type MINSEP = sig
  module G : G
    (** Implementation of a graph *)
  module Vertex_Set : Set.S with type elt = G.V.t
    (** Implementation of a set of vertex *)
  module VSetset : Set.S with type elt = Vertex_Set.t
    (** Implementation of a set of [Vertex_Set] *)

  val allminsep : G.t -> Vertex_Set.t list
    (** [allminsep g] computes the list of all minimal separators of g. *)
  val list_of_allminsep : G.t -> G.V.t list list
    (** Less efficient that [allminsep] *)
  val set_of_allminsep : G.t -> VSetset.t
    (** Less efficient that [allminsep] *)
end

(** Implementation for a persistent graph *)
module P(G : sig include G val remove_vertex : t -> V.t -> t end) : 
  MINSEP with module G = G

(** Implementation for an imperative graph.
  Less efficient that the implementation for a persistent graph *)
module I(G : sig 
	   include G 
	   module Mark : Sig.MARK with type graph = t and type vertex = V.t
	 end) : 
  MINSEP with module G = G

end = struct
#0 "graph/minsep.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(*i $Id: minsep.ml,v 1.7 2004-10-25 15:46:16 signoles Exp $ i*)

module type G = sig
  type t
  module V : Sig.COMPARABLE
  val succ: t -> V.t -> V.t list
  val iter_succ: (V.t -> unit) -> t -> V.t -> unit
  val fold_succ: (V.t -> 'a -> 'a) -> t -> V.t -> 'a -> 'a
  val iter_vertex: (V.t -> unit) -> t -> unit
  val fold_vertex: (V.t -> 'a -> 'a) -> t -> 'a -> 'a
end

module type MINSEP = sig
  module G : G
  module Vertex_Set : Set.S with type elt = G.V.t
  module VSetset : Set.S with type elt = Vertex_Set.t
  val allminsep : G.t -> Vertex_Set.t list
  val list_of_allminsep : G.t -> G.V.t list list
  val set_of_allminsep : G.t -> VSetset.t
end

module Make
  (G : sig 
     include G
     val cc: t -> V.t list -> V.t list list 
       (** compute the set of connected components of G(V \ l) *)
   end) =
struct

  module N = Oper.Neighbourhood(G)
  module Vertex_Set = N.Vertex_Set
  module VSetset = Set.Make(Vertex_Set)

  let initialisation g =
    let cc = G.cc g in
    let neighbourhood = N.list_from_vertex g in
    let neighbourhoods = N.set_from_vertices g in
    G.fold_vertex
      (fun v s -> 
	 List.fold_left 
	   (fun s l -> neighbourhoods l :: s)
	   s (cc (v :: neighbourhood v)))
      g []

  let generation g =
    let neighbourhood = N.list_from_vertex g in
    let neighbourhoods = N.set_from_vertices g in
    let cc = G.cc g in
    let rec gen_aux seen bigs = function
      | [] -> bigs
      | s :: tl ->
	  let l = Vertex_Set.elements s in
	  let seen = VSetset.add s seen in
	  let bigs, tl =
	    Vertex_Set.fold 
	      (fun v c ->
		 let add_neighbourhoods (bigs, tl) l = 
		   let s = neighbourhoods l in
		   s :: bigs, if VSetset.mem s seen then tl else s :: tl
		 in
		 List.fold_left 
		   add_neighbourhoods
		   (bigs, tl) (cc (l @ neighbourhood v)))
	      s (bigs, tl)
	  in
	  gen_aux seen bigs tl
    in
    fun bigs -> gen_aux VSetset.empty bigs bigs

  let allminsep g = generation g (initialisation g)

  let set_of_allminsep g = 
    List.fold_left 
      (fun bigs s -> VSetset.add s bigs) VSetset.empty (allminsep g)

  let list_of_allminsep g = List.map Vertex_Set.elements (allminsep g)

end

module P(G : sig include G val remove_vertex : t -> V.t -> t end) = struct
  module G = G
  include Make(struct
		 include G
		 let cc =
		   let module CC = Components.Make(G) in
		   fun g l ->
		     let g = List.fold_left remove_vertex g l in
		     CC.scc_list g
	       end)
end

module I(G : sig 
	   include G 
	   module Mark : Sig.MARK with type graph = t and type vertex = V.t 
	 end) =  
struct
  module G = G
  include Make(struct
		 include G
		 let cc = 
		   let module CC = 
		     Components.Make
		       (struct 
			  include G 
			  let iter_vertex f = 
			    iter_vertex (fun v -> if Mark.get v=0 then f v)
			end) 
		   in
		   fun g l ->
		     G.Mark.clear g;
		     List.iter (fun v -> G.Mark.set v 1) l;
		     CC.scc_list g
	       end)
end
end
module Cliquetree: sig
#0 "graph/cliquetree.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(*i $Id: cliquetree.mli,v 1.4 2004-10-19 15:22:47 signoles Exp $ i*)

(** Construction of the clique tree of a graph and recognition
    of chordal graphs.
  
    Based on the article:
    Chordal graphs and their clique graph
    by P. Galinier, M. Habib and C. Paul.
  
    @author Matthieu Sozeau *)

module CliqueTree(G : Sig.G) : sig

  (** Original graph vertex *)
  module CliqueV :
  sig
    type t
    val compare : t -> t -> int
    val hash : t -> int
    val equal : t -> t -> bool
    val label : t -> t
    val create : G.V.t -> t
    val vertex : t -> G.V.t
  end

  (** Set of original vertices *)
  module CVS : Set.S with type elt = CliqueV.t
		       
  (** Clique tree vertex type *)
  module CliqueTreeV : sig
    (** Trace of the algorithm as a list of markers Clique vertices *)
    type data = CliqueV.t list * CVS.t
    type label
    type t

    val compare : t -> t -> int
    val hash : t -> int
    val equal : t -> t -> bool
	    
    val create : data -> label -> t
    val label : t -> label
    val data : t -> data
  end
	
  module CliqueTreeE : sig
    type t = int * CVS.t
    val compare : t -> t -> int
    val default : t
    val create : int -> CVS.t -> t
	    
    (** Vertices in the clique tree edge 
      (intersection of the two clique extremities). *)
    val vertices : t -> CVS.t
  end
	
  (** The clique tree graph type *)
  module CliqueTree : Sig.G with type V.t = CliqueTreeV.t
			    and type E.label = CliqueTreeE.t
      
  (** [mcs_clique g] return an perfect elimination order of [g] 
    (if it is chordal), the clique tree of [g] and its root.  *)
  val mcs_clique : G.t -> G.V.t list * CliqueTree.t * CliqueTree.V.t

  (** [is_chordal g] uses the clique tree construction to test if a graph is 
    chordal or not. *)
  val is_chordal : G.t -> bool

  (** [maxwidth g tri tree] returns the maxwidth characteristic of the
    triangulation [tri] of graph [g] given the clique tree [tree] of [tri]. *)
  val maxwidth : G.t -> G.t -> CliqueTree.t -> int
end
end = struct
#0 "graph/cliquetree.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(*i $Id: cliquetree.ml,v 1.6 2005-11-02 13:43:35 filliatr Exp $ i*)

module CliqueTree(Gr : Sig.G) = struct

  (* Original vertex set (of Gr) *)
  module OVSet = Set.Make(Gr.V) 
    
  (* Vertex signature *)
  module rec CliqueV : 
  sig 
    type t
    val compare : t -> t -> int  
    val hash : t -> int
    val equal : t -> t -> bool
    val label : t -> t
    val create : Gr.V.t -> t
    val vertex : t -> Gr.V.t
    val number : t -> int
    val set_number : t -> int -> unit
    val clique : t -> int
    val set_clique : t -> int -> unit
    val mark : t -> int
    val incr_mark : t -> unit
    val m : t -> CVS.t
    val set_m : t -> CVS.t -> unit
    val last : t -> t
    val set_last : t -> t -> unit
  end =
  struct
    type t = {
      mutable mark: int;
      orig: Gr.V.t;
      mutable m: CVS.t;
      mutable last: t option;
      mutable number: int;
      mutable clique: int;
    }

    let compare x y = Gr.V.compare x.orig y.orig
    let hash x = Gr.V.hash x.orig
    let equal x y = Gr.V.equal x.orig y.orig

    type label = t
    let label x = x

    let create o = { 
      mark = 0; 
      orig = o; 
      m = CVS.empty;
      last = None;
      number = 0;
      clique = -1;
    }

    let vertex x = x.orig

    let clique x = x.clique
    let set_clique x v = x.clique <- v

    let number x = x.number
    let set_number x v = x.number <- v

    let mark x = x.mark
    let incr_mark x = 
      (*Printf.printf "Increasing mark of %s to %i\n%!"
	(Gr.v_to_string x.orig) (succ x.mark);*)
      x.mark <- succ x.mark

    let m x = x.m
    let set_m x v = x.m <- v
		      
    let last x = 
      match x.last with
	  Some v -> v
	| None -> failwith "last not set"
	    
    let set_last x v = x.last <- Some v

  end
    (* Clique tree vertex set *)
  and CVS : Set.S with type elt = CliqueV.t = Set.Make(CliqueV)
		    
  (* The final clique tree vertex type:
     - set of original vertexes ordered by mark.
     - clique number.
  *)
  module CliqueTreeV = 
    Util.DataV
      (struct type t = CliqueV.t list * CVS.t end)
      (struct
	 type t = int
	 type label = int
         let compare : t -> t -> int = Pervasives.compare
	 let hash = Hashtbl.hash
	 let equal x y = x = y
	 let label x = x
	 let create lbl = lbl
       end)  
    
  module CliqueTreeE = struct
    type t = int * CVS.t
	
    let compare (x, _ : t) (y, _ : t) = Pervasives.compare x y

    let default = (0, CVS.empty)
		    
    let create n s = (n, s)
		       
    let vertices = snd

    let width g tri (_, x) = 
      let vertices = List.map CliqueV.vertex (CVS.elements x) in
      let w =
	List.fold_left
	  (fun w v ->
	     List.fold_left
	     (fun w v' ->
		if v <> v' then
		  if not (Gr.mem_edge g v v') && Gr.mem_edge tri v v'
		  then succ w
		  else w
		else w)
	     w vertices)
	  0 vertices
      in 
      assert(w mod 2 = 0);
      w / 2
  end
    
  (* The returned tree *)
  module CliqueTree =
    Persistent.Digraph.ConcreteLabeled(CliqueTreeV)(CliqueTreeE)
      
  (* Intermediate graph *)
  module G = Persistent.Graph.Concrete(CliqueV)
    
  (* Convenient types *)
  module EdgeSet = Set.Make(G.E)
  module H = Hashtbl.Make(CliqueV)

  (* Used to choose some vertex in the intermediate graph *)
  module Choose = Oper.Choose(G)

  (* Creates the intermediate graph from the original *)
  module Copy = Gmap.Vertex(Gr)(struct include G include Builder.P(G) end)

  open CliqueV

  let vertices_list x =
    let l = CVS.elements x in
    List.sort
      (fun x y -> 
	 (*let markx = mark x and marky = mark y in*)
	 (Pervasives.compare : int -> int -> int) (number y) (number x))
      l

  let mcs_clique g =
    (* initializations *)
    let n = Gr.nb_vertex g in
    let g' = Copy.map CliqueV.create g in
    let unnumbered = ref (G.fold_vertex CVS.add g' CVS.empty) in
    let pmark = ref (-1) in
    let order = ref [] in
    let cliques = Array.make n ([], CVS.empty) in
    let ties = ref [] in
    let j = ref 0 in
      (* loop, taking each unnumbered vertex in turn *)
      for i = n downto 1 do
	(* Find greatest unnumbered vertex
	   if CVS.is_empty !unnumbered then
	   Printf.printf "No more unnumbered vertices\n%!"
	   else
	   Printf.printf "%i unnumbered vertices remaining\n%!" 
	   (CVS.cardinal !unnumbered);
	*)
 	let x, mark = 
	  let choosed = CVS.choose !unnumbered in
 	    CVS.fold
 	      (fun x ((maxx, maxv) as max) ->
 		 let v = mark x in
 		 if v > maxv then (x, v) else max)
 	      !unnumbered (choosed, mark choosed)
  	in
	  (* peo construction *)
	  order := x :: !order;
	  (* now numbered *)
	  unnumbered := CVS.remove x !unnumbered;
	  if mark <= !pmark then begin
	    (* Create a new clique (lemma 8) *)
	    incr j;
	    (* m x is the neighborhoud of x in the previous clique *)
	    cliques.(!j) <- ([x], CVS.add x (m x));
	    (* Use reverse map of cliques to find what clique 
	       we're connected to. m x is the width of the ties *)
	    let clast = clique (last x) in
	    ties := (clast, m x, !j) :: !ties;
	  end else begin
	    let l, c = cliques.(!j) in
	    cliques.(!j) <- (x::l, CVS.add x c);
	  end;
	  G.iter_succ
	    (fun y ->
	       if number y == 0 then begin
		 incr_mark y;
		 set_m y (CVS.add x (m y));
	       end;
	       set_last y x)
	    g' x;
	  pmark := mark;
	  set_number x i;
	  set_clique x !j;
      done;
      let cliques = 
	Array.mapi
	  (fun i (l, c) -> CliqueTreeV.create (List.rev l, c) i)
	  (Array.sub cliques 0 (succ !j))
      in
      let tree = 
	Array.fold_left CliqueTree.add_vertex CliqueTree.empty cliques
      in
      let tree, _ = 
	List.fold_left
	  (fun (g, n) (i, verts, j) ->	     
	     let label = CliqueTreeE.create n verts in
	     let edge = CliqueTree.E.create cliques.(i) label cliques.(j) in
	     (CliqueTree.add_edge_e g edge, succ n))
	  (tree, 1) !ties
      in
      List.map CliqueV.vertex !order, tree, cliques.(0)

   let sons g x = CliqueTree.fold_succ (fun x y -> x :: y) g x []

   exception NotClique

   let rec drop_while p l =
     match l with
       | x :: tl -> 
	   if p x then drop_while p tl
	   else l
       | [] -> []

   let test_simpliciality_first l sons =
     let takeOne l = match !l with
       | x :: xs -> l := xs; Some x
       | [] -> None
     in
     let vertices = ref l in
     let sons = ref sons in
     try
       while !vertices <> [] && not (List.for_all (fun c -> !c = []) !sons) do
	 (match takeOne vertices with
	      Some v -> 
		let mark = CliqueV.mark v in
		List.iter
		  (fun s -> 
		     match !s with
		       | y :: tl -> 
			   let ymark = CliqueV.mark y in
			   if ymark > mark then
			     ()
			   else if ymark = mark then
			     s := drop_while 
			       (fun y -> CliqueV.mark y = mark) tl
			   else raise NotClique
		       | [] -> ())
		  !sons
	      | None -> assert false);
       done;
       !vertices <> []
     with NotClique -> false

   let test_simpliciality_first' l sons =
     List.for_all
       (fun son ->
	  match !son with
	    | [] -> false
	    | xi :: tl ->
		let other = m xi in
		CVS.subset other l)
       sons

   let test_simpliciality_next vertices sons =
     match vertices with
       | x :: tl ->
	   begin
	     try
	       ignore(
		 List.fold_left
			(fun vm v' ->
			   let vm' = CliqueV.m v' in
			   if CVS.equal vm' vm then
			     CVS.add v' vm'
			   else raise NotClique)
			(CVS.add x (m x)) tl);
	       true
	     with NotClique -> false
	   end
       | _ -> true

   let is_chordal g = 
     let order, tree, root = mcs_clique g in
     let rec aux c = 
       let csons = sons tree c in
       let s = List.map CliqueTreeV.data csons in
       let l = CliqueTreeV.data c in
       let sons () = List.map (fun (x,y) -> ref x) s in
       let first = test_simpliciality_first' (snd l) (sons ()) in
       let next = test_simpliciality_next (fst l) (sons ()) in
       first && next && (List.for_all aux csons)
     in 
     aux root
	  
   let maxwidth g tri tree = 
     CliqueTree.fold_edges_e
       (fun e res -> 
	  let w = CliqueTreeE.width g tri (CliqueTree.E.label e) in	   
	  max res w)
       tree 0      	 

end
end
module Mcs_m: sig
#0 "graph/mcs_m.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: mcs_m.mli,v 1.2 2004-10-19 15:21:44 signoles Exp $ *)

(** Maximal Cardinality Search (MCS-M) algorithm
  
    Based on the article:
    Maximal Cardinality Search for Computing Minimal Triangulations of Graphs.
    by A. Berry, Jean R. S. Blair, Pinar Heggernes & Barry W. Peyton.
  
    @author Matthieu Sozeau
    @author Pierre-Loic Garoche *)

module MaximalCardinalitySearch : sig
  module P(G : Sig.P) : sig
    type edgelist = (G.V.t * G.V.t) list	  
	
    (** [mcsm g] returns a tuple [(o, e)] where [o] is a perfect elimination
      order of [g'] where [g'] is the triangulation [e] applied to [g]. *)
    val mcsm : G.t -> (int * G.V.t) list * edgelist

    (** [triangulate g] computes a triangulation of [g]
      using the MCS-M algorithm *)
    val triangulate : G.t -> G.t
  end
  module I(Gr : Sig.I) : sig
    type edgelist = (Gr.V.t * Gr.V.t) list	  
          
    (** [mcsm g] return a tuple [(o, e)] where o is a perfect elimination order
      of [g'] where [g'] is the triangulation [e] applied to [g]. *) 
    val mcsm : Gr.t -> (int * Gr.V.t) list * edgelist
          
    (** [triangulate g] triangulates [g] using the MCS-M algorithm *)
    val triangulate : Gr.t -> unit
  end
end
end = struct
#0 "graph/mcs_m.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: mcs_m.mli,v 1.2 2004-10-19 15:21:44 signoles Exp $ *)
       
module MaximalCardinalitySearch = struct

  module WeightedV(V : Sig.COMPARABLE) = struct
    include Util.DataV(struct type t = int end)(V)
    let weight = data
    let set_weight = set_data
  end

  module P(Gr : Sig.P) = struct
    type edgelist = (Gr.V.t * Gr.V.t) list

    module NewV = WeightedV(Gr.V)
    module G = Persistent.Graph.Concrete(NewV)
    module EdgeSet = Set.Make(G.E)
    module VerticesSet = Set.Make(NewV)
    module Choose = Oper.Choose(G)
    module H = Hashtbl.Make(NewV)
      
    exception Found
      
    let check_path g u v =
      let h = H.create 97 in
      let maxw = NewV.weight u in
      let rec aux x : bool = 
	if H.mem h x then
	  false
	else 
	  if x = v then true
	  else
	    if NewV.weight x < maxw || x = u then
	      begin
		H.add h x ();
		G.fold_succ 
		  (fun x found -> 
		     if not found then aux x
		     else found)
		  g x false
	      end
	    else (H.add h x (); false)
      in aux u
	   
    module Copy = Gmap.Vertex(Gr)(struct include G include Builder.P(G) end)

    let fold f d =
      let rec aux = function
	  (true, a) -> aux (f a)
	| (false, a) -> a
      in aux d
	   
    let mcsm g =
      let g' = Copy.map (NewV.create 0) g in
      let (_, _, ord, triang) =
	fold 
	  (fun ((i, g', a, f) as x)->
	     if i = 0 then (false, x)
	     else
	       let v =
		 G.fold_vertex
		   (fun x max -> 
		      if NewV.weight x > NewV.weight max then x else max)
		   g' (ref 0, snd (Choose.choose_vertex g'))
	       in
	       let s =
		 G.fold_vertex
		   (fun x s ->
		      if x = v then s
		      else 
			if check_path g' x v then
			  VerticesSet.add x s
			else s)
		   g' VerticesSet.empty
	       in
	       let f' = 
		 VerticesSet.fold
		   (fun x f ->
		      NewV.set_weight x (succ (NewV.weight x));
		      if not (G.mem_edge g' x v) then
			EdgeSet.add (x,v) f
		      else f)
		   s f
	       in
	       let g' = G.remove_vertex g' v in
	       let a' = (i, NewV.label v) :: a in
		 (true, (i - 1, g', a', f')))
	  (true, (Gr.nb_vertex g, g', [], EdgeSet.empty))
      in
      (List.rev ord, 
       EdgeSet.fold 
	 (fun (x, y) e -> (NewV.label x, NewV.label y) :: e)
	 triang [])
	  
    let triangulate g =
      let (_, triang) = mcsm g in
      List.fold_left (fun g (x, y) -> Gr.add_edge g x y) g triang
  end

  module I(Gr : Sig.I) = struct
    type edgelist = (Gr.V.t * Gr.V.t) list	  

    module NewV = WeightedV(Gr.V)
    module G = Imperative.Graph.Concrete(NewV)
    module EdgeSet = Set.Make(G.E)
    module VerticesSet = Set.Make(NewV)
    module Choose = Oper.Choose(G)
    module H = Hashtbl.Make(NewV)
      
    exception Found
      
    let check_path g u v =
      let h = H.create 97 in
      let maxw = NewV.weight u in
      let rec aux x : bool = 
	if H.mem h x then
	  false
	else 
	  if x = v then true
	  else
	    if NewV.weight x < maxw || x = u then begin
	      H.add h x ();
	      G.fold_succ 
		(fun x found -> 
		   if not found then aux x
		   else found)
		g x false
	    end else (H.add h x (); false)
      in aux u
	   
    module Copy = Gmap.Vertex(Gr)(struct include G include Builder.I(G) end)
      
    let mcsm g =
      let f = ref EdgeSet.empty
      and a = ref []
      and g' = Copy.map (NewV.create 0) g in
      for i = Gr.nb_vertex g downto 1 do
	let v =
	  G.fold_vertex
	    (fun x max -> 
	       if NewV.weight x > NewV.weight max then x else max)
	    g' (ref 0, snd (Choose.choose_vertex g'))
	in
	let s =
	  G.fold_vertex
	    (fun x s ->
	       if x = v then s
	       else 
		 if check_path g' x v then
		   VerticesSet.add x s
		 else s)
	    g' VerticesSet.empty
	in
	let f' = 
	  VerticesSet.fold
	    (fun x f ->
	       NewV.set_weight x (succ (NewV.weight x));
	       if not (G.mem_edge g' x v) then
		 EdgeSet.add (x,v) f
	       else f)
	    s !f
	in
	f := f';
	G.remove_vertex g' v;
	a := (i, NewV.label v) :: !a;
      done;
      (List.rev !a, 
       EdgeSet.fold 
	 (fun (x, y) e -> (NewV.label x, NewV.label y) :: e)
	 !f [])
	  
    let triangulate g =
      let (_, triang) = mcsm g in
      List.iter (fun (x, y) -> Gr.add_edge g x y) triang
  end
end
end
module Md: sig
#0 "graph/md.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: md.mli,v 1.2 2004-06-28 13:48:25 signoles Exp $ *)

(** Minimum Degree algorithm
  
    Based on the article:
    The Minimum Degree Heuristic and the Minimal Triangulation Process
    by A. Berry, Pinar Heggernes & Genevive Simonet.
  
    @author Matthieu Sozeau
    @author Pierre-Loic Garoche *)

module P(G : Sig.P) : sig

  type edgeset = (G.V.t * G.V.t) list

  val md : G.t -> G.t * edgeset * G.V.t list
    (** [md g] return a tuple [(g', e, o)] where [g'] is 
      a triangulated graph, [e] is the triangulation of [g] and
      [o] is a perfect elimination order of [g'] *)

  val triangulate : G.t -> G.t
    (** [triangulate g] return the graph [g'] produced by applying 
      miminum degree to [g]. *)

end

module I(G : Sig.I) : sig
  
  type edgeset = (G.V.t * G.V.t) list
	
  val md : G.t -> G.t * edgeset * G.V.t list
    (** [md g] return a tuple [(g', e, o)] where [g'] is 
      a triangulated graph, [e] is the triangulation of [g] and
      [o] is a perfect elimination order of [g'] *)

  val triangulate : G.t -> G.t
    (** [triangulate g] return the graph [g'] produced by applying 
      miminum degree to [g]. *)

end
end = struct
#0 "graph/md.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id: md.ml,v 1.6 2004-10-22 14:42:06 signoles Exp $ *)
  
  
module P(G : Sig.P) = struct

  module VertexSet = Set.Make(G.V)
  module CT = Cliquetree.CliqueTree(G)
  module Choose = Oper.Choose(G)

  type edgeset = (G.V.t * G.V.t) list
      
  let md g =
    let gref = ref g in
    let gtri = ref g in
    let n = G.nb_vertex g in
    let tri = ref [] in
    let ord = ref [] in
    let i = ref 0 in
    while not (CT.is_chordal !gtri) && !i < n do
      let v = 
	let x = 
	  G.fold_vertex 
	    (fun v' x ->
	       let deg' = G.out_degree !gref v' in
	       match x with
		   Some (v,deg) when deg' > deg -> x
		 | _ -> Some (v', deg'))
	    !gref None
	in match x with 
	    Some (v,_) -> v
	  | None -> failwith "Expecting some vertex"
      in
      let ng = G.succ !gref v in
      let g', tri' =
	List.fold_left
	  (fun (g, tri) v ->
	     let tri' =
	       List.fold_left
		 (fun tri v' ->
		    if v <> v' && not (G.mem_edge g v v') then
		      (v, v') :: tri
		    else tri)
		 tri ng
	     in
	     let g' = 
	       List.fold_left
		 (fun g v' ->
		    if v <> v' then
		      G.add_edge g v v'
		    else g)
		 g ng
	     in 
	     (g', tri'))
	  (!gref, []) ng 
      in
      ord := v :: !ord;
      gtri := List.fold_left 
	(fun g (x,y) -> G.add_edge g x y) 
	!gtri tri';
      gref := G.remove_vertex g' v;
      tri := tri' @ !tri;
      incr i;
    done;
    (!gtri, !tri, !ord)
	  
  let triangulate g = 
    let gtri, _, _ = md g in 
    gtri

end

module I(G : Sig.I) = struct

  module VertexSet = Set.Make(G.V)   
  module CT = Cliquetree.CliqueTree(G)
  module Choose = Oper.Choose(G)
            
  type edgeset = (G.V.t * G.V.t) list
      
  module Copy = Gmap.Vertex(G)(struct include G include Builder.I(G) end)

  let md g =
    let gtri = Copy.map (fun x -> x) g in
    let gcur = Copy.map (fun x -> x) g in
    let n = G.nb_vertex g in
    let tri = ref [] in
    let ord = ref [] in
    let i = ref 0 in
    while not (CT.is_chordal gtri) && !i < n do
      let v = 
	let x = 
	  G.fold_vertex 
	    (fun v' x ->
	       let deg' = G.out_degree gcur v' in
	       match x with
		   Some (v,deg) when deg' > deg -> x
		 | _ -> Some (v', deg'))
	    gcur None
	in match x with 
	    Some (v,_) -> v
	  | None -> failwith "Expecting some vertex"
      in
      let ng = G.succ gcur v in
      let tri' =
	List.fold_left
	  (fun tri v ->
	     List.fold_left
	     (fun tri v' ->
		let tri' =
		  if v <> v' && not (G.mem_edge g v v') then
		    (v, v') :: tri
		  else 
		    tri
		in
		List.iter (fun v' -> if v <> v' then G.add_edge gcur v v') ng;
		tri')
	     tri ng)
	  [] ng
      in
      ord := v :: !ord;
      List.iter
	(fun (x,y) -> G.add_edge gtri x y) 
	tri';
      G.remove_vertex gcur v;
      tri := tri' @ !tri;
      incr i;
    done;
    (gtri, !tri, !ord)
	  
  let triangulate g = 
    let gtri, _, _ = md g in 
    gtri

end
end
module Strat: sig
#0 "graph/strat.mli"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id$ *)

(** Strategies 

    Implementation of a winning strategy of a graph: the graph
    represents a two players game, each vertex belongs to either player
    (whose turn it is to play) and describes a configuration of the
    game. The algorithm computes the winning strategy of a player, if any; 
    i.e. the moves to play (which vertex to go to) so that for all
    possible moves of the other player, the game goes through a final
    state. 

    @author Nicolas Ayache *)

(** Signature for graphs *)
module type G = sig
  type t
  module V : Sig.ORDERED_TYPE
  type vertex = V.t
  val mem_vertex : t -> vertex -> bool
  val succ : t -> vertex -> vertex list
  val fold_vertex : (vertex -> 'a -> 'a) -> t -> 'a -> 'a
  val fold_succ : (vertex -> 'a -> 'a) -> t -> vertex -> 'a -> 'a
end

(** Signature for graph add-ons: an initial vertex, final vertices
    and membership of vertices to either true or false,
    i.e. first or second player *)
module type PLAYER = sig

  type t
  type vertex

  val get_initial : t -> vertex
  val is_final : t -> vertex -> bool

  val turn : t -> vertex -> bool

end

(** Signature for strategies: for a given state, the strategy tells
    which state to go to *)
module type STRAT = sig

  type t
  type vertex

  val empty : t
  val add : t -> vertex -> vertex -> t

  val next : t -> vertex -> vertex
    (** @raise Invalid_argument if vertex's image is not defined *)

end

(** Implements strategy algorithms on graphs *)
module Algo
  (G : G)
  (P : PLAYER with type vertex = G.vertex)
  (S : STRAT with type vertex = G.vertex) :
sig

  (** [coherent_player g p] returns [true] iff
     the completion [p] is coherent w.r.t.
     the graph g *)
  val coherent_player : G.t -> P.t -> bool

  (** [coherent_strat g s] returns [true] iff
     the strategy [s] is coherent w.r.t.
     the graph [g] *)
  val coherent_strat : G.t -> S.t -> bool

  (** [game g p a b] returns [true] iff [a] wins in [g]
     given the completion [p] (i.e. the game
     goes through a final state). *)
  val game : G.t -> P.t -> S.t -> S.t -> bool

  (** [strategy g p s] returns [true] iff [s] wins in [g]
     given the completion [p], whatever strategy
     plays the other player. *)
  val strategy : G.t -> P.t -> S.t -> bool

  (** [strategyA g p] returns [true] iff there
      exists [a] winning stragegy for the true
      player. In this case, the winning
      strategy is provided. *)
  val strategyA : G.t -> P.t -> (bool * S.t)

end
end = struct
#0 "graph/strat.ml"
(**************************************************************************)
(*                                                                        *)
(*  Ocamlgraph: a generic graph library for OCaml                         *)
(*  Copyright (C) 2004-2010                                               *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* $Id$ *)

(* Signature for graphs *)
module type G = sig

  type t

  module V : Sig.ORDERED_TYPE

  type vertex = V.t

  val mem_vertex : t -> vertex -> bool

  val succ : t -> vertex -> vertex list

  val fold_vertex : (vertex -> 'a -> 'a) -> t -> 'a -> 'a
  val fold_succ : (vertex -> 'a -> 'a) -> t -> vertex -> 'a -> 'a
end


(* Signature for graph add-ons: an initial vertex, final vertices
   and membership of vertices to either true or false,
   i.e. first or second player *)
module type PLAYER = sig

  type t
  type vertex

  val get_initial : t -> vertex
  val is_final : t -> vertex -> bool

  val turn : t -> vertex -> bool

end


(* Signature for strategies : for a given state, the strategy tells
   which state to go to *)
module type STRAT = sig

  type t
  type vertex

  val empty : t
  val add : t -> vertex -> vertex -> t

  val next : t -> vertex -> vertex
    (* Raises Invalid_argument if vertex's image is not defined *)

end


(* Implements strategy algorithms on graphs *)
module Algo (G : G) (P : PLAYER with type vertex = G.vertex)
  (S : STRAT with type vertex = G.vertex) :
sig

  (* coherent_player g p returns true iff
     the completion p is coherent w.r.t.
     the graph g *)
  val coherent_player : G.t -> P.t -> bool

  (* coherent_strat g s returns true iff
     the strategy s is coherent w.r.t.
     the graph g *)
  val coherent_strat : G.t -> S.t -> bool

  (* game g p a b returns true iff a wins in g
     given the completion p (i.e. the game
     goes through a final state). *)
  val game : G.t -> P.t -> S.t -> S.t -> bool

  (* strategy g p s returns true iff s wins in g
     given the completion p, whatever strategy
     plays the other player. *)
  val strategy : G.t -> P.t -> S.t -> bool

  (* strategyA g p returns true iff there
     exists a winning stragegy for the true
     player. In this case, the winning
     strategy is provided. *)
  val strategyA : G.t -> P.t -> (bool * S.t)
end = struct

    module SetV = Set.Make (G.V)


    let rec eq l1 l2 = match l1, l2 with
	[], [] -> true
      | e1 :: l1', e2 :: l2' ->
	  (e1 = e2) && (eq l1' l2')
      | _ -> false

    let rec eq_mem i l1 l2 = match l1, l2 with
	[], [] -> (true, false)
      | e1 :: l1', e2 :: l2' ->
	  if e1 = e2 then
	    if e1 = i then (eq l1' l2', true)
	    else eq_mem i l1' l2'
	  else (false, false)
      | _ -> (false, false)

    let puit g v = match G.succ g v with
	[] -> true
      | _ -> false


    let get_finals g p =
      let f a l =
	if P.is_final p a then a :: l
	else l
      in G.fold_vertex f g []


    let coherent_player g p =
      G.mem_vertex g (P.get_initial p)


    let coherent_strat g s =
      let f v b =
	try
	  let v' = S.next s v in
	    b && (G.mem_vertex g v')
	with Invalid_argument _ -> true
      in
	G.fold_vertex f g true


    let game g p a b =

      let rec game_aux l pi =
	let continue x =
	  try
	    game_aux (SetV.add pi l) (S.next x pi)
	  with Invalid_argument _ -> false
	in
	  (P.is_final p pi) ||
	    (if SetV.mem pi l then false
	     else
	       if P.turn p pi then continue a
	       else continue b)

      in
	game_aux SetV.empty (P.get_initial p)


    let rec attract1 g p s l =
      let f v l1 =
	if not (List.mem v l1) then
	  if P.turn p v then
	    try
	      if List.mem (S.next s v) l1 then v :: l1
	      else l1
	    with Invalid_argument _ -> l1
	  else
	    if puit g v then l1
	    else
	      if G.fold_succ (fun v' b -> b && (List.mem v' l1)) g v true
	      then v :: l1
	      else l1
	else l1
      in
	G.fold_vertex f g l


    let rec strategy g p s =

      let rec strategy_aux l1 l2 =
	let (b1, b2) = eq_mem (P.get_initial p) l1 l2 in
	  if b1 then b2
	  else strategy_aux (attract1 g p s l1) l1

      in
      let finaux = get_finals g p in
	strategy_aux (attract1 g p s finaux) finaux
	  

    let rec attract g p (l, l') =
      let f v (l1, l1') =
	if not (List.mem v l1) then
	  if P.turn p v then
	    let f' v' l2 =
	      (match l2 with
		   [] ->
		     if List.mem v' l1 then [v']
		     else []
		 | _ -> l2) in
	      (match G.fold_succ f' g v [] with
		   [] -> (l1, l1')
		 | v' :: _ -> (v :: l1, S.add l1' v v' ))
	  else
	    if puit g v then (l1, l1')
	    else
	      if G.fold_succ (fun v' b -> b && (List.mem v' l1)) g v true
	      then (v :: l1, l1')
	      else (l1, l1')
	else (l1, l1')
      in
	G.fold_vertex f g (l, l')


    let rec strategyA g p =

      let rec strategyA_aux l1 l2 f =
	let (b1, b2) = eq_mem (P.get_initial p) l1 l2 in
	  if b1 then (b2, f)
	  else
	    let (new_l1, new_f) = attract g p (l1, f) in
	      strategyA_aux new_l1 l1 new_f

      in
      let finaux = get_finals g p in
      let (l, r) = attract g p (finaux, S.empty) in
	strategyA_aux l finaux r;;

  end
end
end
module rec Version: sig
#0 "version.mli"
val version : string
val date : string
val libdir : string
end = struct
let _ = Printf.fprintf stderr "Executing version.ml\n%!"module type INTERFACE = sig
#0 "version.mli"
val version : string
val date : string
val libdir : string
end
module IMPLEMENTATION = struct
#0 "version.ml"
let version = "0.92.3"
let date = "Thu May 5 15:11:37 CEST 2011"
let libdir = "/usr/local/lib/alt-ergo"
end
include (IMPLEMENTATION : INTERFACE)
end
and Exception: sig
#0 "exception.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

exception Unsolvable
exception Inconsistent of Explanation.t
exception Progress
exception NotCongruent
exception Trivial
exception Interpreted_Symbol
end = struct
let _ = Printf.fprintf stderr "Executing exception.ml\n%!"module type INTERFACE = sig
#0 "exception.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

exception Unsolvable
exception Inconsistent of Explanation.t
exception Progress
exception NotCongruent
exception Trivial
exception Interpreted_Symbol
end
module IMPLEMENTATION = struct
#0 "exception.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

exception Unsolvable
exception Inconsistent of Explanation.t
exception Progress
exception NotCongruent
exception Trivial
exception Interpreted_Symbol
end
include (IMPLEMENTATION : INTERFACE)
end
and Print_color: sig
#0 "print_color.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type style =
    (* users ansi style number *)
  |User of int

      (* the typeset *)
  |Normal
  |Bold  (* the text is in bold *)
  |Bold_off (* the text is unbold *)
  |Underline
  |Underline_off
  |Inverse
  |Inverse_off
  |Blink_off
      (* Foreground color *)
  |F_Black 
  |F_Red
  |F_Green
  |F_Yellow
  |F_Blue
  |F_Magenta
  |F_Cyan
  |F_Gray
  |F_Default
      (* Background color *)
  |G_Black 
  |G_Red
  |G_Green
  |G_Yellow
  |G_Blue
  |G_Magenta
  |G_Cyan
  |G_Gray
  |G_Default
      (* Foreground color bright*)
  |F_Black_B
  |F_Red_B
  |F_Green_B
  |F_Yellow_B
  |F_Blue_B
  |F_Magenta_B
  |F_Cyan_B
  |F_Gray_B
  |F_Default_B
      (* Background color bright*)
  |G_Black_B
  |G_Red_B
  |G_Green_B
  |G_Yellow_B
  |G_Blue_B
  |G_Magenta_B
  |G_Cyan_B
  |G_Gray_B
  |G_Default_B

(* if you net the start you 
   must use the stop in order 
   to have good color *)
val start : style list -> unit
val stop : unit -> unit

(* give a string instead of stdout *)
val sstart : style list-> string
val sstop : unit -> string

(* use Format instead of Printf *)
val format_start : style list-> unit
val format_stop : unit -> unit
val fstartf : Format.formatter -> style list -> unit
val fstopf : Format.formatter -> unit

(*disable all(returned string are empty), but keep track of the start and stop *)
val disable : bool -> unit

(* Les tags sont de la forme "C.<un_style>" (sauf user) *)
val add_to_format_tag : Format.formatter -> unit

val set_margin_with_term_width : Format.formatter -> unit

(* Just some tools *)
  (* print_list separator print_element formatter list *)
(*val print_list : ('a, 'b, 'c, 'd, 'd, 'a) format6 -> (Format.formatter -> 'e -> unit) -> Format.formatter -> 'e list -> unit*)

val print_list : string -> (Format.formatter -> 'e -> unit) -> Format.formatter -> 'e list -> unit
end = struct
let _ = Printf.fprintf stderr "Executing print_color.ml\n%!"module type INTERFACE = sig
#0 "print_color.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type style =
    (* users ansi style number *)
  |User of int

      (* the typeset *)
  |Normal
  |Bold  (* the text is in bold *)
  |Bold_off (* the text is unbold *)
  |Underline
  |Underline_off
  |Inverse
  |Inverse_off
  |Blink_off
      (* Foreground color *)
  |F_Black 
  |F_Red
  |F_Green
  |F_Yellow
  |F_Blue
  |F_Magenta
  |F_Cyan
  |F_Gray
  |F_Default
      (* Background color *)
  |G_Black 
  |G_Red
  |G_Green
  |G_Yellow
  |G_Blue
  |G_Magenta
  |G_Cyan
  |G_Gray
  |G_Default
      (* Foreground color bright*)
  |F_Black_B
  |F_Red_B
  |F_Green_B
  |F_Yellow_B
  |F_Blue_B
  |F_Magenta_B
  |F_Cyan_B
  |F_Gray_B
  |F_Default_B
      (* Background color bright*)
  |G_Black_B
  |G_Red_B
  |G_Green_B
  |G_Yellow_B
  |G_Blue_B
  |G_Magenta_B
  |G_Cyan_B
  |G_Gray_B
  |G_Default_B

(* if you net the start you 
   must use the stop in order 
   to have good color *)
val start : style list -> unit
val stop : unit -> unit

(* give a string instead of stdout *)
val sstart : style list-> string
val sstop : unit -> string

(* use Format instead of Printf *)
val format_start : style list-> unit
val format_stop : unit -> unit
val fstartf : Format.formatter -> style list -> unit
val fstopf : Format.formatter -> unit

(*disable all(returned string are empty), but keep track of the start and stop *)
val disable : bool -> unit

(* Les tags sont de la forme "C.<un_style>" (sauf user) *)
val add_to_format_tag : Format.formatter -> unit

val set_margin_with_term_width : Format.formatter -> unit

(* Just some tools *)
  (* print_list separator print_element formatter list *)
(*val print_list : ('a, 'b, 'c, 'd, 'd, 'a) format6 -> (Format.formatter -> 'e -> unit) -> Format.formatter -> 'e list -> unit*)

val print_list : string -> (Format.formatter -> 'e -> unit) -> Format.formatter -> 'e list -> unit
end
module IMPLEMENTATION = struct
#0 "print_color.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type style =
  |User of int
  |Normal
  |Bold  |Bold_off
  |Underline  |Underline_off
  |Inverse  |Inverse_off  
  |Blink_off
  |F_Black  |F_Red  |F_Green  |F_Yellow  |F_Blue  |F_Magenta  |F_Cyan  |F_Gray
  |F_Default
  |G_Black  |G_Red  |G_Green  |G_Yellow  |G_Blue  |G_Magenta  |G_Cyan  |G_Gray
  |G_Default
  |F_Black_B  |F_Red_B  |F_Green_B  |F_Yellow_B  |F_Blue_B  |F_Magenta_B
  |F_Cyan_B  |F_Gray_B  |F_Default_B
  |G_Black_B  |G_Red_B  |G_Green_B  |G_Yellow_B  |G_Blue_B  |G_Magenta_B
  |G_Cyan_B  |G_Gray_B |G_Default_B

let assoc_style =  function
  |User i ->(i,"m");
  (*|Move_up i -> (i,"A");*)
  |Normal->(0,"m");
  |Bold->(1,"m");
  |Bold_off->(22,"m");
  |Underline->(4,"m");
  |Underline_off->(24,"m");
  |Inverse->(7,"m");
  |Inverse_off->(27,"m");
  |Blink_off->(22,"m");
  |F_Black->(30,"m");
  |F_Red->(31,"m");
  |F_Green->(32,"m");
  |F_Yellow->(33,"m");
  |F_Blue->(34,"m");
  |F_Magenta->(35,"m");
  |F_Cyan->(36,"m");
  |F_Gray->(37,"m");
  |F_Default->(39,"m");
  |G_Black->(40,"m");
  |G_Red->(41,"m");
  |G_Green->(42,"m");
  |G_Yellow->(43,"m");
  |G_Blue->(44,"m");
  |G_Magenta->(45,"m");
  |G_Cyan->(46,"m");
  |G_Gray->(47,"m");
  |G_Default->(49,"m");
  |F_Black_B->(90,"m");
  |F_Red_B->(91,"m");
  |F_Green_B->(92,"m");
  |F_Yellow_B->(93,"m");
  |F_Blue_B->(94,"m");
  |F_Magenta_B->(95,"m");
  |F_Cyan_B->(96,"m");
  |F_Gray_B->(97,"m");
  |F_Default_B->(99,"m");
  |G_Black_B->(100,"m");
  |G_Red_B->(101,"m");
  |G_Green_B->(102,"m");
  |G_Yellow_B->(103,"m");
  |G_Blue_B->(104,"m");
  |G_Magenta_B->(105,"m");
  |G_Cyan_B->(106,"m");
  |G_Gray_B->(107,"m");
  |G_Default_B->(109,"m");

module M = Map.Make (String)

let tag_map = 
List.fold_left (fun m (k,e) -> M.add k e m) M.empty [
  ("C.Normal",Normal);
  ("C.Bold",Bold);
  ("C.Bold_off",Bold_off);
  ("C.Underline",Underline);
  ("C.Underline_off",Underline_off);
  ("C.Inverse",Inverse);
  ("C.Inverse_off",Inverse_off);  
  ("C.Blink_off",Blink_off);
  ("C.F_Black",F_Black);
  ("C.F_Red",F_Red);
  ("C.F_Green",F_Green);
  ("C.F_Yellow",F_Yellow);
  ("C.F_Blue",F_Blue);
  ("C.F_Magenta",F_Magenta);
  ("C.F_Cyan",F_Cyan);
  ("C.F_Gray",F_Gray);
  ("C.F_Default",F_Default);
  ("C.G_Black",G_Black);
  ("C.G_Red",G_Red);
  ("C.G_Green",G_Green);
  ("C.G_Yellow",G_Yellow);
  ("C.G_Blue",G_Blue);
  ("C.G_Magenta",G_Magenta);
  ("C.G_Cyan",G_Cyan);
  ("C.G_Gray",G_Gray);
  ("C.G_Default",G_Default);
  ("C.F_Black_B",F_Black_B);
  ("C.F_Red_B",F_Red_B);
  ("C.F_Green_B",F_Green_B);
  ("C.F_Yellow_B",F_Yellow_B);
  ("C.F_Blue_B",F_Blue_B);
  ("C.F_Magenta_B",F_Magenta_B);
  ("C.F_Cyan_B",F_Cyan_B);
  ("C.F_Gray_B",F_Gray_B);
  ("C.G_Black_B",G_Black_B);
  ("C.G_Red_B",G_Red_B);
  ("C.G_Green_B",G_Green_B);
  ("C.G_Yellow_B",G_Yellow_B);
  ("C.G_Blue_B",G_Blue_B);
  ("C.G_Magenta_B",G_Magenta_B);
  ("C.G_Cyan_B",G_Cyan_B);
  ("C.G_Gray_B",G_Gray_B)]


let rreset = ref true
let reset = (:=) rreset

let ddisable = ref true
let disable = (:=) ddisable

let new_stack () = 
  let q = Stack.create () in
    Stack.push "" q;q

let q = new_stack ()

let rec list_pretty char  = function
  |[] -> ""
  | [a] -> a
  | a::l -> Printf.sprintf "%s%c%s" a char (list_pretty char l)

let gen l = 
  (Printf.sprintf "[%sm" 
     (list_pretty ';' 
	(List.map  (fun x -> string_of_int (fst (assoc_style x))) l)))
    
let _sstart q l = 
  let s = gen l in
  Stack.push s q; if !ddisable then "" else s

let sstart = _sstart q
  
let start l = Printf.printf "%s" (_sstart q l)
let format_start l = Format.printf "@<0>%s" (_sstart q l)
let fstartf ff l = Format.fprintf ff "@<0>%s" (_sstart q l)

(*let sstop_gen l = let s = "[m"^(!ddefault)^(gen l) in
if !ddisable then "" else s;;*)

let _sstop q = 
  ignore(Stack.pop q);
  let s = "[m"^(Stack.top q) in if !ddisable then "" else s

let sstop () = _sstop q

let stop () = Printf.printf "%s" (_sstop q)
let format_stop () = Format.printf "@<0>%s" (_sstop q)
let fstopf ff = Format.fprintf ff "@<0>%s" (_sstop q)
  
let add_to_format_tag formatter =
  let q = new_stack () in
  let old_fs = Format.get_formatter_tag_functions () in
  let mark_open_tag s = try 
    _sstart q [(M.find s tag_map)] 
  with Not_found -> old_fs.Format.mark_open_tag s in
  let mark_close_tag s = 
    if M.mem s tag_map then _sstop q else old_fs.Format.mark_close_tag s 
  in
  Format.pp_set_formatter_tag_functions formatter
    {old_fs with Format.mark_open_tag = mark_open_tag; 
       Format.mark_close_tag = mark_close_tag}
    (* From ocamlbuild display.ml *)
    
let get_columns () =
  try
        int_of_string (input_line (Unix.open_process_in  "tput cols"))
  with
    | Failure _ -> 80
	
let set_margin_with_term_width formatter =
  Format.pp_set_margin formatter (get_columns ())
    

(* Just some tools *)
let rec print_list sep print_ele fmt = function
  |[] -> ()
  |[a] -> print_ele fmt a
  |a::l -> 
     Format.fprintf fmt "%a %s %a" print_ele a sep (print_list sep print_ele) l
       
(* Pour l'extrieur *)
end
include (IMPLEMENTATION : INTERFACE)
end
and Options: sig
#0 "options.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

val fmt : Format.formatter
val file : string ref

val parse_only : bool
val type_only : bool
val stopb : int
val stepsb : int
val age_limite : int
val notriggers : bool
val debug : bool
val debug_cc : bool
val debug_use : bool
val debug_uf : bool
val debug_fm : bool
val debug_sum : bool
val debug_arith : bool
val debug_bitv : bool
val debug_ac : bool
val debug_sat : bool
val debug_sat_simple : bool
val debug_typing : bool
val debug_constr : bool
val debug_pairs : bool
val debug_arrays : bool
val debug_combine : bool
val verbose : bool
val debug_dispatch : bool
val tracefile :string
val smtfile :bool ref
val smt2file :bool ref
val satmode : bool ref
val bjmode : bool
val glouton : bool
val triggers_var : bool
val redondance : int
val astuce : bool
val select : int
val cin : in_channel
val no_rm_eq_existential : bool
val nocontracongru : bool
val omega : bool
val arrays : bool
val pairs : bool
val term_like_pp : bool
val debug_types : bool
val all_models : bool
val smt_arrays : bool
val goal_directed : bool
val bouclage : int
val max_split : Num.num
val rewriting : bool
val proof : bool
val debug_proof : bool
val debug_split : bool
end = struct
let _ = Printf.fprintf stderr "Executing options.ml\n%!"module type INTERFACE = sig
#0 "options.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

val fmt : Format.formatter
val file : string ref

val parse_only : bool
val type_only : bool
val stopb : int
val stepsb : int
val age_limite : int
val notriggers : bool
val debug : bool
val debug_cc : bool
val debug_use : bool
val debug_uf : bool
val debug_fm : bool
val debug_sum : bool
val debug_arith : bool
val debug_bitv : bool
val debug_ac : bool
val debug_sat : bool
val debug_sat_simple : bool
val debug_typing : bool
val debug_constr : bool
val debug_pairs : bool
val debug_arrays : bool
val debug_combine : bool
val verbose : bool
val debug_dispatch : bool
val tracefile :string
val smtfile :bool ref
val smt2file :bool ref
val satmode : bool ref
val bjmode : bool
val glouton : bool
val triggers_var : bool
val redondance : int
val astuce : bool
val select : int
val cin : in_channel
val no_rm_eq_existential : bool
val nocontracongru : bool
val omega : bool
val arrays : bool
val pairs : bool
val term_like_pp : bool
val debug_types : bool
val all_models : bool
val smt_arrays : bool
val goal_directed : bool
val bouclage : int
val max_split : Num.num
val rewriting : bool
val proof : bool
val debug_proof : bool
val debug_split : bool
end
module IMPLEMENTATION = struct
#0 "options.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

(*let fmt = Format.std_formatter*)
let fmt = Format.err_formatter
let _ = 
  Format.pp_set_tags fmt true;
  Print_color.add_to_format_tag fmt

let usage = "usage: alt-ergo [options] file.<mlw|smt>"

let bouclage = ref 1
let smt_arrays = ref false
let rewriting = ref false
let type_only = ref false
let parse_only = ref false
let stopb = ref 8
let stepsb = ref (-1)
let age_limite = ref 10
let debug = ref false
let notriggers = ref false
let dcc = ref false
let duse = ref false
let darrays = ref false
let duf = ref false
let dsat = ref false
let dsats = ref false
let dtyping = ref false
let dconstr = ref false
let dpairs = ref false
let verbose = ref false
let dfm = ref false
let dsum = ref false
let darith = ref false
let dcombine = ref false
let dbitv = ref false
let dac = ref false
let ddispatch = ref false
let debug_split = ref false
let options = ref false
let tracefile = ref ""
let smtfile = ref false
let smt2file = ref false
let satmode = ref false
let bjmode = ref false
let glouton = ref false
let triggers_var = ref false
let redondance = ref 2
let astuce = ref false
let select = ref 0
let no_rm_eq_existential = ref false
let nocontracongru = ref false
let omega = ref false
let arrays = ref false
let pairs = ref false
let term_like_pp = ref false
let types = ref false 
let all_models = ref false
let goal_directed = ref false
let proof = ref false
let debug_proof = ref false
let max_split = ref (Num.Int 1000000)

let show_version () = Format.printf "Alt-Ergo %s@." Version.version; exit 0

let set_max_split s = max_split := Num.num_of_string s

let spec = [
  "-rwt", Arg.Set rewriting, " use rewriting instead of axiomatic approach";
  "-parse-only", Arg.Set parse_only, " stop after parsing";
  "-smt-arrays", Arg.Set smt_arrays, " uses select/store symbols for Arrays";
  "-type-only", Arg.Set type_only , " stop after typing";
  "-notriggers", Arg.Set notriggers, "  trigger inference";
  "-debug", Arg.Set debug, "  sets the debugging flag";
  "-dcc", Arg.Set dcc, "  sets the debugging flag of cc";
  "-duse", Arg.Set duse, "  sets the debugging flag of use";
  "-duf", Arg.Set duf, "  sets the debugging flag of uf";
  "-dfm", Arg.Set dfm, "  sets the debugging flag of Fourier-Moutzkin";
  "-dsum", Arg.Set dsum, "  sets the debugging flag of Sum";
  "-darith", Arg.Set darith, " sets the debugging flag of Arith (without fm)";
  "-dbitv", Arg.Set dbitv, "  sets the debugging flag of bitv";
  "-dac", Arg.Set dac, "  sets the debugging flag of ac";
  "-dsat", Arg.Set dsat, "  sets the debugging flag of sat";
  "-dsats", Arg.Set dsats, "  sets the debugging flag of sat (simple output)";
  "-dtyping", Arg.Set dtyping, "  sets the debugging flag of typing";
  "-types", Arg.Set types, "  sets the debugging flag of types";
  "-dconstr", Arg.Set dconstr, "  sets the debugging flag of constructors";
  "-dpairs", Arg.Set dpairs, "  sets the debugging flag of pairs";
  "-darrays", Arg.Set darrays, "  sets the debugging flag of arrays";
  "-dcombine", Arg.Set dcombine, "  sets the debugging flag of combine";
  "-dsplit", Arg.Set debug_split, "  sets the debugging flag of case-split analysis";
   "-v", Arg.Set verbose, "  sets the verbose mode";
  "-version", Arg.Unit show_version, "  prints the version number";
  "-ddispatch", Arg.Set ddispatch, "  sets the debugging flag of sat";
  "-stop", Arg.Set_int stopb, " <n> set the stop bound";
  "-steps", Arg.Set_int stepsb, " <n> set the maximum number of steps";
  "-age-limite", Arg.Set_int age_limite, " <n> set the age limite bound";
  "-sat" , Arg.Set satmode , " mode sat/unsat";
  "-bj" , Arg.Set bjmode , " mode sat/unsat";
  "-glouton" , Arg.Set glouton, 
  " use ground terms in non-instanciated lemmas";
  "-redondance" , Arg.Set_int redondance, 
  " number of redondant (multi)triggers (2 by default)";
  "-select" , Arg.Set_int select, 
  "k tries to select relevant (at level k) hypotheses for each goal";
  "-triggers-var" , Arg.Set triggers_var , " allows variables as triggers";
  "-cctrace", Arg.Set_string tracefile, 
  " <file> set output file for cc trace ";
  "-no-rm-eq-existential", Arg.Set no_rm_eq_existential, " does not substitute a variable in an existential when an equality gives the value of the variable";
  "-astuce" , Arg.Set astuce, "";
  "-color" , 
  Arg.Unit (fun () -> Print_color.set_margin_with_term_width fmt;
              Print_color.disable false), "Set ainsi color in output";
  "-nocontracongru", Arg.Set nocontracongru, "";
  "-omega", Arg.Set omega, "Use omega for arithmetic equalities";
  "-arrays", Arg.Set arrays, "experimental support for the theory of arrays";
  "-pairs", Arg.Set pairs, "experimental support for the theory of pairs";
  "-term-like-pp", Arg.Set term_like_pp, "Output semantic values as terms";
  "-all-models", Arg.Set all_models, "experimental support for model";
  "-proof", Arg.Set proof, "experimental support for succint proof";
  "-debug-proof", Arg.Set debug_proof, "experimental support for succint proof";
  "-goal-directed", Arg.Set goal_directed,
  " instantiate lemmas only with the terms from the goal";
  "-bouclage", Arg.Set_int bouclage,
  " number of instantiations at each matching round";
  "-max-split", Arg.String set_max_split,
  (Format.sprintf " maximum size of case-split (default value : %s)" 
     (Num.string_of_num !max_split));

]

let file = ref " stdin"
let cin =
  let ofile = ref None in
  let set_file s =
    if Filename.check_suffix s ".mlw" || Filename.check_suffix s ".why"
    then ofile := Some s
    else
      if Filename.check_suffix s ".smt"
      then begin 
	smtfile := true ; ofile := Some s
      end
      else
	if Filename.check_suffix s ".smt2"
	then begin 
	  smt2file := true ; ofile := Some s
	end
      else raise (Arg.Bad "no .mlw, .smt or smt2 extension");
  in
  Arg.parse spec set_file usage;
  match !ofile with Some f -> file := f ; open_in f 
    | None -> 	smtfile := true ; stdin

let type_only = ! type_only
let parse_only = ! parse_only
let stopb = !stopb
let stepsb = !stepsb
let age_limite = !age_limite
let notriggers = !notriggers
let debug = !debug
let debug_cc = !dcc
let debug_use = !duse
let debug_uf = !duf
let debug_fm = !dfm
let debug_sum = !dsum
let debug_arith = !darith
let debug_bitv = !dbitv
let debug_ac   = !dac
let debug_sat = !dsat
let debug_sat_simple = !dsats
let debug_typing = !dtyping
let debug_constr = !dconstr
let debug_pairs = !dpairs
let verbose = !verbose
let debug_dispatch = !ddispatch
let tracefile = !tracefile
let bjmode = !bjmode
let glouton = !glouton
let triggers_var = !triggers_var
let redondance = !redondance
let astuce = !astuce
let select = !select
let no_rm_eq_existential = !no_rm_eq_existential
let nocontracongru = !nocontracongru
let omega = !omega
let arrays = !arrays
let pairs = !pairs
let term_like_pp = !term_like_pp || true
let debug_arrays = !darrays
let debug_types = !types
let all_models = !all_models
let debug_combine = !dcombine
let smt_arrays = ! smt_arrays
let goal_directed = !goal_directed
let bouclage = ! bouclage
let max_split = !max_split
let rewriting = !rewriting
let proof = !proof
let debug_proof = !debug_proof && proof
let debug_split = !debug_split
end
include (IMPLEMENTATION : INTERFACE)
end
and Loc: sig
#0 "loc.mli"
val report : Lexing.position * Lexing.position -> unit
end = struct
let _ = Printf.fprintf stderr "Executing loc.ml\n%!"module type INTERFACE = sig
#0 "loc.mli"
val report : Lexing.position * Lexing.position -> unit
end
module IMPLEMENTATION = struct
#0 "loc.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Format
open Lexing
open Options

let report (b,e) =
  let l = b.pos_lnum in
  let fc = b.pos_cnum - b.pos_bol + 1 in
  let lc = e.pos_cnum - b.pos_bol + 1 in
  printf "File \"%s\", line %d, characters %d-%d:" !file l fc lc
end
include (IMPLEMENTATION : INTERFACE)
end
and Hashcons: sig
#0 "hashcons.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

(*
 * hashcons: hash tables for hash consing
 * Copyright (C) 2000 Jean-Christophe FILLIATRE
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License version 2, as published by the Free Software Foundation.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * See the GNU Library General Public License version 2 for more details
 * (enclosed in the file LGPL).
 *)

(*s Hash tables for hash consing. 

    Hash consed values are of the
    following type [hash_consed]. The field [tag] contains a unique
    integer (for values hash consed with the same table). The field
    [hkey] contains the hash key of the value (without modulo) for
    possible use in other hash tables (and internally when hash
    consing tables are resized). The field [node] contains the value
    itself. 

    Hash consing tables are using weak pointers, so that values that are no
    more referenced from anywhere else can be erased by the GC. *)

type 'a hash_consed = private { 
  hkey : int;
  tag : int;
  node : 'a }

(*s Generic part, using ocaml generic equality and hash function. *)

type 'a t

val create : int -> 'a t
  (** [create n] creates an empty table of initial size [n]. The table
      will grow as needed. *)  
val clear : 'a t -> unit
  (** Removes all elements from the table. *)
val hashcons : 'a t -> 'a -> 'a hash_consed
  (** [hashcons t n] hash-cons the value [n] using table [t] i.e. returns
      any existing value in [t] equal to [n], if any; otherwise, allocates
      a new one hash-consed value of node [n] and returns it. 
      As a consequence the returned value is physically equal to
      any equal value already hash-consed using table [t]. *)
val iter : ('a hash_consed -> unit) -> 'a t -> unit
  (** [iter f t] iterates [f] over all elements of [t]. *)
val stats : 'a t -> int * int * int * int * int * int
  (** Return statistics on the table.  The numbers are, in order:
      table length, number of entries, sum of bucket lengths,
      smallest bucket length, median bucket length, biggest bucket length. *)

(*s Functorial interface. *) 

module type HashedType =
  sig
    type t
    val equal : t -> t -> bool
    val hash : t -> int
  end

module type S =
  sig
    type key
    type t
    val create : int -> t
    val clear : t -> unit
    val hashcons : t -> key -> key hash_consed
    val iter : (key hash_consed -> unit) -> t -> unit
    val stats : t -> int * int * int * int * int * int
  end

module Make(H : HashedType) : (S with type key = H.t)
end = struct
let _ = Printf.fprintf stderr "Executing hashcons.ml\n%!"module type INTERFACE = sig
#0 "hashcons.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

(*
 * hashcons: hash tables for hash consing
 * Copyright (C) 2000 Jean-Christophe FILLIATRE
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License version 2, as published by the Free Software Foundation.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * See the GNU Library General Public License version 2 for more details
 * (enclosed in the file LGPL).
 *)

(*s Hash tables for hash consing. 

    Hash consed values are of the
    following type [hash_consed]. The field [tag] contains a unique
    integer (for values hash consed with the same table). The field
    [hkey] contains the hash key of the value (without modulo) for
    possible use in other hash tables (and internally when hash
    consing tables are resized). The field [node] contains the value
    itself. 

    Hash consing tables are using weak pointers, so that values that are no
    more referenced from anywhere else can be erased by the GC. *)

type 'a hash_consed = private { 
  hkey : int;
  tag : int;
  node : 'a }

(*s Generic part, using ocaml generic equality and hash function. *)

type 'a t

val create : int -> 'a t
  (** [create n] creates an empty table of initial size [n]. The table
      will grow as needed. *)  
val clear : 'a t -> unit
  (** Removes all elements from the table. *)
val hashcons : 'a t -> 'a -> 'a hash_consed
  (** [hashcons t n] hash-cons the value [n] using table [t] i.e. returns
      any existing value in [t] equal to [n], if any; otherwise, allocates
      a new one hash-consed value of node [n] and returns it. 
      As a consequence the returned value is physically equal to
      any equal value already hash-consed using table [t]. *)
val iter : ('a hash_consed -> unit) -> 'a t -> unit
  (** [iter f t] iterates [f] over all elements of [t]. *)
val stats : 'a t -> int * int * int * int * int * int
  (** Return statistics on the table.  The numbers are, in order:
      table length, number of entries, sum of bucket lengths,
      smallest bucket length, median bucket length, biggest bucket length. *)

(*s Functorial interface. *) 

module type HashedType =
  sig
    type t
    val equal : t -> t -> bool
    val hash : t -> int
  end

module type S =
  sig
    type key
    type t
    val create : int -> t
    val clear : t -> unit
    val hashcons : t -> key -> key hash_consed
    val iter : (key hash_consed -> unit) -> t -> unit
    val stats : t -> int * int * int * int * int * int
  end

module Make(H : HashedType) : (S with type key = H.t)
end
module IMPLEMENTATION = struct
#0 "hashcons.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

(*
 * hashcons: hash tables for hash consing
 * Copyright (C) 2000 Jean-Christophe FILLIATRE
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License version 2, as published by the Free Software Foundation.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * See the GNU Library General Public License version 2 for more details
 * (enclosed in the file LGPL).
 *)

(*s Hash tables for hash-consing. (Some code is borrowed from the ocaml
    standard library, which is copyright 1996 INRIA.) *)

type 'a hash_consed = { 
  hkey : int;
  tag : int;
  node : 'a }

let gentag =
  let r = ref 0 in
  fun () -> incr r; !r

type 'a t = {
  mutable table : 'a hash_consed Weak.t array;
  mutable totsize : int;             (* sum of the bucket sizes *)
  mutable limit : int;               (* max ratio totsize/table length *)
}

let create sz =
  let sz = if sz < 7 then 7 else sz in
  let sz = if sz > Sys.max_array_length then Sys.max_array_length else sz in
  let emptybucket = Weak.create 0 in
  { table = Array.create sz emptybucket;
    totsize = 0;
    limit = 3; }

let clear t =
  let emptybucket = Weak.create 0 in
  for i = 0 to Array.length t.table - 1 do t.table.(i) <- emptybucket done;
  t.totsize <- 0;
  t.limit <- 3
  
let fold f t init =
  let rec fold_bucket i b accu =
    if i >= Weak.length b then accu else
      match Weak.get b i with
	| Some v -> fold_bucket (i+1) b (f v accu)
	| None -> fold_bucket (i+1) b accu
  in
  Array.fold_right (fold_bucket 0) t.table init

let iter f t =
  let rec iter_bucket i b =
    if i >= Weak.length b then () else
      match Weak.get b i with
	| Some v -> f v; iter_bucket (i+1) b
	| None -> iter_bucket (i+1) b
  in
  Array.iter (iter_bucket 0) t.table

let count t =
  let rec count_bucket i b accu =
    if i >= Weak.length b then accu else
      count_bucket (i+1) b (accu + (if Weak.check b i then 1 else 0))
  in
  Array.fold_right (count_bucket 0) t.table 0

let next_sz n = min (3*n/2 + 3) (Sys.max_array_length - 1)

let rec resize t =
  let oldlen = Array.length t.table in
  let newlen = next_sz oldlen in
  if newlen > oldlen then begin
    let newt = create newlen in
    newt.limit <- t.limit + 100;          (* prevent resizing of newt *)
    fold (fun d () -> add newt d) t ();
    t.table <- newt.table;
    t.limit <- t.limit + 2;
  end

and add t d =
  let index = d.hkey mod (Array.length t.table) in
  let bucket = t.table.(index) in
  let sz = Weak.length bucket in
  let rec loop i =
    if i >= sz then begin
      let newsz = min (sz + 3) (Sys.max_array_length - 1) in
      if newsz <= sz then 
	failwith "Hashcons.Make: hash bucket cannot grow more";
      let newbucket = Weak.create newsz in
      Weak.blit bucket 0 newbucket 0 sz;
      Weak.set newbucket i (Some d);
      t.table.(index) <- newbucket;
      t.totsize <- t.totsize + (newsz - sz);
      if t.totsize > t.limit * Array.length t.table then resize t;
    end else begin
      if Weak.check bucket i
      then loop (i+1)
      else Weak.set bucket i (Some d)
    end
  in
  loop 0

let hashcons t d =
  let hkey = Hashtbl.hash d in
  let index = hkey mod (Array.length t.table) in
  let bucket = t.table.(index) in
  let sz = Weak.length bucket in
  let rec loop i =
    if i >= sz then begin
      let hnode = { hkey = hkey; tag = gentag (); node = d } in
      add t hnode;
      hnode
    end else begin
      match Weak.get_copy bucket i with
        | Some v when v.node = d -> 
	    begin match Weak.get bucket i with
              | Some v -> v
              | None -> loop (i+1)
            end
        | _ -> loop (i+1)
    end
  in
  loop 0
  
let stats t =
  let len = Array.length t.table in
  let lens = Array.map Weak.length t.table in
  Array.sort compare lens;
  let totlen = Array.fold_left ( + ) 0 lens in
  (len, count t, totlen, lens.(0), lens.(len/2), lens.(len-1))


(* Functorial interface *)

module type HashedType =
  sig
    type t
    val equal : t -> t -> bool
    val hash : t -> int
  end

module type S =
  sig
    type key
    type t
    val create : int -> t
    val clear : t -> unit
    val hashcons : t -> key -> key hash_consed
    val iter : (key hash_consed -> unit) -> t -> unit
    val stats : t -> int * int * int * int * int * int
  end

module Make(H : HashedType) : (S with type key = H.t) = struct

  type key = H.t

  type data = H.t hash_consed

  type t = {
    mutable table : data Weak.t array;
    mutable totsize : int;             (* sum of the bucket sizes *)
    mutable limit : int;               (* max ratio totsize/table length *)
  }

  let emptybucket = Weak.create 0

  let create sz =
    let sz = if sz < 7 then 7 else sz in
    let sz = if sz > Sys.max_array_length then Sys.max_array_length else sz in
    {
      table = Array.create sz emptybucket;
      totsize = 0;
      limit = 3;
    }

  let clear t =
    for i = 0 to Array.length t.table - 1 do
      t.table.(i) <- emptybucket
    done;
    t.totsize <- 0;
    t.limit <- 3
  
  let fold f t init =
    let rec fold_bucket i b accu =
      if i >= Weak.length b then accu else
      match Weak.get b i with
      | Some v -> fold_bucket (i+1) b (f v accu)
      | None -> fold_bucket (i+1) b accu
    in
    Array.fold_right (fold_bucket 0) t.table init

  let iter f t =
    let rec iter_bucket i b =
      if i >= Weak.length b then () else
      match Weak.get b i with
      | Some v -> f v; iter_bucket (i+1) b
      | None -> iter_bucket (i+1) b
    in
    Array.iter (iter_bucket 0) t.table

  let count t =
    let rec count_bucket i b accu =
      if i >= Weak.length b then accu else
      count_bucket (i+1) b (accu + (if Weak.check b i then 1 else 0))
    in
    Array.fold_right (count_bucket 0) t.table 0

  let next_sz n = min (3*n/2 + 3) (Sys.max_array_length - 1)

  let rec resize t =
    let oldlen = Array.length t.table in
    let newlen = next_sz oldlen in
    if newlen > oldlen then begin
      let newt = create newlen in
      newt.limit <- t.limit + 100;          (* prevent resizing of newt *)
      fold (fun d () -> add newt d) t ();
      t.table <- newt.table;
      t.limit <- t.limit + 2;
    end

  and add t d =
    let index = d.hkey mod (Array.length t.table) in
    let bucket = t.table.(index) in
    let sz = Weak.length bucket in
    let rec loop i =
      if i >= sz then begin
        let newsz = min (sz + 3) (Sys.max_array_length - 1) in
        if newsz <= sz then 
	  failwith "Hashcons.Make: hash bucket cannot grow more";
        let newbucket = Weak.create newsz in
        Weak.blit bucket 0 newbucket 0 sz;
        Weak.set newbucket i (Some d);
        t.table.(index) <- newbucket;
        t.totsize <- t.totsize + (newsz - sz);
        if t.totsize > t.limit * Array.length t.table then resize t;
      end else begin
        if Weak.check bucket i
        then loop (i+1)
        else Weak.set bucket i (Some d)
      end
    in
    loop 0

  let hashcons t d =
    let hkey = H.hash d in
    let index = hkey mod (Array.length t.table) in
    let bucket = t.table.(index) in
    let sz = Weak.length bucket in
    let rec loop i =
      if i >= sz then begin
	let hnode = { hkey = hkey; tag = gentag (); node = d } in
	add t hnode;
	hnode
      end else begin
        match Weak.get_copy bucket i with
        | Some v when H.equal v.node d -> 
	    begin match Weak.get bucket i with
              | Some v -> v
              | None -> loop (i+1)
            end
        | _ -> loop (i+1)
      end
    in
    loop 0
  
  let stats t =
    let len = Array.length t.table in
    let lens = Array.map Weak.length t.table in
    Array.sort compare lens;
    let totlen = Array.fold_left ( + ) 0 lens in
    (len, count t, totlen, lens.(0), lens.(len/2), lens.(len-1))
  
end
end
include (IMPLEMENTATION : INTERFACE)
end
and Hstring: sig
#0 "hstring.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Hashcons 

type t = string hash_consed

val make : string -> t

val view : t -> string

val equal : t -> t -> bool

val compare : t -> t -> int

val hash : t -> int

val empty : t 
end = struct
let _ = Printf.fprintf stderr "Executing hstring.ml\n%!"module type INTERFACE = sig
#0 "hstring.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Hashcons 

type t = string hash_consed

val make : string -> t

val view : t -> string

val equal : t -> t -> bool

val compare : t -> t -> int

val hash : t -> int

val empty : t 
end
module IMPLEMENTATION = struct
#0 "hstring.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Hashcons

module S = 
  Hashcons.Make(struct include String 
		       let hash = Hashtbl.hash 
		       let equal = (=)     end)

type t = string Hashcons.hash_consed

let htable = S.create 17

let make s = S.hashcons htable s

let view s = s.node

let equal s1 s2 = s1.tag = s2.tag

let compare s1 s2 = compare s1.tag s2.tag

let hash s = s.tag

let empty = make ""
end
include (IMPLEMENTATION : INTERFACE)
end
and Builtin: sig
#0 "builtin.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

val is_builtin : string -> Hstring.t
end = struct
let _ = Printf.fprintf stderr "Executing builtin.ml\n%!"module type INTERFACE = sig
#0 "builtin.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

val is_builtin : string -> Hstring.t
end
module IMPLEMENTATION = struct
#0 "builtin.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

let symbols = Hashtbl.create 97
let () = 
  List.iter 
    (fun (x,y) -> Hashtbl.add symbols x y) 
       [ "<=", Hstring.make "<="; 
         "<", Hstring.make "<" ]


let is_builtin = Hashtbl.find symbols
end
include (IMPLEMENTATION : INTERFACE)
end
and Symbols: sig
#0 "symbols.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type operator = 
    Plus | Minus | Mult | Div | Modulo | Concat | Extract | Get | Set

type name_kind = Ac | Constructor | Other

type t = 
  | True 
  | False
  | Void
  | Name of Hstring.t * name_kind
  | Int of Hstring.t
  | Real of Hstring.t
  | Bitv of string
  | Op of operator
  | Var of Hstring.t

val name : ?kind:name_kind -> string -> t
val var : string -> t
val underscoring : t -> t
val int : string -> t
val real : string -> t

val is_ac : t -> bool

val equal : t -> t -> bool
val compare : t -> t -> int
val hash : t -> int

val to_string : t -> string
val print : Format.formatter -> t -> unit

val dummy : t

val fresh : string -> t
  
val is_get : t -> bool 
val is_set : t -> bool 


module Map : Map.S with type key = t
module Set : Set.S with type elt = t

end = struct
let _ = Printf.fprintf stderr "Executing symbols.ml\n%!"module type INTERFACE = sig
#0 "symbols.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type operator = 
    Plus | Minus | Mult | Div | Modulo | Concat | Extract | Get | Set

type name_kind = Ac | Constructor | Other

type t = 
  | True 
  | False
  | Void
  | Name of Hstring.t * name_kind
  | Int of Hstring.t
  | Real of Hstring.t
  | Bitv of string
  | Op of operator
  | Var of Hstring.t

val name : ?kind:name_kind -> string -> t
val var : string -> t
val underscoring : t -> t
val int : string -> t
val real : string -> t

val is_ac : t -> bool

val equal : t -> t -> bool
val compare : t -> t -> int
val hash : t -> int

val to_string : t -> string
val print : Format.formatter -> t -> unit

val dummy : t

val fresh : string -> t
  
val is_get : t -> bool 
val is_set : t -> bool 


module Map : Map.S with type key = t
module Set : Set.S with type elt = t

end
module IMPLEMENTATION = struct
#0 "symbols.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Hashcons

type operator = 
    Plus | Minus | Mult | Div | Modulo 
  | Concat | Extract | Get | Set

type name_kind = Ac | Constructor | Other

type t = 
  | True 
  | False
  | Void
  | Name of Hstring.t * name_kind
  | Int of Hstring.t
  | Real of Hstring.t
  | Bitv of string
  | Op of operator
  | Var of Hstring.t

let name ?(kind=Other) s = Name (Hstring.make s, kind)
let var s = Var (Hstring.make s)
let int i = Int (Hstring.make i)
let real r = Real (Hstring.make r)

let is_ac = function
  | Name(_, Ac) -> true
  | _           -> false

let underscoring = function
    Var s -> Var (Hstring.make ("$"^Hstring.view s))
  | _ -> assert false

let compare_kind k1 k2 = match k1, k2 with
  | Ac   , Ac    -> 0
  | Ac   , _     -> 1
  | _    , Ac    -> -1
  | Other, Other -> 0
  | Other, _     -> 1
  | _    , Other -> -1
  | Constructor, Constructor -> 0

let compare s1 s2 =  match s1,s2 with
  | Name (n1,k1) , Name (n2,k2) -> 
      let c = compare_kind k1 k2 in
      if c = 0 then Hstring.compare n1 n2 else c
  | Name _ , _ ->  -1
  | _ , Name _ -> 1
  | Var n1 , Var n2 -> Hstring.compare n1 n2
  | Var _ , _ -> -1
  | _ , Var _ -> 1
  | Int i1 , Int i2 -> Hstring.compare i1 i2
  | Int _ , _ -> -1
  | _ , Int _ -> 1
  | _  -> Pervasives.compare s1 s2
  
let equal s1 s2 = compare s1 s2 = 0

let hash = function
  | Name (n,Ac) -> Hstring.hash n * 19 + 1
  | Name (n,_) -> Hstring.hash n * 19
  | Var n (*| Int n*) -> Hstring.hash n * 19 + 1
  | s -> Hashtbl.hash s
	
let to_string =  function
  | Name (n,_) -> Hstring.view n
  | Var x -> (Hstring.view x)
  | Int n -> Hstring.view n
  | Real n -> Hstring.view n
  | Bitv s -> "[|"^s^"|]"
  | Op Plus -> "+" 
  | Op Minus -> "-" 
  | Op Mult -> "*"
  | Op Div -> "/"
  | Op Modulo -> "%"
  | True -> "true"
  | False -> "false"
  | Void -> "void"
  | _ -> "" (*assert false*)

let print fmt s = Format.fprintf fmt "%s" (to_string s)

let dummy = Name (Hstring.make "_one", Other)

let fresh = 
  let cpt = ref 0 in
  fun s -> incr cpt; name (Format.sprintf "__%s%i" s (!cpt))

let is_get f = equal f (Op Get) 
let is_set f = equal f (Op Set)


module Map =
  Map.Make(struct type t' = t type t=t' let compare=compare end)

module Set = 
  Set.Make(struct type t' = t type t=t' let compare=compare end)

end
include (IMPLEMENTATION : INTERFACE)
end
and Subst: sig
#0 "subst.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type +'a t = 'a Symbols.Map.t

module type PRINT_TYPE = sig
  type t
  val print : Format.formatter -> t -> unit
end

module type S = sig
  type elt

  include Map.S with type key = Symbols.t and type 'a t = 'a t

  val print : Format.formatter -> elt t -> unit
end

module Make (X : PRINT_TYPE) : S with type elt = X.t


end = struct
let _ = Printf.fprintf stderr "Executing subst.ml\n%!"module type INTERFACE = sig
#0 "subst.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type +'a t = 'a Symbols.Map.t

module type PRINT_TYPE = sig
  type t
  val print : Format.formatter -> t -> unit
end

module type S = sig
  type elt

  include Map.S with type key = Symbols.t and type 'a t = 'a t

  val print : Format.formatter -> elt t -> unit
end

module Make (X : PRINT_TYPE) : S with type elt = X.t


end
module IMPLEMENTATION = struct
#0 "subst.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Format

type +'a t = 'a Symbols.Map.t

module type PRINT_TYPE = sig
  type t
  val print : Format.formatter -> t -> unit
end

module type S = sig
  type elt

  include Map.S with type key = Symbols.t and type 'a t = 'a t

  val print : Format.formatter -> elt t -> unit
end



module Make(X : PRINT_TYPE) = struct
  include Symbols.Map 

  type elt  = X.t

  let print fmt = 
    iter (fun k v -> fprintf fmt "%a -> %a  " Symbols.print k X.print v)

end


end
include (IMPLEMENTATION : INTERFACE)
end
and Ty: sig
#0 "ty.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type t = 
    | Tint
    | Treal
    | Tbool
    | Tunit
    | Tvar of tvar
    | Tbitv of int
    | Text of t list * Hstring.t
    | Tfarray of t * t
    | Tsum of Hstring.t * Hstring.t list

and tvar = { v : int ; mutable value : t option }

type subst

val esubst : subst

exception TypeClash of t*t

val tunit : t

val text : t list -> string -> t
val tsum : string -> string list -> t

val shorten : t -> t

val fresh_var : unit -> tvar
val fresh_empty_text : unit -> t

val equal : t -> t -> bool
val hash : t -> int
val compare : t -> t -> int

val unify : t -> t -> unit
val matching : subst -> t -> t -> subst

val apply_subst : subst -> t -> t

(* Applique la seconde substitution sur la premiere 
   puis fais l'union des map avec priorite  la premire *)
val union_subst : subst -> subst -> subst

val compare_subst : subst -> subst -> int

val print : Format.formatter -> t -> unit
val printl : Format.formatter -> t list -> unit

module Svty : Set.S

val vty_of : t -> Svty.t

val monomorphize: t -> t

val print_subst: Format.formatter -> subst -> unit
end = struct
let _ = Printf.fprintf stderr "Executing ty.ml\n%!"module type INTERFACE = sig
#0 "ty.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type t = 
    | Tint
    | Treal
    | Tbool
    | Tunit
    | Tvar of tvar
    | Tbitv of int
    | Text of t list * Hstring.t
    | Tfarray of t * t
    | Tsum of Hstring.t * Hstring.t list

and tvar = { v : int ; mutable value : t option }

type subst

val esubst : subst

exception TypeClash of t*t

val tunit : t

val text : t list -> string -> t
val tsum : string -> string list -> t

val shorten : t -> t

val fresh_var : unit -> tvar
val fresh_empty_text : unit -> t

val equal : t -> t -> bool
val hash : t -> int
val compare : t -> t -> int

val unify : t -> t -> unit
val matching : subst -> t -> t -> subst

val apply_subst : subst -> t -> t

(* Applique la seconde substitution sur la premiere 
   puis fais l'union des map avec priorite  la premire *)
val union_subst : subst -> subst -> subst

val compare_subst : subst -> subst -> int

val print : Format.formatter -> t -> unit
val printl : Format.formatter -> t list -> unit

module Svty : Set.S

val vty_of : t -> Svty.t

val monomorphize: t -> t

val print_subst: Format.formatter -> subst -> unit
end
module IMPLEMENTATION = struct
#0 "ty.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

module type INTERFACE = sig

(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type t =
    | Tint
    | Treal
    | Tbool
    | Tunit
    | Tvar of tvar
    | Tbitv of int
    | Text of t list * Hstring.t
    | Tfarray of t * t
    | Tsum of Hstring.t * Hstring.t list

and tvar = { v : int ; mutable value : t option }

type subst

val esubst : subst

exception TypeClash of t*t

val tunit : t

val text : t list -> string -> t
val tsum : string -> string list -> t

val shorten : t -> t

val fresh_var : unit -> tvar
val fresh_empty_text : unit -> t

val equal : t -> t -> bool
val hash : t -> int
val compare : t -> t -> int

val unify : t -> t -> unit
val matching : subst -> t -> t -> subst

val apply_subst : subst -> t -> t

(* Applique la seconde substitution sur la premiere
   puis fais l'union des map avec priorite  la premire *)
val union_subst : subst -> subst -> subst

val compare_subst : subst -> subst -> int

val print : Format.formatter -> t -> unit
val printl : Format.formatter -> t list -> unit

module Svty : Set.S

val vty_of : t -> Svty.t

val monomorphize: t -> t

val print_subst: Format.formatter -> subst -> unit

end

module IMPLEMENTATION = struct

open Hashcons
open Format

type t =
    | Tint
    | Treal
    | Tbool
    | Tunit
    | Tvar of tvar
    | Tbitv of int
    | Text of t list * Hstring.t
    | Tfarray of t * t
    | Tsum of Hstring.t * Hstring.t list


and tvar = { v : int ; mutable value : t option }

exception TypeClash of t*t
exception Shorten of t

(* smart constructors *)

let tunit = Text([],Hstring.make "unit")
let text l s = Text(l,Hstring.make s)
let tsum s lc = Tsum(Hstring.make s, List.map Hstring.make lc)

let rec shorten t =
  match t with
  | Tvar {value=None}  -> t
  | Tvar {value=Some(Tvar{value=None} as t')} -> t'
  | Tvar ({value=Some(Tvar t2)} as t1) -> t1.value <- t2.value; shorten t
  | Tvar {value=Some t'} -> shorten t'
  | Text (l,s) -> Text(List.map shorten l,s)
  | Tfarray (t1,t2) -> Tfarray(shorten t1,shorten t2)
  | _ -> t

let fresh_var =
  let cpt = ref (-1) in
  fun () -> incr cpt; {v= !cpt ; value = None }

let fresh_empty_text =
  let cpt = ref (-1) in
  fun () -> incr cpt; text [] ("'_c"^(string_of_int !cpt))

let rec hash t = match t with
  | Tvar{v=v} -> v
  | Text(l,s) ->
      abs (List.fold_left (fun acc x-> acc*19 + hash x) s.tag l)
  | Tfarray (t1,t2) -> 19 * (hash t1) + 23 * (hash t2)
  | Tsum (s, _) ->
      s.tag
  | _ -> Hashtbl.hash t

let rec equal t1 t2 = match shorten t1 , shorten t2 with
    Tvar{v=v1} , Tvar{v=v2} -> v1 = v2
  | Text(l1,s1) , Text(l2,s2) ->
      (try s1.tag = s2.tag && List.for_all2 equal l1 l2
       with Invalid_argument _ -> false)
  | Tfarray (ta1,ta2), Tfarray (tb1,tb2) -> equal ta1 tb1 && equal ta2 tb2
  | Tsum(s1,_) , Tsum(s2,_) -> s1.tag = s2.tag
  | t1 , t2 -> t1 = t2

let rec compare t1 t2 = match shorten t1 , shorten t2 with
    Tvar{v=v1} , Tvar{v=v2} -> Pervasives.compare v1 v2
  | Text(l1, s1) , Text(l2, s2) ->
      let c = Hstring.compare s1 s2 in
      if c<>0 then c
      else compare_list l1 l2
  | Tfarray (ta1,ta2), Tfarray (tb1,tb2) ->
    let c = compare ta1 tb1 in
      if c<>0 then c
      else compare ta2 tb2
  | Tsum(s1, _), Tsum(s2, _) ->
      Hstring.compare s1 s2
  | t1 , t2 -> Pervasives.compare t1 t2
and compare_list l1 l2 = match l1, l2 with
  | [] , [] -> 0
  | [] , _ -> -1
  | _ , [] -> 1
  | x::ll1 , y::ll2 ->
      let c = compare x y in
      if c<>0 then c else compare_list ll1 ll2

let occurs {v=n} t =
  let rec occursrec = function
      Tvar {v=m} -> n=m
    | Text(l,_) -> List.exists occursrec l
    | Tfarray (t1,t2) -> occursrec t1 || occursrec t2
    | _ -> false
  in occursrec t

(*** destructive unification ***)
let rec unify t1 t2 =
  let t1 = shorten t1 in
  let t2 = shorten t2 in
  match t1 , t2 with
      Tvar ({v=n;value=None} as tv1), Tvar {v=m;value=None} ->
	if n<>m then tv1.value <- Some t2
    | _ ,  Tvar ({value=None} as tv) ->
	if (occurs tv t1) then raise (TypeClash(t1,t2));
	tv.value <- Some t1
    | Tvar ({value=None} as tv) , _ ->
	  if (occurs tv t2) then raise (TypeClash(t1,t2));
	tv.value <- Some t2
    | Text(l1,s1) , Text(l2,s2) when Hstring.equal s1 s2 ->
	List.iter2 unify l1 l2
    | Tfarray (ta1,ta2), Tfarray (tb1,tb2) -> unify ta1 tb1;unify ta2 tb2
    | Tsum(s1, _) , Tsum(s2, _) when Hstring.equal s1 s2 -> ()
    | Tint, Tint | Tbool, Tbool | Treal, Treal | Tunit, Tunit -> ()
    | Tbitv n , Tbitv m when m=n -> ()
    | _ , _ -> raise (TypeClash(t1,t2))


(*** matching with a substitution mechanism ***)
module M = Map.Make(struct type t=int let compare = Pervasives.compare end)
type subst = t M.t

let esubst = M.empty

let rec matching s pat t =
  match pat , t with
    | Tvar {v=n;value=None} , _ ->
	(try if not (equal (M.find n s) t) then raise (TypeClash(pat,t)); s
	 with Not_found -> M.add n t s)
    | Tvar {value=_}, _ -> raise (Shorten pat)
    | Text (l1,s1) , Text (l2,s2) when Hstring.equal s1 s2 ->
	List.fold_left2 matching s l1 l2
    | Tfarray (ta1,ta2), Tfarray (tb1,tb2) ->
	matching (matching s ta1 tb1) ta2 tb2
    | Tsum (s1, _), Tsum (s2, _) when Hstring.equal s1 s2 -> s
    | Tint , Tint | Tbool , Tbool | Treal , Treal | Tunit, Tunit -> s
    | Tbitv n , Tbitv m when n=m -> s
    | _ , _ -> raise (TypeClash(pat,t))

let rec apply_subst s = function
  | Tvar {v=n} as t -> (try M.find n s with Not_found -> t)
  | Text (l,e) -> Text(List.map (apply_subst s) l,e)
  | Tfarray (t1,t2) -> Tfarray (apply_subst s t1,apply_subst s t2)
  | t -> t

let union_subst s1 s2 =
  M.fold (fun k x s2 -> M.add k x s2) (M.map (apply_subst s2)  s1) s2

let compare_subst = M.compare Pervasives.compare

(*** pretty print ***)
let rec print fmt = function
  | Tint -> fprintf fmt "int"
  | Treal -> fprintf fmt "real"
  | Tbool -> fprintf fmt "bool"
  | Tunit -> fprintf fmt "unit"
  | Tbitv n -> fprintf fmt "bitv[%d]" n
  | Tvar{v=v ; value = None} -> fprintf fmt "'a_%d" v
  | Tvar{v=v ; value = Some t} -> print fmt t
    (* fprintf fmt "('a_%d->%a)" v print t *)
  | Text(l,s) -> fprintf fmt "%a%s" printl l (Hstring.view s)
  | Tfarray (t1,t2) -> fprintf fmt "(%a,%a) farray" print t1 print t2
  | Tsum(s, _) -> fprintf fmt "%s" (Hstring.view s)

and printl fmt = function
    [] -> ()
  | [t] -> fprintf fmt "%a " print t
  | t::l -> fprintf fmt "%a,%a" print t printl l


module Svty =
  Set.Make(struct type t = int let compare = Pervasives.compare end)


let vty_of t =
  let rec vty_of_rec acc t =
    let t = shorten t in
    match t with
      | Tvar { v = i ; value = None } -> Svty.add i acc
      | Text(l,_) -> List.fold_left vty_of_rec acc l
      | Tfarray (t1,t2) -> vty_of_rec (vty_of_rec acc t1) t2
      | _ -> acc
  in
  vty_of_rec Svty.empty t

let rec monomorphize ty = match ty with
  | Tint | Treal | Tbool | Tunit   | Tbitv _  | Tsum _ -> ty
  | Text (tyl,hs) -> Text (List.map monomorphize tyl, hs)
  | Tfarray (ty1,ty2)    -> Tfarray (monomorphize ty1,monomorphize ty2)
  | Tvar {v=v; value=None} -> text [] ("'_c"^(string_of_int v))
  | Tvar {value=Some ty} -> monomorphize ty


let print_subst fmt sbt =
  M.iter (fun n ty -> fprintf fmt "%d -> %a" n print ty) sbt;
  fprintf fmt "@?";

end

include (IMPLEMENTATION : INTERFACE)
end
include (IMPLEMENTATION : INTERFACE)
end
and Why_ptree : sig
#0 "why_ptree.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type loc = Lexing.position * Lexing.position

type constant =
  | ConstBitv of string
  | ConstInt of string
  | ConstReal of Num.num
  | ConstTrue
  | ConstFalse
  | ConstVoid

type pp_infix = 
  | PPand | PPor | PPimplies | PPiff 
  | PPlt | PPle | PPgt | PPge | PPeq | PPneq
  | PPadd | PPsub | PPmul | PPdiv | PPmod
	  
type pp_prefix = 
  | PPneg | PPnot

type ppure_type =
  | PPTint
  | PPTbool
  | PPTreal
  | PPTunit
  | PPTbitv of int
  | PPTvarid of string * loc
  | PPTexternal of ppure_type list * string * loc
  
type lexpr = 
  { pp_loc : loc; pp_desc : pp_desc }

and pp_desc =
  | PPvar of string
  | PPapp of string * lexpr list
  | PPdistinct of lexpr list
  | PPconst of constant
  | PPinfix of lexpr * pp_infix * lexpr
  | PPprefix of pp_prefix * lexpr
  | PPget of lexpr * lexpr
  | PPset of lexpr * lexpr * lexpr
  | PPextract of lexpr * lexpr * lexpr
  | PPconcat of lexpr * lexpr
  | PPif of lexpr * lexpr * lexpr
  | PPforall of string list * ppure_type * lexpr list list * lexpr
  | PPexists of string list * ppure_type * lexpr
  | PPnamed of string * lexpr
  | PPlet of string * lexpr * lexpr

(* Declarations. *)

type plogic_type =
  | PPredicate of ppure_type list
  | PFunction of ppure_type list * ppure_type

type name_kind = Symbols.name_kind

type decl = 
  | Axiom of loc * string * lexpr
  | Rewriting of loc * string * lexpr list
  | Goal of loc * string * lexpr
  | Logic of loc * name_kind * string list * plogic_type
  | Predicate_def of loc * string * (loc * string * ppure_type) list * lexpr
  | Function_def 
      of loc * string * (loc * string * ppure_type) list * ppure_type * lexpr
  | TypeDecl of loc * string list * string * string list

type file = decl list

(*** typed ast *)

type ('a, 'b) annoted =
    { c : 'a;
      annot : 'b }

type tconstant =
  | Tint of string
  | Treal of Num.num
  | Tbitv of string
  | Ttrue
  | Tfalse
  | Tvoid

type 'a tterm = 
    { tt_ty : Ty.t; tt_desc : 'a tt_desc }
and 'a tt_desc = 
  | TTconst of tconstant
  | TTvar of Symbols.t
  | TTinfix of ('a tterm, 'a) annoted * Symbols.t * ('a tterm, 'a) annoted
  | TTprefix of Symbols.t * ('a tterm, 'a) annoted 
  | TTapp of Symbols.t * ('a tterm, 'a) annoted list
  | TTget of ('a tterm, 'a) annoted * ('a tterm, 'a) annoted
  | TTset of 
      ('a tterm, 'a) annoted * ('a tterm, 'a) annoted * ('a tterm, 'a) annoted
  | TTextract of 
      ('a tterm, 'a) annoted * ('a tterm, 'a) annoted * ('a tterm, 'a) annoted
  | TTconcat of ('a tterm, 'a) annoted * ('a tterm, 'a) annoted
  | TTlet of Symbols.t * ('a tterm, 'a) annoted * ('a tterm, 'a) annoted

type 'a tatom = 
  | TAtrue
  | TAfalse
  | TAeq of ('a tterm, 'a) annoted list
  | TAdistinct of ('a tterm, 'a) annoted list
  | TAneq of ('a tterm, 'a) annoted list
  | TAle of ('a tterm, 'a) annoted list
  | TAlt of ('a tterm, 'a) annoted list
  | TApred of ('a tterm, 'a) annoted
  | TAbuilt of Hstring.t * ('a tterm, 'a) annoted list

type 'a oplogic = 
    OPand |OPor | OPimp | OPnot | OPiff 
  | OPif of ('a tterm, 'a) annoted

type 'a quant_form = {       
  (* quantified variables that appear in the formula *)
  qf_bvars : (Symbols.t * Ty.t) list ;
  qf_upvars : (Symbols.t * Ty.t) list ;
  qf_triggers : ('a tterm, 'a) annoted list list ;
  qf_form : ('a tform, 'a) annoted
}

and 'a tform =
  | TFatom of ('a tatom, 'a) annoted
  | TFop of 'a oplogic * (('a tform, 'a) annoted) list
  | TFforall of 'a quant_form
  | TFexists of 'a quant_form
  | TFlet of (Symbols.t * Ty.t) list * Symbols.t * 
      ('a tterm, 'a) annoted * ('a tform, 'a) annoted
  | TFnamed of Hstring.t * ('a tform, 'a) annoted


type 'a rwt_rule = {
  rwt_vars : (Symbols.t * Ty.t) list;
  rwt_left : 'a;
  rwt_right : 'a
}

type 'a tdecl = 
  | TAxiom of loc * string * ('a tform, 'a) annoted
  | TRewriting of loc * string * (('a tterm, 'a) annoted rwt_rule) list
  | TGoal of loc * string * ('a tform, 'a) annoted
  | TLogic of loc * string list * plogic_type
  | TPredicate_def of 
      loc * string * (string * ppure_type) list * ('a tform, 'a) annoted
  | TFunction_def of 
      loc * string * (string * ppure_type) list * 
	ppure_type * ('a tform, 'a) annoted
  | TTypeDecl of loc * string list * string * string list


(* Sat entry *)

type sat_decl_aux = 
  | Assume of Formula.t * bool 
  | PredDef of Formula.t
  | RwtDef of (Term.t rwt_rule) list
  | Query of string * Formula.t * Literal.LT.t list

type sat_tdecl = {
  st_loc : loc;
  st_decl : sat_decl_aux
}
end = struct
#0 "why_ptree.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type loc = Lexing.position * Lexing.position

type constant =
  | ConstBitv of string
  | ConstInt of string
  | ConstReal of Num.num
  | ConstTrue
  | ConstFalse
  | ConstVoid

type pp_infix = 
  | PPand | PPor | PPimplies | PPiff 
  | PPlt | PPle | PPgt | PPge | PPeq | PPneq
  | PPadd | PPsub | PPmul | PPdiv | PPmod
	  
type pp_prefix = 
  | PPneg | PPnot

type ppure_type =
  | PPTint
  | PPTbool
  | PPTreal
  | PPTunit
  | PPTbitv of int
  | PPTvarid of string * loc
  | PPTexternal of ppure_type list * string * loc
  
type lexpr = 
  { pp_loc : loc; pp_desc : pp_desc }

and pp_desc =
  | PPvar of string
  | PPapp of string * lexpr list
  | PPdistinct of lexpr list
  | PPconst of constant
  | PPinfix of lexpr * pp_infix * lexpr
  | PPprefix of pp_prefix * lexpr
  | PPget of lexpr * lexpr
  | PPset of lexpr * lexpr * lexpr
  | PPextract of lexpr * lexpr * lexpr
  | PPconcat of lexpr * lexpr
  | PPif of lexpr * lexpr * lexpr
  | PPforall of string list * ppure_type * lexpr list list * lexpr
  | PPexists of string list * ppure_type * lexpr
  | PPnamed of string * lexpr
  | PPlet of string * lexpr * lexpr

(* Declarations. *)

type plogic_type =
  | PPredicate of ppure_type list
  | PFunction of ppure_type list * ppure_type

type name_kind = Symbols.name_kind

type decl = 
  | Axiom of loc * string * lexpr
  | Rewriting of loc * string * lexpr list
  | Goal of loc * string * lexpr
  | Logic of loc * name_kind * string list * plogic_type
  | Predicate_def of loc * string * (loc * string * ppure_type) list * lexpr
  | Function_def 
      of loc * string * (loc * string * ppure_type) list * ppure_type * lexpr
  | TypeDecl of loc * string list * string * string list

type file = decl list

(*** typed ast *)

type ('a, 'b) annoted =
    { c : 'a;
      annot : 'b }

type tconstant =
  | Tint of string
  | Treal of Num.num
  | Tbitv of string
  | Ttrue
  | Tfalse
  | Tvoid

type 'a tterm = 
    { tt_ty : Ty.t; tt_desc : 'a tt_desc }
and 'a tt_desc = 
  | TTconst of tconstant
  | TTvar of Symbols.t
  | TTinfix of ('a tterm, 'a) annoted * Symbols.t * ('a tterm, 'a) annoted
  | TTprefix of Symbols.t * ('a tterm, 'a) annoted 
  | TTapp of Symbols.t * ('a tterm, 'a) annoted list
  | TTget of ('a tterm, 'a) annoted * ('a tterm, 'a) annoted
  | TTset of 
      ('a tterm, 'a) annoted * ('a tterm, 'a) annoted * ('a tterm, 'a) annoted
  | TTextract of 
      ('a tterm, 'a) annoted * ('a tterm, 'a) annoted * ('a tterm, 'a) annoted
  | TTconcat of ('a tterm, 'a) annoted * ('a tterm, 'a) annoted
  | TTlet of Symbols.t * ('a tterm, 'a) annoted * ('a tterm, 'a) annoted

type 'a tatom = 
  | TAtrue
  | TAfalse
  | TAeq of ('a tterm, 'a) annoted list
  | TAdistinct of ('a tterm, 'a) annoted list
  | TAneq of ('a tterm, 'a) annoted list
  | TAle of ('a tterm, 'a) annoted list
  | TAlt of ('a tterm, 'a) annoted list
  | TApred of ('a tterm, 'a) annoted
  | TAbuilt of Hstring.t * ('a tterm, 'a) annoted list

type 'a oplogic = 
    OPand |OPor | OPimp | OPnot | OPiff 
  | OPif of ('a tterm, 'a) annoted

type 'a quant_form = {       
  (* quantified variables that appear in the formula *)
  qf_bvars : (Symbols.t * Ty.t) list ;
  qf_upvars : (Symbols.t * Ty.t) list ;
  qf_triggers : ('a tterm, 'a) annoted list list ;
  qf_form : ('a tform, 'a) annoted
}

and 'a tform =
  | TFatom of ('a tatom, 'a) annoted
  | TFop of 'a oplogic * (('a tform, 'a) annoted) list
  | TFforall of 'a quant_form
  | TFexists of 'a quant_form
  | TFlet of (Symbols.t * Ty.t) list * Symbols.t * 
      ('a tterm, 'a) annoted * ('a tform, 'a) annoted
  | TFnamed of Hstring.t * ('a tform, 'a) annoted


type 'a rwt_rule = {
  rwt_vars : (Symbols.t * Ty.t) list;
  rwt_left : 'a;
  rwt_right : 'a
}

type 'a tdecl = 
  | TAxiom of loc * string * ('a tform, 'a) annoted
  | TRewriting of loc * string * (('a tterm, 'a) annoted rwt_rule) list
  | TGoal of loc * string * ('a tform, 'a) annoted
  | TLogic of loc * string list * plogic_type
  | TPredicate_def of 
      loc * string * (string * ppure_type) list * ('a tform, 'a) annoted
  | TFunction_def of 
      loc * string * (string * ppure_type) list * 
	ppure_type * ('a tform, 'a) annoted
  | TTypeDecl of loc * string list * string * string list


(* Sat entry *)

type sat_decl_aux = 
  | Assume of Formula.t * bool 
  | PredDef of Formula.t
  | RwtDef of (Term.t rwt_rule) list
  | Query of string * Formula.t * Literal.LT.t list

type sat_tdecl = {
  st_loc : loc;
  st_decl : sat_decl_aux
}
end
and Common: sig
#0 "common.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

type error = 
  | BitvExtract of int*int
  | BitvExtractRange of int*int
  | ClashType of string
  | ClashParam of string
  | TypeBadArityDecl
  | UnknownType of string
  | WrongArity of string * int
  | SymbAlreadyDefined of string 
  | SymbUndefined of string
  | NotAPropVar of string
  | NotAPredicate of string
  | Unification of Ty.t * Ty.t
  | ShouldBeApply of string
  | WrongNumberofArgs of string
  | ShouldHaveType of Ty.t * Ty.t
  | ShouldHaveTypeIntorReal of Ty.t
  | ShouldHaveTypeInt of Ty.t
  | ShouldHaveTypeBitv of Ty.t
  | ArrayIndexShouldHaveTypeInt
  | ShouldHaveTypeArray
  | ShouldHaveTypeProp
  | Notrigger 
  | CannotGeneralize
  | SyntaxError

exception Error of error * loc
exception Warning of error * loc

val report : Format.formatter -> error -> unit
val error : error -> loc -> 'a
val warning : error -> loc -> 'a

val print_term : Format.formatter -> ('a tterm, 'a) annoted -> unit
val print_formula : Format.formatter -> ('a tform, 'a) annoted 
  -> unit
val print_binders : Format.formatter -> (Symbols.t * Ty.t) list -> unit
val print_triggers : Format.formatter -> ('a tterm, 'a) annoted list list 
  -> unit
val fresh_string : unit -> string
end = struct
let _ = Printf.fprintf stderr "Executing common.ml\n%!"module type INTERFACE = sig
#0 "common.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

type error = 
  | BitvExtract of int*int
  | BitvExtractRange of int*int
  | ClashType of string
  | ClashParam of string
  | TypeBadArityDecl
  | UnknownType of string
  | WrongArity of string * int
  | SymbAlreadyDefined of string 
  | SymbUndefined of string
  | NotAPropVar of string
  | NotAPredicate of string
  | Unification of Ty.t * Ty.t
  | ShouldBeApply of string
  | WrongNumberofArgs of string
  | ShouldHaveType of Ty.t * Ty.t
  | ShouldHaveTypeIntorReal of Ty.t
  | ShouldHaveTypeInt of Ty.t
  | ShouldHaveTypeBitv of Ty.t
  | ArrayIndexShouldHaveTypeInt
  | ShouldHaveTypeArray
  | ShouldHaveTypeProp
  | Notrigger 
  | CannotGeneralize
  | SyntaxError

exception Error of error * loc
exception Warning of error * loc

val report : Format.formatter -> error -> unit
val error : error -> loc -> 'a
val warning : error -> loc -> 'a

val print_term : Format.formatter -> ('a tterm, 'a) annoted -> unit
val print_formula : Format.formatter -> ('a tform, 'a) annoted 
  -> unit
val print_binders : Format.formatter -> (Symbols.t * Ty.t) list -> unit
val print_triggers : Format.formatter -> ('a tterm, 'a) annoted list list 
  -> unit
val fresh_string : unit -> string
end
module IMPLEMENTATION = struct
#0 "common.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree
open Format

type error = 
  | BitvExtract of int*int
  | BitvExtractRange of int*int
  | ClashType of string
  | ClashParam of string
  | TypeBadArityDecl
  | UnknownType of string
  | WrongArity of string * int
  | SymbAlreadyDefined of string 
  | SymbUndefined of string
  | NotAPropVar of string
  | NotAPredicate of string
  | Unification of Ty.t * Ty.t
  | ShouldBeApply of string
  | WrongNumberofArgs of string
  | ShouldHaveType of Ty.t * Ty.t
  | ShouldHaveTypeIntorReal of Ty.t
  | ShouldHaveTypeInt of Ty.t
  | ShouldHaveTypeBitv of Ty.t
  | ArrayIndexShouldHaveTypeInt
  | ShouldHaveTypeArray
  | ShouldHaveTypeProp
  | Notrigger 
  | CannotGeneralize
  | SyntaxError

exception Error of error * loc
exception Warning of error * loc

let report fmt = function
  | BitvExtract(i,j) -> 
      fprintf fmt "bitvector extraction malformed (%d>%d)" i j
  | BitvExtractRange(n,j) -> 
      fprintf fmt "extraction out of range (%d>%d)" j n
  | ClashType s -> 
      fprintf fmt "the type %s is already defined" s
  | ClashParam s -> 
      fprintf fmt "parameter %s is bound twice" s
  | CannotGeneralize -> 
      fprintf fmt "cannot generalize the type of this expression"
  | TypeBadArityDecl -> 
      fprintf fmt "bad arity declaration"
  | UnknownType s -> 
      fprintf fmt "unknown type %s" s
  | WrongArity(s,n) -> 
      fprintf fmt "the type %s has %d arguments" s n
  | SymbAlreadyDefined s -> 
      fprintf fmt "the symbol %s is already defined" s
  | SymbUndefined s -> 
      fprintf fmt "undefined symbol %s" s
  | NotAPropVar s -> 
      fprintf fmt "%s is not a propositional variable" s
  | NotAPredicate s -> 
      fprintf fmt "%s is not a predicate" s
  | Unification(t1,t2) ->
      fprintf fmt "%a and %a cannot be unified" Ty.print t1 Ty.print t2
  | ShouldBeApply s -> 
      fprintf fmt "%s is a function symbol, it should be apply" s
  | WrongNumberofArgs s ->
      fprintf fmt "Wrong number of arguments when applying %s" s
  | ShouldHaveType(ty1,ty2) ->
      fprintf fmt "this expression has type %a but is here used with type %a"
	Ty.print ty1 Ty.print ty2
  | ShouldHaveTypeBitv t -> 
      fprintf fmt "this expression has type %a but it should be a bitvector"
	Ty.print t
  | ShouldHaveTypeIntorReal t ->
      fprintf fmt 
	"this expression has type %a but it should have type int or real"
	Ty.print t
  | ShouldHaveTypeInt t ->
      fprintf fmt 
	"this expression has type %a but it should have type int"
	Ty.print t
  | ShouldHaveTypeArray ->
      fprintf fmt "this expression should have type farray"
  | ShouldHaveTypeProp -> 
      fprintf fmt "this expression should have type prop"
  | ArrayIndexShouldHaveTypeInt -> 
      fprintf fmt "index of arrays should hava type int"
  | Notrigger -> 
      fprintf fmt "No trigger for this lemma"
  | SyntaxError -> 
      fprintf fmt "syntax error"

let error e l = raise (Error(e,l))
let warning e l = raise (Warning(e,l))

let rec print_term fmt t = match t.c.tt_desc with
  | TTconst Ttrue -> 
      fprintf fmt "true"
  | TTconst Tfalse -> 
      fprintf fmt "false"
  | TTconst Tvoid -> 
      fprintf fmt "void"
  | TTconst (Tint n) -> 
      fprintf fmt "%s" n
  | TTconst (Treal n) -> 
      fprintf fmt "%s" (Num.string_of_num n)
  | TTconst Tbitv s -> 
      fprintf fmt "%s" s
  | TTvar s -> 
      fprintf fmt "%a" Symbols.print s
  | TTapp(s,l) -> 
      fprintf fmt "%a(%a)" Symbols.print s print_term_list l
  | TTinfix(t1,s,t2) -> 
      fprintf fmt "%a %a %a" print_term t1 Symbols.print s print_term t2
  | TTprefix (s, t') ->
      fprintf fmt "%a %a" Symbols.print s print_term t'
  | TTget (t1, t2) ->
      fprintf fmt "%a[%a]" print_term t1 print_term t2
  | TTset (t1, t2, t3) ->
      fprintf fmt "%a[%a<-%a]" print_term t1 print_term t2 print_term t3
  | TTextract (t1, t2, t3) ->
      fprintf fmt "%a^{%a,%a}" print_term t1 print_term t2 print_term t3
  | TTconcat (t1, t2) ->
      fprintf fmt "%a @ %a" print_term t1 print_term t2
  | TTlet (s, t1, t2) ->
      fprintf fmt "let %a=%a in %a" Symbols.print s print_term t1 print_term t2

and print_term_list fmt = List.iter (fprintf fmt "%a," print_term)

let print_atom fmt a = 
    match a.c with
      | TAtrue ->
	  fprintf fmt "True"
      | TAfalse ->
	  fprintf fmt "True"
      | TAeq [t1; t2] -> 
	  fprintf fmt "%a = %a" print_term t1 print_term t2
      | TAneq [t1; t2] ->
	  fprintf fmt "%a <> %a" print_term t1 print_term t2
      | TAle [t1; t2] ->
	  fprintf fmt "%a <= %a" print_term t1 print_term t2
      | TAlt [t1; t2] ->
	  fprintf fmt "%a < %a" print_term t1 print_term t2
      | TApred t -> 
	  print_term fmt t
      | TAbuilt(s, l) ->
	  fprintf fmt "%s(%a)" (Hstring.view s) print_term_list l
      | _ -> assert false

let string_of_op = function
  | OPand -> "and"
  | OPor -> "or"
  | OPimp -> "->"
  | OPiff -> "<->"
  | _ -> assert false

let print_binder fmt (s, t) =
  fprintf fmt "%a:%a" Symbols.print s Ty.print t

let print_binders fmt l = 
  List.iter (fun c -> fprintf fmt "%a, " print_binder c) l

let print_triggers fmt ll = 
  List.iter (fun l -> fprintf fmt "%a | " print_term_list l) ll
 
let rec print_formula fmt f = 
  match f.c with
  | TFatom a -> 
      print_atom fmt a
  | TFop(OPnot, [f]) -> 
      fprintf fmt "not %a" print_formula f
  | TFop(OPif(t), [f1;f2]) -> 
      fprintf fmt "if %a then %a else %a" 
	print_term t print_formula f1 print_formula f2
  | TFop(op, [f1; f2]) -> 
      fprintf fmt "%a %s %a" print_formula f1 (string_of_op op) print_formula f2

  | TFforall {qf_bvars = l; qf_triggers = t; qf_form = f} -> 
      fprintf fmt "forall %a [%a]. %a" 
	print_binders l print_triggers t print_formula f
  | _ -> assert false

and print_form_list fmt = List.iter (fprintf fmt "%a" print_formula)

let fresh_string = 
  let cpt = ref 0 in
  fun () ->
    incr cpt;
    "!k" ^ (string_of_int !cpt)


end
include (IMPLEMENTATION : INTERFACE)
end
and Term: sig
#0 "term.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type t
type view = private {f: Symbols.t ; xs: t list; ty: Ty.t}

type subst = t Subst.t * Ty.subst

val view : t -> view
val make : Symbols.t -> t list -> Ty.t -> t

val shorten : t -> t

val vrai : t
val faux : t
val void : t

val int : string -> t
val real : string -> t
val bitv : string -> Ty.t -> t

val fresh_name : Ty.t -> t

val is_int : t -> bool
val is_real : t -> bool

val compare : t -> t -> int
val equal : t -> t -> bool
val hash : t -> int

val vars_of : t -> Symbols.Set.t
val vty_of : t -> Ty.Svty.t

val pred : t -> t

val apply_subst : subst -> t -> t
val compare_subst : subst -> subst -> int
val fold_subst_term : (Symbols.t -> t -> 'b -> 'b) -> subst -> 'b -> 'b

val union_subst : subst -> subst -> subst

val print : Format.formatter -> t -> unit
val print_list : Format.formatter -> t list -> unit

val dummy : t 

module Map : Map.S with type key = t
module Set : Set.S with type elt = t
 
val subterms : Set.t -> t -> Set.t
end = struct
let _ = Printf.fprintf stderr "Executing term.ml\n%!"module type INTERFACE = sig
#0 "term.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type t
type view = private {f: Symbols.t ; xs: t list; ty: Ty.t}

type subst = t Subst.t * Ty.subst

val view : t -> view
val make : Symbols.t -> t list -> Ty.t -> t

val shorten : t -> t

val vrai : t
val faux : t
val void : t

val int : string -> t
val real : string -> t
val bitv : string -> Ty.t -> t

val fresh_name : Ty.t -> t

val is_int : t -> bool
val is_real : t -> bool

val compare : t -> t -> int
val equal : t -> t -> bool
val hash : t -> int

val vars_of : t -> Symbols.Set.t
val vty_of : t -> Ty.Svty.t

val pred : t -> t

val apply_subst : subst -> t -> t
val compare_subst : subst -> subst -> int
val fold_subst_term : (Symbols.t -> t -> 'b -> 'b) -> subst -> 'b -> 'b

val union_subst : subst -> subst -> subst

val print : Format.formatter -> t -> unit
val print_list : Format.formatter -> t list -> unit

val dummy : t 

module Map : Map.S with type key = t
module Set : Set.S with type elt = t
 
val subterms : Set.t -> t -> Set.t
end
module IMPLEMENTATION = struct
#0 "term.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Format
open Hashcons

module Sy = Symbols

type view = {f: Sy.t ; xs: t list; ty: Ty.t}
and t = view hash_consed

type subst = t Subst.t * Ty.subst
    
module H = struct
  type t = view
  let equal t1 t2 = try
    Sy.equal t1.f t2.f 
    && List.for_all2 (==) t1.xs t2.xs 
    && Ty.equal t1.ty t2.ty
  with Invalid_argument _ -> false
      
  let hash t =
    abs (List.fold_left 
	   (fun acc x-> acc*19 +x.tag) (Sy.hash t.f + Ty.hash t.ty) 
	   t.xs)
end

module T = Make(H)
  
let tbl = T.create 100007
  
let view t = t.node

(* fresh variables must be smaller than problem's variables.
   thus, Instead of comparinf t1.tag with t2.tag, 
   we compare t2.tag and t1.tag
   But we keep true and false as repr
 *)
let compare t1 t2 =
  let c = Pervasives.compare t2.tag t1.tag in
  if c = 0 then c else
  match (view t1).f, (view t2).f with
    | (Sy.True | Sy.False ), _ -> -1
    | _, (Sy.True | Sy.False ) -> 1
    | _,_ -> c

let sort = List.sort compare

let make s l ty = T.hashcons tbl {f=s;xs=l;ty=ty}

let fresh_name ty = make (Sy.name (Common.fresh_string())) [] ty

let shorten t = 
  let {f=f;xs=xs;ty=ty} = view t in
  T.hashcons tbl {f=f;xs=xs;ty=Ty.shorten ty}

let vrai = make (Sy.True) [] Ty.Tbool
let faux = make (Sy.False) [] Ty.Tbool
let void = make (Sy.Void) [] Ty.Tunit

let int i = make (Sy.int i) [] Ty.Tint
let real r = make (Sy.real r) [] Ty.Treal
let bitv bt ty = make (Sy.Bitv bt) [] ty

let rec print fmt t = 
  let {f=x;xs=l;ty=ty} = view t in
  match x, l with
    | Sy.Op Sy.Get, [e1; e2] ->
	fprintf fmt "%a[%a]" print e1 print e2

    | Sy.Op Sy.Set, [e1; e2; e3] ->
	fprintf fmt "%a[%a<-%a]" print e1 print e2 print e3

    | Sy.Op Sy.Concat, [e1; e2] ->
	fprintf fmt "%a@@%a" print e1 print e2

    | Sy.Op Sy.Extract, [e1; e2; e3] ->
	fprintf fmt "%a^{%a,%a}" print e1 print e2 print e3

    | Sy.Op op, [e1; e2] -> 
	fprintf fmt "(%a %a %a)" print e1 Sy.print x print e2

    | _, [] -> 
        if Options.debug then
          fprintf fmt "%a:%a" Sy.print x Ty.print ty
        else
          fprintf fmt "%a" Sy.print x
          
    | _, _ ->
        if Options.debug then 
          fprintf fmt "%a(%a):%a" Sy.print x print_list l Ty.print ty
        else 
          fprintf fmt "%a(%a)" Sy.print x print_list l

and print_list fmt = function
  | [] -> ()
  | [t] -> print fmt t
  | t::l -> Format.fprintf fmt "%a,%a" print t print_list l

let is_int t = (view t).ty= Ty.Tint
let is_real t = (view t).ty= Ty.Treal
      
let equal t1 t2 =  t1.tag == t2.tag
  
let hash t = t.tag
  
let pred t = make (Sy.Op Sy.Minus) [t;int "1"] Ty.Tint
  
let dummy = make Sy.dummy [] Ty.Tint
  (* verifier que ce type est correct et voir si on ne peut pas
  supprimer ce dummy*)
  
let vars_of = 
  let rec vars_of s t = 
    match view t with
	{ f=(Sy.Var _ as v);xs=[]} -> Sy.Set.add v s
      | {xs=l} -> List.fold_left vars_of s l
  in fun t -> vars_of Sy.Set.empty t
    
let vty_of t = 
  let rec vty_of s t = 
    let {xs = xs; ty = ty} = view t in 
    List.fold_left vty_of (Ty.Svty.union s (Ty.vty_of ty)) xs
  in
  vty_of Ty.Svty.empty t

let rec apply_subst ((s_t,s_ty) as s) t = 
  let {f=f;xs=xs;ty=ty} = view t in
  try Sy.Map.find f s_t
  with Not_found -> 
    make f (List.map (apply_subst s) xs) (Ty.apply_subst s_ty ty)

let compare_subst (s_t1, s_ty1) (s_t2, s_ty2) = 
  let c = Ty.compare_subst s_ty1 s_ty2 in
  if c<>0 then c else Sy.Map.compare compare s_t1 s_t2

let fold_subst_term f (s,_) acc = Sy.Map.fold f s acc

let union_subst (s_t1, s_ty1) ((s_t2, s_ty2) as subst) = 
  let s_t = 
    Sy.Map.fold 
      (fun k x s2 -> Sy.Map.add k x s2)
      (Sy.Map.map (apply_subst subst) s_t1) s_t2
  in
  let s_ty = Ty.union_subst s_ty1 s_ty2 in
  s_t, s_ty

module Set = 
  Set.Make(struct type t' = t type t=t' let compare=compare end)
    
module Map = 
  Map.Make(struct type t' = t type t=t' let compare=compare end)


let rec subterms acc t = 
  let {xs=xs} = view t in List.fold_left subterms (Set.add t acc) xs
end
include (IMPLEMENTATION : INTERFACE)
end
and Literal: sig
#0 "literal.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)


module type OrderedType = sig
  type t
  val compare : t -> t -> int
  val hash :  t -> int
  val print : Format.formatter -> t -> unit
end

type 'a view = 
  | Eq of 'a * 'a 
  | Distinct of bool * 'a list
  | Builtin of bool * Hstring.t * 'a list

module type S = sig
  type elt
  type t

  val make : elt view -> t
  val view : t -> elt view

  val neg : t -> t

  val add_label : Hstring.t -> t -> unit
  val label : t -> Hstring.t

  val print : Format.formatter -> t -> unit

  val compare : t -> t -> int
  val equal : t -> t -> bool
  val hash : t -> int

  module Map : Map.S with type key = t
  module Set : Set.S with type elt = t

end

module Make ( X : OrderedType ) : S with type elt = X.t

module type S_Term = sig

  include S with type elt = Term.t

  val mk_pred : Term.t -> t
  val vrai : t
  val faux : t

  val apply_subst : Term.subst -> t -> t

  val terms_of : t -> Term.Set.t
  val vars_of : t -> Symbols.Set.t

end

module LT : S_Term


end = struct
let _ = Printf.fprintf stderr "Executing literal.ml\n%!"module type INTERFACE = sig
#0 "literal.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)


module type OrderedType = sig
  type t
  val compare : t -> t -> int
  val hash :  t -> int
  val print : Format.formatter -> t -> unit
end

type 'a view = 
  | Eq of 'a * 'a 
  | Distinct of bool * 'a list
  | Builtin of bool * Hstring.t * 'a list

module type S = sig
  type elt
  type t

  val make : elt view -> t
  val view : t -> elt view

  val neg : t -> t

  val add_label : Hstring.t -> t -> unit
  val label : t -> Hstring.t

  val print : Format.formatter -> t -> unit

  val compare : t -> t -> int
  val equal : t -> t -> bool
  val hash : t -> int

  module Map : Map.S with type key = t
  module Set : Set.S with type elt = t

end

module Make ( X : OrderedType ) : S with type elt = X.t

module type S_Term = sig

  include S with type elt = Term.t

  val mk_pred : Term.t -> t
  val vrai : t
  val faux : t

  val apply_subst : Term.subst -> t -> t

  val terms_of : t -> Term.Set.t
  val vars_of : t -> Symbols.Set.t

end

module LT : S_Term


end
module IMPLEMENTATION = struct
#0 "literal.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Hashcons

type 'a view = 
  | Eq of 'a * 'a 
  | Distinct of bool * 'a list
  | Builtin of bool * Hstring.t * 'a list

module type OrderedType = sig
  type t
  val compare : t -> t -> int
  val hash :  t -> int
  val print : Format.formatter -> t -> unit
end

module type S = sig
  type elt
  type t

  val make : elt view -> t
  val view : t -> elt view

  val neg : t -> t

  val add_label : Hstring.t -> t -> unit
  val label : t -> Hstring.t

  val print : Format.formatter -> t -> unit

  val compare : t -> t -> int
  val equal : t -> t -> bool
  val hash : t -> int

  module Map : Map.S with type key = t
  module Set : Set.S with type elt = t
    
end

module Make (X : OrderedType) : S with type elt = X.t = struct

  type elt = X.t
  type t = (X.t view) hash_consed

  module V = struct 
    type t = X.t view 
	
    let equal a1 a2 = 
      match a1, a2 with
	| Eq(t1, t2), Eq(u1, u2) -> 
	    X.compare t1 u1 = 0 && X.compare t2 u2 = 0
	| Distinct (b1,lt1), Distinct (b2,lt2) ->
	    (try 
	       b1 = b2 && 
		List.for_all2 (fun x y -> X.compare x y = 0) lt1 lt2
	     with Invalid_argument _ -> false)
	| Builtin(b1, n1, l1), Builtin(b2, n2, l2) -> 
	    (try 
	       b1 = b2 && Hstring.equal n1 n2 
		&& 
		List.for_all2 (fun x y -> X.compare x y = 0) l1 l2
	     with Invalid_argument _ -> false)
	| _ -> false
	    
    let hash a = match a with
      | Eq(t1, t2) -> abs (19 * (X.hash t1 + X.hash t2))
      | Distinct (b,lt) ->
	  let x = if b then 7 else 23 in
	  abs (17 * List.fold_left (fun acc t -> (X.hash t) + acc ) x lt)
      | Builtin(b, n, l) -> 
	  let x = if b then 7 else 23 in
	  abs 
	    (List.fold_left 
	       (fun acc t-> acc*13 + X.hash t) (Hstring.hash n+x) l)
  end

  module H = Make(V)

  let compare a1 a2 = Pervasives.compare a1.tag a2.tag
  let equal a1 a2 = a1.tag = a2.tag
  let hash a1 = a1.tag

  module T = struct 
    type t' = t 
    type t = t' 
    let compare=compare
    let equal = equal
    let hash = hash
  end

  let tbl = H.create 100007
    
  let make t = H.hashcons tbl t
  let view a = a.node

  let neg a = match view a with
    | Eq(x, y) -> make (Distinct (false,[x; y]))
    | Distinct (false, [x; y]) -> make (Eq (x, y))
    | Distinct (true, [x; y]) -> make (Distinct (false,[x; y]))
    | Distinct (false, l) -> make (Distinct (true,l))
    | Distinct _ -> assert false
    | Builtin(b, n, l) -> make (Builtin (not b, n, l))

  module Labels = Hashtbl.Make(T)
    
  let labels = Labels.create 100007
    
  let add_label lbl t = Labels.replace labels t lbl
    
  let label t = try Labels.find labels t with Not_found -> Hstring.empty

  let print_list fmt = function
    | [] -> ()
    | z :: l ->
	Format.fprintf fmt "%a" X.print z;
	List.iter (Format.fprintf fmt ", %a" X.print) l
    
  let print fmt a = 
    let lbl = Hstring.view (label a) in
    let lbl = if lbl = "" then lbl else lbl^":" in
    match view a with
      | Eq (z1, z2) -> 
	  Format.fprintf fmt "%s%a=%a" lbl X.print z1 X.print z2
      | Distinct (b,(z::l)) -> 
	  let b = if b then "" else "~" in
	  Format.fprintf fmt "%s%s%a" lbl b X.print z;
	  List.iter (fun x -> Format.fprintf fmt "<>%a" X.print x) l
      | Builtin (b, n, l) ->
	  let b = if b then "" else "~" in
	  Format.fprintf fmt "%s%s%s(%a)" lbl b (Hstring.view n) print_list l
      | _ -> assert false
    
  module Set = Set.Make(T)
  module Map = Map.Make(T)

end

module type S_Term = sig

  include S with type elt = Term.t

  val mk_pred : Term.t -> t

  val vrai : t
  val faux : t

  val apply_subst : Term.subst -> t -> t

  val terms_of : t -> Term.Set.t
  val vars_of : t -> Symbols.Set.t

(*  module SetEq : Set.S with type elt = t * Term.t * Term.t*)
end

module LT : S_Term = struct

  module L = Make(Term)
  include L

  let mk_pred t = make (Eq (t, Term.vrai) ) 
    
  let vrai = mk_pred Term.vrai
  let faux = mk_pred Term.faux

 let neg a = match view a with
   | Eq(t1, t2) when Term.equal t2 Term.faux -> 
       make (Eq (t1, Term.vrai))
   | Eq(t1, t2) when Term.equal t2 Term.vrai -> 
       make (Eq (t1, Term.faux))
   | _ -> L.neg a

 let apply_subst subst a = 
   let f = Term.apply_subst subst in
   let v = match view a with
     | Eq (t1, t2) -> Eq(f t1, f t2)
     | Distinct (b, lt) -> Distinct (b, List.map f lt)
     | Builtin (b, n, l) -> Builtin(b, n, List.map f l)
   in
   make v

 let terms_of a = 
   let l = match view a with 
     | Eq (t1, t2) -> [t1; t2] 
     | Distinct (_, l) | Builtin (_, _, l) -> l 
   in
   List.fold_left Term.subterms Term.Set.empty l

 module SS = Symbols.Set     
 let vars_of a = 
   Term.Set.fold (fun t -> SS.union (Term.vars_of t)) (terms_of a) SS.empty

end

end
include (IMPLEMENTATION : INTERFACE)
end
and Formula: sig
#0 "formula.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type t

type lemma =
    { qvars: Symbols.Set.t;  (* toplevel quantified variables *)
      triggers : Term.t list list; (* multi-triggers *)
      main : t;  (* the main lemma's formula *)
      name : string; }
      
and llet = {
  let_var: Symbols.t;
  let_subst : Term.subst;
  let_term : Term.t;
  let_f : t;
}

and skolem = {
  sko_subst : Term.subst;
  sko_f : t;
}

and view = 
    Unit of t*t  (* unit clauses *)
  | Clause of t*t      (* a clause (t1 or t2) *)
  | Literal of Literal.LT.t   (* an atom *)
  | Lemma of lemma   (* a lemma *)
  | Skolem of skolem  (* lazy substitution *)
  | Let of llet (* a binding of a term *)

val mk_not : t -> t
val mk_and : t -> t -> int -> t
val mk_or : t -> t -> int -> t
val mk_imp : t -> t -> int -> t
val mk_if : Term.t -> t -> t -> int -> t
val mk_iff : t -> t -> int -> t
val mk_lit : Literal.LT.t -> int -> t
val mk_forall : Term.Set.t -> Term.Set.t -> Term.t list list -> t ->
  string -> int -> t
val mk_exists : Term.Set.t -> Term.Set.t -> Term.t list list -> t ->
  string -> int -> t
val mk_let : Term.Set.t -> Symbols.t -> Term.t -> t -> int -> t

val add_label : Hstring.t -> t -> unit
val label : t -> Hstring.t

val view : t -> view
val size : t -> int
val id : t -> int

val print : Format.formatter -> t -> unit

val terms : t -> Term.Set.t
val free_vars : t -> Symbols.Set.t

val apply_subst : Term.subst -> t -> t 

val compare : t -> t -> int
    
module Set : Set.S with type elt = t
module Map : Map.S with type key = t

end = struct
let _ = Printf.fprintf stderr "Executing formula.ml\n%!"module type INTERFACE = sig
#0 "formula.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type t

type lemma =
    { qvars: Symbols.Set.t;  (* toplevel quantified variables *)
      triggers : Term.t list list; (* multi-triggers *)
      main : t;  (* the main lemma's formula *)
      name : string; }
      
and llet = {
  let_var: Symbols.t;
  let_subst : Term.subst;
  let_term : Term.t;
  let_f : t;
}

and skolem = {
  sko_subst : Term.subst;
  sko_f : t;
}

and view = 
    Unit of t*t  (* unit clauses *)
  | Clause of t*t      (* a clause (t1 or t2) *)
  | Literal of Literal.LT.t   (* an atom *)
  | Lemma of lemma   (* a lemma *)
  | Skolem of skolem  (* lazy substitution *)
  | Let of llet (* a binding of a term *)

val mk_not : t -> t
val mk_and : t -> t -> int -> t
val mk_or : t -> t -> int -> t
val mk_imp : t -> t -> int -> t
val mk_if : Term.t -> t -> t -> int -> t
val mk_iff : t -> t -> int -> t
val mk_lit : Literal.LT.t -> int -> t
val mk_forall : Term.Set.t -> Term.Set.t -> Term.t list list -> t ->
  string -> int -> t
val mk_exists : Term.Set.t -> Term.Set.t -> Term.t list list -> t ->
  string -> int -> t
val mk_let : Term.Set.t -> Symbols.t -> Term.t -> t -> int -> t

val add_label : Hstring.t -> t -> unit
val label : t -> Hstring.t

val view : t -> view
val size : t -> int
val id : t -> int

val print : Format.formatter -> t -> unit

val terms : t -> Term.Set.t
val free_vars : t -> Symbols.Set.t

val apply_subst : Term.subst -> t -> t 

val compare : t -> t -> int
    
module Set : Set.S with type elt = t
module Map : Map.S with type key = t

end
module IMPLEMENTATION = struct
#0 "formula.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Format
open Hashcons
open Options

module T = Term
module Sy = Symbols

type lemma = {
  qvars: Sy.Set.t;
  triggers : T.t list list;
  main : t;
  name : string
}

and llet = {
  let_var: Symbols.t;
  let_subst : Term.subst;
  let_term : Term.t;
  let_f : t;
}

and skolem = {
  sko_subst : Term.subst;
  sko_f : t;
}

and view = 
    Unit of t*t
  | Clause of t*t  
  | Literal of Literal.LT.t
  | Lemma of lemma
  | Skolem of skolem
  | Let of llet

and iview = { pos : view ; neg : view ; size : int}

and t = iview hash_consed * int
    
module View = struct
  type t = iview
      
  let rec compare_list compare l1 l2 = match l1 , l2 with
      [] , [] -> 0
    | [] , _ -> 1
    | _ , [] -> -1
    | x1::l1 , x2::l2 -> 
	let c = compare x1 x2 in 
	if c<>0 then c else compare_list compare l1 l2
	
  let rec compare_pclause v1 v2 = match v1 , v2 with
    | Unit(x1,y1) , Unit(x2,y2) -> 
	  let c = compare_t x1 x2 in if c<>0 then c else compare_t y1 y2
    | Unit _ , _ -> -1
    | _, Unit _ -> 1
    | Clause(x1,y1) , Clause(x2,y2) -> 
	  let c = compare_t x1 x2 in if c<>0 then c else compare_t y1 y2
    | Clause _ , _ -> -1
    | _ , Clause _ -> 1
    | Literal a1 , Literal a2 -> Literal.LT.compare a1 a2
    | Literal _ , _ -> -1
    | _ , Literal _ -> 1
    | Lemma l1 , Lemma l2 ->  compare_lemme l1 l2
    | Lemma _ , _ -> -1
    | _ , Lemma _ -> 1
    | Let l1, Let l2 -> compare_let l1 l2
    | Let _, _ -> -1
    | _, Let _ -> 1
    | Skolem s1 , Skolem s2 -> compare_skolem s1 s2
	
  and compare_t (t1,_) (t2,_)  = Pervasives.compare t1.tag t2.tag
  and compare_view v1 v2 = 
    let c = compare_pclause v1.pos v2.pos in
    if c<>0 then c else compare_pclause v1.neg v2.neg
  and compare_lemme l1 l2 = 
    let c = compare_t l1.main l2.main in
    if c<>0 then c else
      let c = Sy.Set.compare l1.qvars l2.qvars in
      if c<>0 then c else 
	compare_list (compare_list T.compare) l1.triggers l2.triggers
  and compare_skolem s1 s2 = 
    let c = compare_t s1.sko_f s2.sko_f in
    if c<>0 then c else
(*      let c = Ty.compare_subst s1.ssubst_ty s2.ssubst_ty in
        if c<>0 then c else Sy.Map.compare T.compare s1.ssubst s2.ssubst*)
      Term.compare_subst s1.sko_subst s2.sko_subst
  and compare_let l1 l2 =
    let c = compare_t l1.let_f l2.let_f in
    if c<>0 then c else 
      let c = T.compare l1.let_term l2.let_term in
      if c<>0 then c else 
        let c = Sy.compare l1.let_var l2.let_var in
        if c<>0 then c else
	  T.compare_subst l1.let_subst l2.let_subst
          (*let c = Ty.compare_subst l1.lsubst_ty l2.lsubst_ty in
            if c<>0 then c else
              Sy.Map.compare T.compare l1.lsubst l2.lsubst*)
      
  let sort l = 
    let l = List.sort compare_t l in
    List.fold_left 
	(fun acc x -> match acc with
	     [] -> [x]
	   | h::l when fst x == fst h -> acc
	   | _ -> x::acc) [] l
      
  let eqc c1 c2 = match c1,c2 with
    | Unit((f1, _), (f2, _)) , Unit((g1,_), (g2,_)) ->
      f1==g1 && f2==g2 || f1==g2 && f2==g1

    | Clause((f1, _), (f2, _)) , Clause((g1,_), (g2,_)) ->
      f1==g1 && f2==g2 || f1==g2 && f2==g1

    | Literal x , Literal y -> Literal.LT.equal x y

    | Lemma({triggers = lt1; main = (f1,_)}),
      Lemma({triggers = lt2; main = (f2,_)}) -> 
	(try List.for_all2 (List.for_all2 T.equal) lt1 lt2 && f1==f2
	 with Invalid_argument _ -> false)

    | Skolem {sko_subst = s1; sko_f = (f1, _)}, 
	Skolem {sko_subst = s2; sko_f = (f2,_)} -> 
	f1==f2  && Term.compare_subst s1 s2 = 0

(*
    | Skolem {ssubst=s1;ssubst_ty=ty1;sf=(f1,_)},
	Skolem {ssubst=s2;ssubst_ty=ty2;sf=(f2,_)} -> 
	f1==f2 
	&& (Sy.Map.compare T.compare s1 s2 = 0)
	&& Ty.compare_subst ty1 ty2 = 0
*)
    | Let l1, Let l2 -> 
	fst l1.let_f == fst l2.let_f 
	&& Sy.equal l1.let_var l2.let_var 
	&& Term.equal l1.let_term l2.let_term 
	&& Term.compare_subst l1.let_subst l2.let_subst = 0
        (*&& (Sy.Map.compare T.compare l1.lsubst l2.lsubst = 0)
	&& Ty.compare_subst l1.lsubst_ty l2.lsubst_ty = 0*)
	    
    | _, _ -> false
	
  let hashlt = List.fold_left (fun acc x->acc*19 + T.hash x)
  let hashllt = List.fold_left (fun acc x->acc*19 + hashlt 0 x)
    
  let hashc acc = function 
    | Unit((f1,_),(f2,_)) -> (* XXX : Same as Clause ? *)
	let min = min f1.tag f2.tag in
	let max = max f1.tag f2.tag in
	(acc*19 + min)*19 + max
    | Clause((f1,_),(f2,_)) -> 
	let min = min f1.tag f2.tag in
	let max = max f1.tag f2.tag in
	(acc*19 + min)*19 + max
    | Lemma({qvars = vars;triggers = trs; main = (f,_)}) -> 
	hashllt (Hashtbl.hash (f.tag,vars)) trs
    | Literal x -> Literal.LT.hash x

    | Skolem{sko_subst = s; sko_f = (f,_)} -> 
	T.fold_subst_term
	  (fun s t acc -> acc * 19 + Sy.hash s + T.hash t) s f.tag

(*    | Skolem{ssubst=s;sf=(f,_)} -> 
	Sy.Map.fold 
	  (fun s t acc ->acc * 19 + Sy.hash s) s f.tag*)

    | Let ({let_var=lvar; let_term=lterm; 
	    let_subst=s; let_f=(lf,_)}) -> 
	T.fold_subst_term 
	  (fun s t acc ->acc * 19 + Sy.hash s) s
	  (lf.tag * 19 * 19 + Sy.hash lvar * 19 + acc)

(*        Sy.Map.fold (fun s t acc ->acc * 19 + Sy.hash s) lsubst 
          (lf.tag * 19 * 19 + Sy.hash lvar * 19 + acc)*)

(*    | Let ({let_var=lvar; let_term=lterm;lsubst=lsubst;let_f=(lf,_)}) -> 
        Sy.Map.fold (fun s t acc ->acc * 19 + Sy.hash s) lsubst 
          (lf.tag * 19 * 19 + Sy.hash lvar * 19 + acc)*)
	  
  let equal f1 f2 = eqc f1.pos f2.pos && eqc f1.neg f2.neg
  let hash f = abs (hashc (hashc 1 f.pos) f.neg)
end
  
  
module H = Make(View)
  
let tbl = H.create 100007
let iview f = f.node

let view (t,_) = t.node.pos
let id (_,id) = id

let rec print fmt f = 
  match view f with
  | Literal a -> 
      Literal.LT.print fmt a
  | Lemma {triggers = trs; main = f; name = n} -> 
      if verbose then
	fprintf fmt "(lemma: %s)[%a] %a" 
	  n
	  (fun fmt -> List.iter (fprintf fmt "%a@ |" T.print_list)) 
	  trs print f
      else 
	fprintf fmt "lem %s" n

  | Unit(f1, f2) -> fprintf fmt "%a & %a " print f1 print f2

  | Clause(f1, f2) -> fprintf fmt "(%a v %a) " print f1 print f2

  | Skolem{sko_f=f} -> fprintf fmt "<sko> (%a)" print f

  | Let l -> 
      fprintf fmt 
	"let %a =@ %a in@ %a" Sy.print l.let_var 
	Term.print l.let_term print l.let_f

let print fmt ((_,id) as f) =
  fprintf fmt "%a (%d)" print f id

let union_subst s1 ((s2,s2_ty) as subst) = 
  Sy.Map.fold 
    (fun k x s2 -> Sy.Map.add k x s2) (Sy.Map.map (T.apply_subst subst)  s1) s2


let size (t,_) = t.node.size

let compare ((v1,_) as f1) ((v2,_) as f2)= 
  let c = Pervasives.compare (size f1) (size f2) in 
  if c=0 then compare v1.tag v2.tag else c
	  
let equal (f1,_) (f2,_) = f1.tag == f2.tag


(* smart constructors *)

let mk_lit a id = 
  (H.hashcons tbl 
     {pos = Literal a; neg = Literal (Literal.LT.neg a); size = 1}, id)
  
let mk_not (f,id) = 
  let f = iview f in (H.hashcons tbl ({pos=f.neg;neg=f.pos;size=f.size}), id)

let mk_skolem_subst bv v = 
  T.Set.fold 
    (fun x m -> 
       let {T.f=x;ty=ty} = T.view x in
       let bv = T.Set.fold (fun y acc-> y::acc) bv [] in
       let t = T.make (Sy.fresh "sko") bv ty in
       Sy.Map.add x t m) 
    v Sy.Map.empty

let symbols_of_terms v = 
  T.Set.fold 
    (fun t sy -> let {T.f=f} = T.view t in Sy.Set.add f sy) 
    v Sy.Set.empty
  
(* name: (forall bv [trs]. f[fv]) *)
let mk_forall up bv trs f name id = 
  let sy = symbols_of_terms bv in
  let lem = {qvars = sy; triggers = trs; main = f ; name=name} in
(*  let sko = {ssubst = mk_skolem_subst up bv;
             ssubst_ty = Ty.esubst;
             sf = mk_not f} in*)
  let sko = 
    {sko_subst = (mk_skolem_subst up bv, Ty.esubst); sko_f = mk_not f} 
  in
  (H.hashcons tbl {pos=Lemma(lem) ; neg=Skolem(sko); size=size f }, id)
    
(* forall upbv.  name: (exists bv [trs]. f) *)
let mk_exists up bv trs f name id= 
  let sy = symbols_of_terms bv in
  let lem = {qvars = sy; triggers = trs; main = mk_not f; name=name} in
(*  let sko = {ssubst = mk_skolem_subst up bv;
             ssubst_ty = Ty.esubst;
             sf = f} in*)
  let sko = {sko_subst = (mk_skolem_subst up bv, Ty.esubst); sko_f = f} in
  (H.hashcons tbl {pos=Skolem(sko)  ; neg=Lemma(lem) ; size = size f}, id)

(* forall up. let bv = t in f *)
let mk_let up bv t f id =
  let {Term.ty=ty} = Term.view t in
  let up = T.Set.fold (fun y acc-> y::acc) up [] in
  let subst = Sy.Map.add bv (T.make (Sy.fresh "let") up ty) Sy.Map.empty in
   (H.hashcons tbl 
     {pos=Let{let_var=bv; let_subst=(subst, Ty.esubst); let_term=t; let_f=f};
      neg=Let{let_var=bv; let_subst=(subst, Ty.esubst); 
	      let_term=t; let_f=mk_not f};
      size=size f }, id)
    
let mk_and f1 f2 id =
  if equal f1 f2 then f1 else
    let size = size f1 + size f2 in
    (H.hashcons tbl 
       {pos=Unit(f1,f2); neg=Clause(mk_not f1,mk_not f2); size=size}, id)
	
let mk_or f1 f2 id = 
  if equal f1 f2 then f1 else
    let size = size f1 + size f2 in
    (H.hashcons tbl 
       {pos=Clause(f1,f2); neg=Unit(mk_not f1,mk_not f2); size=size}, id)
      
let mk_imp f1 f2 id = 
  let size = size f1 + size f2 in
  (H.hashcons tbl 
     {pos=Clause(mk_not f1,f2); neg=Unit(f1,mk_not f2); size=size}, id)

let mk_if t f2 f3 id = 
  let lit = mk_lit (Literal.LT.mk_pred t) id in
  mk_or (mk_and lit f2 id) (mk_and (mk_not lit) f3 id) id
    
let mk_iff f1 f2 id = 
  let a = mk_or f1 f2 id in
  let b = mk_or (mk_not f1) (mk_not f2) id in
  let c = mk_or (mk_not f1) f2 id in
  let d = mk_or f1 (mk_not f2) id in
  (H.hashcons tbl 
     {pos=Unit(c,d); neg=Unit(a,b) ; size=2*(size f1+size f2)}, id)


(* this function should only be applied with ground substitutions *)
let rec apply_subst subst (f, id) =
  let {pos=p;neg=n;size=s} = iview f in
  let sp, sn = iapply_subst subst p n in 
  (H.hashcons tbl { pos = sp; neg = sn; size = s }, id)

and iapply_subst ((s_t,s_ty) as subst) p n = match p, n with
  | Literal a, Literal _ ->
      let sa = Literal.LT.apply_subst subst a in
      let nsa = Literal.LT.neg sa in
      Literal(sa), Literal(nsa)

  | Lemma({qvars = vars; triggers = trs; main = f} as lem), Skolem sko
  | Skolem sko, Lemma({qvars = vars; triggers = trs; main = f} as lem)->
      let s_t = Sy.Set.fold Sy.Map.remove vars s_t in
      let subst = s_t , s_ty in
      let f = apply_subst subst f in
      let trs = List.map (List.map (T.apply_subst subst)) trs in
      let slem = Lemma({lem with triggers = trs; main = f}) in
(*      let ssko = Skolem {sko with 
	    ssubst = union_subst sko.ssubst subst;
            ssubst_ty = Ty.union_subst sko.ssubst_ty s_ty} in*)
      let sigma = T.union_subst sko.sko_subst subst in
      let ssko = Skolem {sko with sko_subst = sigma } in
      (match p,n with
	| Lemma _, Skolem _ -> slem, ssko
	| Skolem _, Lemma _ -> ssko, slem
	| _ -> assert false)

  | Unit(f1, f2), _ ->
      let sf1 = apply_subst subst f1 in
      let sf2 = apply_subst subst f2 in
      Unit(sf1, sf2), Clause(mk_not sf1, mk_not sf2)

  | Clause(f1, f2), _ -> 
      let sf1 = apply_subst subst f1 in
      let sf2 = apply_subst subst f2 in
      Clause(sf1, sf2), Unit(mk_not sf1, mk_not sf2)

  | Let ({let_subst = s; let_term = lterm; let_f = lf} as e), Let _ ->
     let lterm = T.apply_subst subst lterm in
     let se = { e with let_subst = T.union_subst s subst; let_term = lterm } in
     let sne = { se with let_f = mk_not lf } in
     Let se, Let sne

(*  | Let ({lsubst=lsubst;lsubst_ty=lsubst_ty;
	  let_term=lterm;let_f=lf} as e), Let _ ->
     let lterm = T.apply_subst subst lterm in
     let lsubst = union_subst lsubst subst in
     let se = { e with 
		  lsubst = lsubst; lsubst_ty = Ty.union_subst lsubst_ty s_ty;
		  let_term=lterm} in
     let sne = { se with let_f = mk_not lf } in
     Let se, Let sne*)
  | _ -> assert false

let add_label lbl f =
  match view f with
    | Literal a -> 
	Literal.LT.add_label lbl a;
	Literal.LT.add_label lbl (Literal.LT.neg a)
    | _ -> ()

let label f = 
  match view f with
    | Literal l -> Literal.LT.label l
    | _ -> Hstring.empty
	
let free_vars =
  let rec free_rec acc f = 
    match view f with
	Literal a -> Sy.Set.union (Literal.LT.vars_of a) acc
      | Lemma {qvars = v; main = f} -> 
	  let s = free_rec acc f in Sy.Set.diff s v
      | Unit(f1,f2) -> free_rec (free_rec acc f1) f2
      | Clause(f1,f2) -> free_rec (free_rec acc f1) f2
      | Skolem{sko_subst = (subst,_); sko_f = f} -> 
	  let sy = free_rec acc f in
	  Sy.Map.fold 
	    (fun s t sy -> 
	       if Sy.Set.mem s sy then 
		 Sy.Set.remove s (Sy.Set.union sy (Term.vars_of t))
	       else sy
	    ) subst sy
      | Let {let_subst = (subst, _); let_term = t; let_f = lf} ->
	  let ss =  
	    Sy.Set.filter (fun x -> Sy.Map.mem x subst) (free_rec acc lf) in
          let sy = Sy.Set.union (Term.vars_of t) ss in
          Sy.Map.fold
	    (fun s t sy -> 
	       if Sy.Set.mem s sy then 
		 Sy.Set.remove s (Sy.Set.union sy (Term.vars_of t))
	       else sy
	    ) subst sy

(*      | Let {lsubst=subst; let_term=t; let_f=lf} ->
	  let ss =  
	    Sy.Set.filter (fun x -> Sy.Map.mem x subst) (free_rec acc lf) in
          let sy = Sy.Set.union (Term.vars_of t) ss in
          Sy.Map.fold
	    (fun s t sy -> 
	       if Sy.Set.mem s sy then 
		 Sy.Set.remove s (Sy.Set.union sy (Term.vars_of t))
	       else sy
	    ) subst sy*)
          
  in free_rec Sy.Set.empty
    
let terms = 
  let rec terms acc f = match view f with
    | Literal a -> 
	let s = 
	  T.Set.filter 
	    (fun t-> 
	       Sy.Set.is_empty (T.vars_of t) && Ty.Svty.is_empty (T.vty_of t)
	    ) (Literal.LT.terms_of a)
	in
	T.Set.union s acc
    | Lemma {triggers = trs; main = f} -> terms acc f
    | Unit(f1,f2) -> terms (terms acc f1) f2
    | Clause(f1,f2) -> terms (terms acc f1) f2
    | Skolem{sko_subst = (s,_); sko_f = f} -> terms acc f
    | Let {let_term=t; let_f=lf} -> 
        let st = 
	  T.Set.filter (fun t->Sy.Set.is_empty (T.vars_of t)) 
	    (Term.subterms Term.Set.empty t) 
	in
        terms (T.Set.union st acc) lf
  in terms T.Set.empty

module Set = Set.Make(struct type t'=t type t=t' let compare=compare end)
module Map = Map.Make(struct type t'=t type t=t' let compare=compare end)

end
include (IMPLEMENTATION : INTERFACE)
end
and Explanation: sig
#0 "explanation.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type t

(* val everything : t *)

val empty : t

val mem_as_bj : Formula.t -> t -> bool

val singleton : ?bj:bool -> Formula.t -> t

val make_deps : Formula.Set.t -> t

val union : t -> t -> t

val merge : t -> t -> t

val remove : Formula.t -> t -> t

val print : Format.formatter -> t -> unit

val print_proof : Format.formatter -> t -> unit

val ids_of : t -> int list option

val formulas_of : t -> Formula.Set.t
end = struct
let _ = Printf.fprintf stderr "Executing explanation.ml\n%!"module type INTERFACE = sig
#0 "explanation.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type t

(* val everything : t *)

val empty : t

val mem_as_bj : Formula.t -> t -> bool

val singleton : ?bj:bool -> Formula.t -> t

val make_deps : Formula.Set.t -> t

val union : t -> t -> t

val merge : t -> t -> t

val remove : Formula.t -> t -> t

val print : Format.formatter -> t -> unit

val print_proof : Format.formatter -> t -> unit

val ids_of : t -> int list option

val formulas_of : t -> Formula.Set.t
end
module IMPLEMENTATION = struct
#0 "explanation.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type e = Dep of Formula.t | BJ of Formula.t

module ES = Set.Make(struct 
  type t = e 
  let compare e1 e2 = match e1,e2 with
    | Dep e1, Dep e2 -> Formula.compare e1 e2
    | Dep _, _ -> 1
    | BJ e1, BJ e2 -> Formula.compare e1 e2
    | BJ _, _ -> -1
end)

type t = ES.t option

(* let everything = None *)

let empty = Some (ES.empty)

let mem_as_bj l = function
  | None -> true
  | Some s -> ES.mem (BJ l) s

let singleton ?(bj = true) l = 
  Some (ES.singleton (if bj then BJ l else Dep l))

let make_deps sf = 
  Some (Formula.Set.fold (fun l acc -> ES.add (BJ l) acc) sf ES.empty)

let union d1 d2 = match d1,d2 with
    None , _ | _ , None -> None
  | Some s1 , Some s2 -> Some (ES.union s1 s2)


let merge d1 d2 = d1

let remove f = function
  | None -> None
  | Some s when ES.mem (BJ f) s -> Some (ES.remove (BJ f) s)
  | _ -> raise Not_found
  (*
    let s', found = 
      ES.fold (fun e (acc, found) -> 
	match e with  
	  | BJ e' when (not found) && Formula.compare e' f = 0 -> acc, true
	  | _ -> (ES.add e acc), found
      ) s (ES.empty, false) in
    if found then Some s' else raise Not_found
  *)

let print fmt = function
  | None -> Format.fprintf fmt "{Everything}"
  | Some s -> 
      Format.fprintf fmt "[";
      ES.iter (fun e -> match e with 
	| Dep f -> Format.fprintf fmt "{Dep:%a}" Formula.print f
	| BJ f -> Format.fprintf fmt "{BJ:%a}" Formula.print f) s;
      Format.fprintf fmt "]"

let print_proof fmt = function
  | None -> Format.fprintf fmt "{Everything}"
  | Some s -> 
      ES.iter (fun e -> match e with 
	| (Dep f | BJ f) -> Format.fprintf fmt "  %a@." Formula.print f
	(* | BJ f  -> Format.fprintf fmt "  %a@." Formula.print f *)
      ) s

let ids_of = function
  | None -> None
  | Some s ->
    Some (ES.fold (fun e acc ->
      let id = match e with
	| Dep f | BJ f -> Formula.id f in
      id::acc) s [])

let formulas_of = function
  | None  -> Formula.Set.empty
  | Some s -> 
      ES.fold (fun e acc -> 
                 match e with 
	             Dep f | BJ f -> Formula.Set.add f acc
              )s Formula.Set.empty
end
include (IMPLEMENTATION : INTERFACE)
end
and Why_parser: sig
#0 "why_parser.mli"
type token =
  | IDENT of (string)
  | INTEGER of (string)
  | FLOAT of (string)
  | NUM of (Num.num)
  | STRING of (string)
  | AND
  | LEFTARROW
  | ARROW
  | AC
  | AT
  | AXIOM
  | REWRITING
  | BAR
  | HAT
  | BOOL
  | COLON
  | COMMA
  | PV
  | DISTINCT
  | DOT
  | ELSE
  | EOF
  | EQUAL
  | EXISTS
  | FALSE
  | VOID
  | FORALL
  | FUNCTION
  | GE
  | GOAL
  | GT
  | IF
  | IN
  | INT
  | BITV
  | LE
  | LET
  | LEFTPAR
  | LEFTSQ
  | LEFTBR
  | LOGIC
  | LRARROW
  | LT
  | MINUS
  | NOT
  | NOTEQ
  | OR
  | PERCENT
  | PLUS
  | PREDICATE
  | PROP
  | QUOTE
  | REAL
  | UNIT
  | RIGHTPAR
  | RIGHTSQ
  | RIGHTBR
  | SLASH
  | THEN
  | TIMES
  | TRUE
  | TYPE

val trigger :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Why_ptree.lexpr list
val lexpr :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Why_ptree.lexpr
val file :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Why_ptree.file
end = struct
let _ = Printf.fprintf stderr "Executing why_parser.ml\n%!"module type INTERFACE = sig
#0 "why_parser.mli"
type token =
  | IDENT of (string)
  | INTEGER of (string)
  | FLOAT of (string)
  | NUM of (Num.num)
  | STRING of (string)
  | AND
  | LEFTARROW
  | ARROW
  | AC
  | AT
  | AXIOM
  | REWRITING
  | BAR
  | HAT
  | BOOL
  | COLON
  | COMMA
  | PV
  | DISTINCT
  | DOT
  | ELSE
  | EOF
  | EQUAL
  | EXISTS
  | FALSE
  | VOID
  | FORALL
  | FUNCTION
  | GE
  | GOAL
  | GT
  | IF
  | IN
  | INT
  | BITV
  | LE
  | LET
  | LEFTPAR
  | LEFTSQ
  | LEFTBR
  | LOGIC
  | LRARROW
  | LT
  | MINUS
  | NOT
  | NOTEQ
  | OR
  | PERCENT
  | PLUS
  | PREDICATE
  | PROP
  | QUOTE
  | REAL
  | UNIT
  | RIGHTPAR
  | RIGHTSQ
  | RIGHTBR
  | SLASH
  | THEN
  | TIMES
  | TRUE
  | TYPE

val trigger :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Why_ptree.lexpr list
val lexpr :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Why_ptree.lexpr
val file :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Why_ptree.file
end
module IMPLEMENTATION = struct
#0 "why_parser.ml"
type token =
  | IDENT of (string)
  | INTEGER of (string)
  | FLOAT of (string)
  | NUM of (Num.num)
  | STRING of (string)
  | AND
  | LEFTARROW
  | ARROW
  | AC
  | AT
  | AXIOM
  | REWRITING
  | BAR
  | HAT
  | BOOL
  | COLON
  | COMMA
  | PV
  | DISTINCT
  | DOT
  | ELSE
  | EOF
  | EQUAL
  | EXISTS
  | FALSE
  | VOID
  | FORALL
  | FUNCTION
  | GE
  | GOAL
  | GT
  | IF
  | IN
  | INT
  | BITV
  | LE
  | LET
  | LEFTPAR
  | LEFTSQ
  | LEFTBR
  | LOGIC
  | LRARROW
  | LT
  | MINUS
  | NOT
  | NOTEQ
  | OR
  | PERCENT
  | PLUS
  | PREDICATE
  | PROP
  | QUOTE
  | REAL
  | UNIT
  | RIGHTPAR
  | RIGHTSQ
  | RIGHTBR
  | SLASH
  | THEN
  | TIMES
  | TRUE
  | TYPE

open Parsing;;
# 37 "why_parser.mly"

  open Why_ptree
  open Parsing

  let loc () = (symbol_start_pos (), symbol_end_pos ())
  let loc_i i = (rhs_start_pos i, rhs_end_pos i)
  let loc_ij i j = (rhs_start_pos i, rhs_end_pos j)

  let mk_ppl loc d = { pp_loc = loc; pp_desc = d }
  let mk_pp d = mk_ppl (loc ()) d
  let mk_pp_i i d = mk_ppl (loc_i i) d
		    
  let infix_ppl loc a i b = mk_ppl loc (PPinfix (a, i, b))
  let infix_pp a i b = infix_ppl (loc ()) a i b

  let prefix_ppl loc p a = mk_ppl loc (PPprefix (p, a))
  let prefix_pp p a = prefix_ppl (loc ()) p a

  let check_binary_mode s = 
    String.iter (fun x-> if x<>'0' && x<>'1' then raise Parsing.Parse_error) s;
    s

# 90 "why_parser.ml"
let yytransl_const = [|
  262 (* AND *);
  263 (* LEFTARROW *);
  264 (* ARROW *);
  265 (* AC *);
  266 (* AT *);
  267 (* AXIOM *);
  268 (* REWRITING *);
  269 (* BAR *);
  270 (* HAT *);
  271 (* BOOL *);
  272 (* COLON *);
  273 (* COMMA *);
  274 (* PV *);
  275 (* DISTINCT *);
  276 (* DOT *);
  277 (* ELSE *);
    0 (* EOF *);
  278 (* EQUAL *);
  279 (* EXISTS *);
  280 (* FALSE *);
  281 (* VOID *);
  282 (* FORALL *);
  283 (* FUNCTION *);
  284 (* GE *);
  285 (* GOAL *);
  286 (* GT *);
  287 (* IF *);
  288 (* IN *);
  289 (* INT *);
  290 (* BITV *);
  291 (* LE *);
  292 (* LET *);
  293 (* LEFTPAR *);
  294 (* LEFTSQ *);
  295 (* LEFTBR *);
  296 (* LOGIC *);
  297 (* LRARROW *);
  298 (* LT *);
  299 (* MINUS *);
  300 (* NOT *);
  301 (* NOTEQ *);
  302 (* OR *);
  303 (* PERCENT *);
  304 (* PLUS *);
  305 (* PREDICATE *);
  306 (* PROP *);
  307 (* QUOTE *);
  308 (* REAL *);
  309 (* UNIT *);
  310 (* RIGHTPAR *);
  311 (* RIGHTSQ *);
  312 (* RIGHTBR *);
  313 (* SLASH *);
  314 (* THEN *);
  315 (* TIMES *);
  316 (* TRUE *);
  317 (* TYPE *);
    0|]

let yytransl_block = [|
  257 (* IDENT *);
  258 (* INTEGER *);
  259 (* FLOAT *);
  260 (* NUM *);
  261 (* STRING *);
    0|]

let yylhs = "\255\255\
\003\000\003\000\004\000\004\000\005\000\005\000\005\000\005\000\
\005\000\005\000\005\000\005\000\005\000\005\000\005\000\010\000\
\010\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
\014\000\014\000\012\000\012\000\012\000\012\000\016\000\016\000\
\017\000\017\000\013\000\013\000\018\000\018\000\019\000\007\000\
\007\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
\021\000\021\000\026\000\024\000\024\000\027\000\027\000\001\000\
\015\000\015\000\015\000\022\000\022\000\022\000\028\000\028\000\
\023\000\023\000\020\000\020\000\020\000\020\000\020\000\020\000\
\008\000\009\000\009\000\006\000\011\000\011\000\025\000\025\000\
\000\000\000\000\000\000"

let yylen = "\002\000\
\002\000\001\000\001\000\002\000\002\000\004\000\003\000\005\000\
\005\000\009\000\004\000\007\000\004\000\004\000\004\000\000\000\
\001\000\001\000\001\000\001\000\001\000\004\000\001\000\001\000\
\002\000\004\000\003\000\001\000\003\000\001\000\001\000\003\000\
\000\000\001\000\000\000\001\000\001\000\003\000\003\000\001\000\
\003\000\001\000\001\000\001\000\001\000\001\000\003\000\003\000\
\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
\002\000\002\000\005\000\007\000\003\000\004\000\004\000\001\000\
\004\000\004\000\006\000\007\000\006\000\003\000\006\000\003\000\
\001\000\003\000\003\000\000\000\003\000\001\000\003\000\001\000\
\001\000\002\000\003\000\000\000\001\000\003\000\001\000\003\000\
\003\000\003\000\001\000\001\000\001\000\001\000\001\000\001\000\
\002\000\001\000\003\000\001\000\001\000\003\000\001\000\001\000\
\002\000\002\000\002\000"

let yydefred = "\000\000\
\000\000\000\000\000\000\000\000\000\000\042\000\043\000\104\000\
\000\000\000\000\045\000\046\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\044\000\105\000\000\000\000\000\000\000\
\080\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\
\000\000\000\000\107\000\000\000\000\000\000\000\100\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\095\000\094\000\093\000\
\092\000\000\000\000\000\091\000\000\000\096\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\017\000\000\000\000\000\000\000\000\000\000\000\
\000\000\001\000\004\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\072\000\000\000\000\000\000\000\000\000\000\000\
\088\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\097\000\000\000\007\000\000\000\066\000\102\000\019\000\018\000\
\000\000\000\000\020\000\021\000\023\000\024\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\062\000\063\000\000\000\
\000\000\065\000\000\000\000\000\014\000\000\000\000\000\036\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\006\000\000\000\090\000\000\000\000\000\000\000\000\000\025\000\
\000\000\000\000\000\000\000\000\059\000\000\000\000\000\000\000\
\074\000\086\000\000\000\000\000\000\000\000\000\028\000\009\000\
\000\000\034\000\000\000\000\000\099\000\008\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\083\000\000\000\000\000\038\000\000\000\000\000\041\000\
\022\000\032\000\026\000\000\000\077\000\000\000\060\000\000\000\
\027\000\000\000\000\000\079\000\000\000\000\000"

let yydgoto = "\004\000\
\196\000\022\000\035\000\036\000\037\000\023\000\161\000\134\000\
\120\000\076\000\041\000\184\000\151\000\165\000\149\000\166\000\
\187\000\152\000\153\000\068\000\099\000\110\000\085\000\170\000\
\024\000\100\000\197\000\025\000"

let yysindex = "\087\000\
\056\004\056\004\061\000\000\000\000\000\000\000\000\000\000\000\
\236\254\018\255\000\000\000\000\018\255\056\004\018\255\056\004\
\016\255\056\004\056\004\000\000\000\000\095\004\240\254\037\255\
\000\000\243\005\018\255\018\255\000\000\018\255\018\255\034\255\
\018\255\004\255\000\000\062\000\029\001\056\004\000\000\046\255\
\049\255\050\255\139\004\047\255\185\004\069\255\044\255\044\255\
\056\004\056\004\056\004\056\255\056\004\000\000\000\000\000\000\
\000\000\056\004\056\004\000\000\056\004\000\000\056\004\056\004\
\056\004\056\004\056\004\056\004\056\004\056\004\067\255\080\255\
\048\255\084\255\000\000\018\255\027\255\051\255\018\255\079\255\
\018\255\000\000\000\000\235\004\053\255\018\255\110\255\110\255\
\056\004\056\004\000\000\090\255\047\006\243\005\252\254\102\255\
\000\000\196\255\054\255\091\255\243\005\249\254\017\006\252\254\
\249\254\252\254\252\254\138\002\023\005\058\255\044\255\056\004\
\056\004\018\255\056\004\094\255\056\004\018\255\097\255\061\255\
\000\000\018\255\000\000\056\004\000\000\000\000\000\000\000\000\
\096\255\110\255\000\000\000\000\000\000\000\000\036\255\007\255\
\067\005\111\005\063\255\119\255\056\004\000\000\000\000\056\004\
\056\004\000\000\243\005\155\005\000\000\116\255\083\255\000\000\
\128\255\243\005\105\255\243\005\092\255\051\255\018\255\138\255\
\000\000\235\004\000\000\152\255\025\255\118\255\056\004\000\000\
\056\004\139\255\056\004\056\004\000\000\169\255\243\005\199\005\
\000\000\000\000\056\004\110\255\158\255\018\255\000\000\000\000\
\025\255\000\000\167\255\155\255\000\000\000\000\018\255\123\255\
\110\255\018\255\243\005\166\255\127\255\056\004\077\006\243\005\
\130\255\000\000\018\255\110\255\000\000\115\255\056\004\000\000\
\000\000\000\000\000\000\056\004\000\000\243\005\000\000\008\255\
\000\000\018\255\243\005\000\000\056\004\243\005"

let yyrindex = "\000\000\
\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\022\000\057\000\000\000\
\000\000\183\000\000\000\000\000\000\000\000\000\000\000\183\255\
\000\000\000\000\000\000\000\000\189\000\000\000\000\000\175\255\
\000\000\000\000\000\000\000\000\000\000\000\000\113\000\169\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\140\255\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\117\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\213\002\044\003\025\001\000\000\
\000\000\000\000\000\000\137\255\068\003\249\001\009\003\081\001\
\049\002\137\001\193\001\105\002\141\255\000\000\225\000\000\000\
\000\000\143\255\000\000\000\000\000\000\143\255\146\255\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\173\255\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\173\000\229\000\000\000\000\000\000\000\000\000\
\147\255\213\003\197\255\236\003\000\000\000\000\000\000\239\003\
\000\000\159\255\000\000\000\000\248\254\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\245\254\000\000\
\000\000\000\000\246\003\000\000\000\000\000\000\000\000\000\000\
\206\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\120\003\157\255\000\000\000\000\161\002\144\003\
\000\000\000\000\253\254\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\183\003\000\000\000\000\
\000\000\013\004\023\004\000\000\000\000\037\004"

let yygindex = "\000\000\
\213\000\009\000\000\000\178\000\000\000\005\000\026\000\226\255\
\064\000\000\000\011\000\000\000\101\000\181\255\041\000\117\255\
\000\000\045\000\000\000\000\000\084\000\000\000\108\000\000\000\
\000\000\000\000\021\000\205\255"

let yytablesize = 1928
let yytable = "\031\000\
\100\000\097\000\051\000\081\000\039\000\075\000\052\000\039\000\
\039\000\052\000\026\000\135\000\136\000\039\000\040\000\186\000\
\038\000\040\000\039\000\044\000\069\000\087\000\043\000\042\000\
\045\000\039\000\047\000\048\000\046\000\221\000\058\000\071\000\
\072\000\058\000\073\000\074\000\039\000\077\000\080\000\064\000\
\078\000\193\000\075\000\075\000\169\000\031\000\084\000\119\000\
\117\000\066\000\039\000\067\000\070\000\210\000\079\000\167\000\
\064\000\093\000\094\000\095\000\029\000\082\000\086\000\118\000\
\087\000\088\000\098\000\101\000\090\000\102\000\092\000\103\000\
\104\000\105\000\106\000\107\000\108\000\109\000\111\000\185\000\
\040\000\058\000\112\000\121\000\114\000\123\000\116\000\001\000\
\002\000\003\000\040\000\133\000\133\000\178\000\096\000\113\000\
\126\000\137\000\138\000\115\000\122\000\079\000\139\000\140\000\
\203\000\039\000\125\000\144\000\143\000\155\000\039\000\146\000\
\058\000\158\000\159\000\039\000\005\000\173\000\150\000\127\000\
\147\000\148\000\150\000\154\000\127\000\156\000\160\000\119\000\
\216\000\127\000\218\000\180\000\162\000\164\000\133\000\174\000\
\181\000\128\000\129\000\168\000\168\000\130\000\128\000\129\000\
\182\000\188\000\130\000\128\000\129\000\175\000\191\000\130\000\
\176\000\192\000\183\000\079\000\131\000\132\000\198\000\133\000\
\079\000\131\000\132\000\190\000\217\000\079\000\131\000\132\000\
\057\000\168\000\201\000\194\000\013\000\204\000\206\000\195\000\
\207\000\209\000\212\000\199\000\200\000\213\000\106\000\016\000\
\133\000\215\000\150\000\148\000\003\000\168\000\101\000\073\000\
\076\000\084\000\085\000\160\000\035\000\133\000\211\000\098\000\
\037\000\049\000\141\000\050\000\033\000\051\000\214\000\168\000\
\133\000\052\000\133\000\078\000\089\000\021\000\083\000\219\000\
\208\000\054\000\157\000\202\000\168\000\189\000\168\000\055\000\
\070\000\056\000\205\000\177\000\081\000\222\000\057\000\163\000\
\220\000\058\000\000\000\000\000\059\000\060\000\061\000\000\000\
\062\000\063\000\064\000\065\000\000\000\000\000\000\000\000\000\
\000\000\000\000\142\000\000\000\066\000\000\000\067\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\100\000\100\000\
\100\000\000\000\100\000\100\000\100\000\100\000\100\000\000\000\
\103\000\100\000\100\000\000\000\000\000\100\000\100\000\000\000\
\061\000\000\000\000\000\100\000\100\000\100\000\100\000\000\000\
\100\000\000\000\087\000\100\000\000\000\100\000\100\000\000\000\
\100\000\100\000\100\000\100\000\000\000\100\000\100\000\100\000\
\100\000\100\000\000\000\000\000\000\000\000\000\100\000\100\000\
\000\000\100\000\100\000\100\000\000\000\100\000\064\000\064\000\
\064\000\000\000\064\000\064\000\064\000\064\000\064\000\027\000\
\028\000\064\000\064\000\087\000\087\000\064\000\064\000\000\000\
\051\000\000\000\000\000\064\000\064\000\064\000\064\000\030\000\
\064\000\031\000\000\000\064\000\000\000\000\000\064\000\000\000\
\064\000\064\000\064\000\064\000\032\000\064\000\064\000\064\000\
\064\000\064\000\000\000\000\000\000\000\033\000\064\000\064\000\
\000\000\064\000\064\000\064\000\000\000\064\000\058\000\058\000\
\058\000\034\000\058\000\058\000\058\000\058\000\058\000\005\000\
\005\000\058\000\058\000\000\000\000\000\058\000\058\000\000\000\
\050\000\000\000\000\000\058\000\058\000\058\000\058\000\005\000\
\058\000\005\000\000\000\058\000\000\000\000\000\000\000\000\000\
\058\000\058\000\058\000\058\000\005\000\058\000\058\000\058\000\
\058\000\058\000\000\000\000\000\000\000\005\000\058\000\058\000\
\000\000\058\000\058\000\058\000\000\000\058\000\057\000\057\000\
\057\000\005\000\057\000\057\000\057\000\057\000\057\000\013\000\
\013\000\057\000\057\000\000\000\000\000\057\000\057\000\000\000\
\049\000\000\000\000\000\057\000\057\000\057\000\057\000\013\000\
\057\000\013\000\000\000\057\000\000\000\000\000\000\000\000\000\
\057\000\057\000\057\000\057\000\013\000\057\000\057\000\057\000\
\057\000\057\000\000\000\000\000\000\000\013\000\057\000\057\000\
\000\000\057\000\057\000\057\000\000\000\057\000\070\000\070\000\
\070\000\013\000\070\000\070\000\070\000\070\000\070\000\081\000\
\081\000\070\000\070\000\000\000\000\000\070\000\070\000\000\000\
\048\000\000\000\000\000\070\000\070\000\070\000\070\000\081\000\
\070\000\081\000\000\000\070\000\000\000\000\000\000\000\000\000\
\070\000\070\000\070\000\070\000\081\000\070\000\070\000\070\000\
\070\000\070\000\000\000\000\000\000\000\081\000\070\000\070\000\
\000\000\070\000\070\000\070\000\000\000\070\000\061\000\061\000\
\061\000\081\000\061\000\061\000\061\000\061\000\000\000\027\000\
\028\000\061\000\061\000\000\000\000\000\061\000\061\000\000\000\
\047\000\000\000\000\000\061\000\061\000\061\000\061\000\030\000\
\061\000\031\000\000\000\061\000\000\000\000\000\000\000\000\000\
\061\000\061\000\061\000\061\000\032\000\061\000\061\000\061\000\
\061\000\061\000\000\000\000\000\000\000\033\000\061\000\061\000\
\000\000\061\000\061\000\061\000\000\000\061\000\051\000\051\000\
\051\000\034\000\051\000\051\000\051\000\051\000\000\000\000\000\
\000\000\051\000\051\000\000\000\000\000\051\000\051\000\000\000\
\056\000\000\000\000\000\051\000\051\000\051\000\051\000\000\000\
\051\000\000\000\000\000\051\000\000\000\000\000\000\000\000\000\
\051\000\051\000\051\000\051\000\000\000\051\000\051\000\051\000\
\051\000\051\000\000\000\000\000\000\000\000\000\051\000\051\000\
\000\000\051\000\051\000\051\000\000\000\051\000\050\000\050\000\
\050\000\000\000\050\000\050\000\050\000\050\000\000\000\000\000\
\000\000\050\000\050\000\000\000\000\000\050\000\050\000\000\000\
\067\000\000\000\000\000\050\000\050\000\050\000\050\000\000\000\
\050\000\000\000\000\000\050\000\000\000\000\000\000\000\000\000\
\050\000\050\000\050\000\050\000\000\000\050\000\050\000\050\000\
\050\000\050\000\000\000\000\000\000\000\000\000\050\000\050\000\
\000\000\050\000\050\000\050\000\000\000\050\000\049\000\049\000\
\049\000\000\000\049\000\049\000\049\000\049\000\000\000\000\000\
\000\000\049\000\049\000\000\000\052\000\049\000\049\000\000\000\
\000\000\000\000\000\000\049\000\049\000\049\000\049\000\000\000\
\049\000\000\000\000\000\049\000\000\000\000\000\000\000\000\000\
\049\000\049\000\049\000\049\000\000\000\049\000\049\000\049\000\
\049\000\049\000\000\000\000\000\000\000\000\000\049\000\049\000\
\000\000\049\000\049\000\049\000\000\000\049\000\048\000\048\000\
\048\000\000\000\000\000\048\000\048\000\048\000\000\000\000\000\
\053\000\048\000\048\000\000\000\000\000\048\000\048\000\000\000\
\000\000\000\000\000\000\048\000\048\000\048\000\048\000\000\000\
\048\000\000\000\000\000\048\000\000\000\000\000\000\000\000\000\
\048\000\048\000\048\000\048\000\000\000\048\000\048\000\000\000\
\048\000\048\000\000\000\055\000\000\000\000\000\048\000\048\000\
\000\000\000\000\048\000\000\000\000\000\048\000\047\000\047\000\
\047\000\000\000\000\000\047\000\047\000\047\000\000\000\000\000\
\000\000\047\000\047\000\054\000\000\000\047\000\047\000\000\000\
\000\000\000\000\000\000\047\000\047\000\047\000\047\000\000\000\
\047\000\000\000\000\000\047\000\000\000\000\000\000\000\000\000\
\047\000\047\000\047\000\047\000\000\000\047\000\047\000\000\000\
\047\000\047\000\000\000\000\000\000\000\000\000\047\000\047\000\
\000\000\000\000\047\000\000\000\000\000\047\000\056\000\056\000\
\056\000\000\000\000\000\056\000\056\000\056\000\000\000\069\000\
\000\000\056\000\056\000\000\000\000\000\056\000\056\000\000\000\
\000\000\000\000\000\000\056\000\056\000\056\000\056\000\000\000\
\056\000\000\000\000\000\056\000\000\000\000\000\000\000\071\000\
\056\000\056\000\056\000\051\000\000\000\056\000\056\000\052\000\
\000\000\056\000\000\000\000\000\000\000\000\000\056\000\056\000\
\000\000\000\000\056\000\000\000\000\000\056\000\067\000\067\000\
\067\000\000\000\000\000\067\000\067\000\067\000\000\000\058\000\
\000\000\067\000\067\000\000\000\061\000\067\000\068\000\000\000\
\064\000\065\000\000\000\067\000\000\000\067\000\000\000\000\000\
\067\000\000\000\066\000\000\000\067\000\000\000\000\000\000\000\
\067\000\067\000\000\000\000\000\000\000\030\000\067\000\000\000\
\000\000\067\000\000\000\000\000\015\000\000\000\067\000\067\000\
\000\000\000\000\067\000\052\000\052\000\067\000\000\000\052\000\
\052\000\052\000\000\000\000\000\000\000\052\000\052\000\000\000\
\000\000\052\000\000\000\011\000\000\000\000\000\040\000\052\000\
\000\000\052\000\000\000\000\000\052\000\082\000\000\000\000\000\
\000\000\000\000\000\000\000\000\052\000\052\000\000\000\000\000\
\000\000\000\000\052\000\000\000\000\000\052\000\000\000\000\000\
\000\000\000\000\052\000\052\000\029\000\000\000\052\000\053\000\
\053\000\052\000\000\000\053\000\053\000\053\000\012\000\000\000\
\000\000\053\000\053\000\000\000\000\000\053\000\000\000\000\000\
\000\000\000\000\000\000\053\000\010\000\053\000\000\000\000\000\
\053\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\053\000\053\000\055\000\000\000\000\000\000\000\055\000\055\000\
\055\000\053\000\000\000\000\000\055\000\055\000\053\000\053\000\
\055\000\000\000\053\000\000\000\000\000\053\000\055\000\000\000\
\055\000\000\000\054\000\055\000\000\000\000\000\054\000\054\000\
\054\000\000\000\000\000\055\000\054\000\054\000\000\000\000\000\
\054\000\000\000\000\000\000\000\055\000\000\000\054\000\000\000\
\054\000\055\000\055\000\054\000\000\000\055\000\000\000\000\000\
\055\000\000\000\000\000\054\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\054\000\000\000\000\000\000\000\
\000\000\054\000\054\000\000\000\000\000\054\000\069\000\000\000\
\054\000\000\000\069\000\069\000\069\000\000\000\000\000\000\000\
\069\000\069\000\000\000\000\000\069\000\000\000\000\000\000\000\
\000\000\000\000\069\000\000\000\069\000\000\000\071\000\069\000\
\000\000\000\000\071\000\071\000\071\000\000\000\000\000\069\000\
\071\000\071\000\000\000\000\000\071\000\000\000\000\000\000\000\
\069\000\000\000\071\000\000\000\071\000\069\000\069\000\071\000\
\000\000\069\000\000\000\000\000\069\000\000\000\000\000\071\000\
\000\000\000\000\000\000\000\000\000\000\068\000\000\000\000\000\
\071\000\068\000\068\000\068\000\000\000\071\000\071\000\068\000\
\068\000\071\000\000\000\068\000\071\000\000\000\000\000\000\000\
\000\000\068\000\000\000\068\000\000\000\031\000\068\000\000\000\
\030\000\030\000\000\000\000\000\000\000\000\000\068\000\015\000\
\015\000\000\000\000\000\000\000\000\000\000\000\000\000\068\000\
\030\000\000\000\030\000\000\000\068\000\068\000\000\000\015\000\
\068\000\015\000\000\000\068\000\000\000\030\000\011\000\011\000\
\000\000\040\000\040\000\000\000\015\000\000\000\030\000\000\000\
\082\000\082\000\000\000\000\000\000\000\015\000\011\000\000\000\
\011\000\040\000\030\000\040\000\000\000\000\000\000\000\000\000\
\082\000\015\000\082\000\011\000\000\000\000\000\040\000\029\000\
\029\000\000\000\000\000\000\000\011\000\082\000\000\000\040\000\
\000\000\012\000\012\000\000\000\000\000\000\000\082\000\029\000\
\011\000\029\000\000\000\040\000\000\000\000\000\000\000\010\000\
\010\000\012\000\082\000\012\000\029\000\000\000\000\000\000\000\
\005\000\006\000\000\000\007\000\008\000\029\000\012\000\010\000\
\000\000\010\000\000\000\000\000\000\000\000\000\000\000\012\000\
\000\000\029\000\009\000\000\000\010\000\000\000\010\000\011\000\
\012\000\013\000\000\000\012\000\000\000\010\000\014\000\000\000\
\000\000\000\000\000\000\015\000\016\000\017\000\000\000\000\000\
\000\000\010\000\018\000\019\000\049\000\000\000\050\000\000\000\
\051\000\000\000\000\000\000\000\052\000\000\000\000\000\053\000\
\000\000\000\000\000\000\020\000\054\000\000\000\000\000\000\000\
\000\000\000\000\055\000\000\000\056\000\000\000\000\000\000\000\
\000\000\057\000\000\000\000\000\058\000\000\000\000\000\059\000\
\060\000\061\000\000\000\062\000\063\000\064\000\065\000\000\000\
\049\000\000\000\050\000\000\000\051\000\000\000\000\000\066\000\
\052\000\067\000\000\000\000\000\000\000\000\000\000\000\000\000\
\054\000\000\000\000\000\000\000\000\000\000\000\055\000\000\000\
\056\000\000\000\000\000\000\000\000\000\057\000\000\000\000\000\
\058\000\000\000\000\000\059\000\060\000\061\000\000\000\062\000\
\063\000\064\000\065\000\000\000\000\000\000\000\049\000\000\000\
\050\000\000\000\051\000\066\000\089\000\067\000\052\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\054\000\000\000\
\000\000\000\000\000\000\000\000\055\000\000\000\056\000\000\000\
\000\000\000\000\000\000\057\000\000\000\000\000\058\000\000\000\
\000\000\059\000\060\000\061\000\000\000\062\000\063\000\064\000\
\065\000\000\000\000\000\000\000\000\000\000\000\091\000\000\000\
\049\000\066\000\050\000\067\000\051\000\000\000\000\000\000\000\
\052\000\000\000\000\000\124\000\000\000\000\000\000\000\000\000\
\054\000\000\000\000\000\000\000\000\000\000\000\055\000\000\000\
\056\000\000\000\000\000\000\000\000\000\057\000\000\000\000\000\
\058\000\000\000\000\000\059\000\060\000\061\000\000\000\062\000\
\063\000\064\000\065\000\000\000\049\000\000\000\050\000\000\000\
\051\000\000\000\000\000\066\000\052\000\067\000\000\000\145\000\
\000\000\000\000\000\000\000\000\054\000\000\000\000\000\000\000\
\000\000\000\000\055\000\000\000\056\000\000\000\000\000\000\000\
\000\000\057\000\000\000\000\000\058\000\000\000\000\000\059\000\
\060\000\061\000\000\000\062\000\063\000\064\000\065\000\000\000\
\049\000\000\000\050\000\000\000\051\000\000\000\000\000\066\000\
\052\000\067\000\000\000\000\000\000\000\000\000\000\000\171\000\
\054\000\000\000\000\000\000\000\000\000\000\000\055\000\000\000\
\056\000\000\000\000\000\000\000\000\000\057\000\000\000\000\000\
\058\000\000\000\000\000\059\000\060\000\061\000\000\000\062\000\
\063\000\064\000\065\000\000\000\049\000\000\000\050\000\000\000\
\051\000\000\000\000\000\066\000\052\000\067\000\000\000\000\000\
\000\000\000\000\000\000\000\000\054\000\000\000\000\000\000\000\
\000\000\000\000\055\000\000\000\056\000\000\000\172\000\000\000\
\000\000\057\000\000\000\000\000\058\000\000\000\000\000\059\000\
\060\000\061\000\000\000\062\000\063\000\064\000\065\000\000\000\
\049\000\000\000\050\000\000\000\051\000\000\000\000\000\066\000\
\052\000\067\000\000\000\000\000\179\000\000\000\000\000\000\000\
\054\000\000\000\000\000\000\000\000\000\000\000\055\000\000\000\
\056\000\000\000\000\000\000\000\000\000\057\000\000\000\000\000\
\058\000\000\000\000\000\059\000\060\000\061\000\000\000\062\000\
\063\000\064\000\065\000\000\000\049\000\141\000\050\000\000\000\
\051\000\000\000\000\000\066\000\052\000\067\000\000\000\000\000\
\000\000\000\000\000\000\000\000\054\000\000\000\000\000\000\000\
\000\000\000\000\055\000\000\000\056\000\000\000\000\000\000\000\
\000\000\057\000\000\000\000\000\058\000\000\000\000\000\059\000\
\060\000\061\000\000\000\062\000\063\000\064\000\065\000\000\000\
\049\000\000\000\050\000\000\000\051\000\000\000\000\000\066\000\
\052\000\067\000\000\000\000\000\000\000\000\000\000\000\000\000\
\054\000\000\000\000\000\000\000\000\000\000\000\055\000\000\000\
\056\000\000\000\000\000\000\000\000\000\057\000\049\000\000\000\
\058\000\000\000\051\000\059\000\060\000\061\000\052\000\062\000\
\063\000\064\000\065\000\000\000\000\000\000\000\054\000\000\000\
\000\000\000\000\000\000\066\000\055\000\067\000\056\000\000\000\
\000\000\000\000\000\000\057\000\049\000\000\000\058\000\000\000\
\051\000\000\000\060\000\061\000\052\000\062\000\063\000\064\000\
\065\000\000\000\000\000\000\000\054\000\000\000\000\000\000\000\
\000\000\066\000\055\000\067\000\056\000\000\000\000\000\000\000\
\000\000\057\000\000\000\000\000\058\000\000\000\051\000\000\000\
\060\000\061\000\052\000\062\000\000\000\064\000\065\000\000\000\
\000\000\000\000\054\000\000\000\000\000\000\000\000\000\066\000\
\055\000\067\000\056\000\000\000\000\000\000\000\000\000\057\000\
\000\000\000\000\058\000\000\000\000\000\000\000\060\000\061\000\
\000\000\062\000\000\000\064\000\065\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\066\000\000\000\067\000"

let yycheck = "\008\001\
\000\000\053\000\010\001\034\000\001\001\017\001\014\001\001\001\
\001\001\014\001\002\000\087\000\088\000\017\001\010\000\155\000\
\037\001\013\000\001\001\015\000\037\001\000\000\014\000\013\000\
\016\000\001\001\018\000\019\000\013\001\022\001\038\001\027\000\
\028\000\038\001\030\000\031\000\001\001\033\000\034\000\047\001\
\037\001\017\001\009\001\055\001\038\001\054\001\038\000\078\000\
\022\001\057\001\054\001\059\001\016\001\193\000\051\001\020\001\
\000\000\049\000\050\000\051\000\000\000\000\000\017\001\037\001\
\016\001\016\001\058\000\059\000\022\001\061\000\002\001\063\000\
\064\000\065\000\066\000\067\000\068\000\069\000\070\000\155\000\
\076\000\038\001\016\001\079\000\037\001\081\000\076\000\001\000\
\002\000\003\000\086\000\087\000\088\000\145\000\039\001\016\001\
\086\000\089\000\090\000\016\001\022\001\051\001\013\001\002\001\
\180\000\001\001\054\001\017\001\055\001\016\001\001\001\054\001\
\000\000\017\001\054\001\001\001\000\000\055\001\114\000\015\001\
\112\000\113\000\118\000\115\000\015\001\117\000\122\000\158\000\
\204\000\015\001\206\000\016\001\124\000\038\001\130\000\017\001\
\054\001\033\001\034\001\135\000\136\000\037\001\033\001\034\001\
\017\001\054\001\037\001\033\001\034\001\141\000\013\001\037\001\
\144\000\002\001\050\001\051\001\052\001\053\001\020\001\155\000\
\051\001\052\001\053\001\159\000\050\001\051\001\052\001\053\001\
\000\000\165\000\002\001\054\001\000\000\016\001\008\001\167\000\
\022\001\055\001\013\001\171\000\172\000\055\001\000\000\001\001\
\180\000\056\001\182\000\179\000\000\000\185\000\016\001\055\001\
\020\001\054\001\054\001\191\000\054\001\193\000\194\000\054\001\
\054\001\006\001\007\001\008\001\008\001\010\001\198\000\203\000\
\204\000\014\001\206\000\055\001\054\001\001\000\037\000\207\000\
\191\000\022\001\118\000\179\000\216\000\158\000\218\000\028\001\
\000\000\030\001\182\000\144\000\000\000\221\000\035\001\124\000\
\212\000\038\001\255\255\255\255\041\001\042\001\043\001\255\255\
\045\001\046\001\047\001\048\001\255\255\255\255\255\255\255\255\
\255\255\255\255\055\001\255\255\057\001\255\255\059\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\006\001\007\001\
\008\001\255\255\010\001\011\001\012\001\013\001\014\001\255\255\
\016\001\017\001\018\001\255\255\255\255\021\001\022\001\255\255\
\000\000\255\255\255\255\027\001\028\001\029\001\030\001\255\255\
\032\001\255\255\013\001\035\001\255\255\037\001\038\001\255\255\
\040\001\041\001\042\001\043\001\255\255\045\001\046\001\047\001\
\048\001\049\001\255\255\255\255\255\255\255\255\054\001\055\001\
\255\255\057\001\058\001\059\001\255\255\061\001\006\001\007\001\
\008\001\255\255\010\001\011\001\012\001\013\001\014\001\011\001\
\012\001\017\001\018\001\054\001\055\001\021\001\022\001\255\255\
\000\000\255\255\255\255\027\001\028\001\029\001\030\001\027\001\
\032\001\029\001\255\255\035\001\255\255\255\255\038\001\255\255\
\040\001\041\001\042\001\043\001\040\001\045\001\046\001\047\001\
\048\001\049\001\255\255\255\255\255\255\049\001\054\001\055\001\
\255\255\057\001\058\001\059\001\255\255\061\001\006\001\007\001\
\008\001\061\001\010\001\011\001\012\001\013\001\014\001\011\001\
\012\001\017\001\018\001\255\255\255\255\021\001\022\001\255\255\
\000\000\255\255\255\255\027\001\028\001\029\001\030\001\027\001\
\032\001\029\001\255\255\035\001\255\255\255\255\255\255\255\255\
\040\001\041\001\042\001\043\001\040\001\045\001\046\001\047\001\
\048\001\049\001\255\255\255\255\255\255\049\001\054\001\055\001\
\255\255\057\001\058\001\059\001\255\255\061\001\006\001\007\001\
\008\001\061\001\010\001\011\001\012\001\013\001\014\001\011\001\
\012\001\017\001\018\001\255\255\255\255\021\001\022\001\255\255\
\000\000\255\255\255\255\027\001\028\001\029\001\030\001\027\001\
\032\001\029\001\255\255\035\001\255\255\255\255\255\255\255\255\
\040\001\041\001\042\001\043\001\040\001\045\001\046\001\047\001\
\048\001\049\001\255\255\255\255\255\255\049\001\054\001\055\001\
\255\255\057\001\058\001\059\001\255\255\061\001\006\001\007\001\
\008\001\061\001\010\001\011\001\012\001\013\001\014\001\011\001\
\012\001\017\001\018\001\255\255\255\255\021\001\022\001\255\255\
\000\000\255\255\255\255\027\001\028\001\029\001\030\001\027\001\
\032\001\029\001\255\255\035\001\255\255\255\255\255\255\255\255\
\040\001\041\001\042\001\043\001\040\001\045\001\046\001\047\001\
\048\001\049\001\255\255\255\255\255\255\049\001\054\001\055\001\
\255\255\057\001\058\001\059\001\255\255\061\001\006\001\007\001\
\008\001\061\001\010\001\011\001\012\001\013\001\255\255\011\001\
\012\001\017\001\018\001\255\255\255\255\021\001\022\001\255\255\
\000\000\255\255\255\255\027\001\028\001\029\001\030\001\027\001\
\032\001\029\001\255\255\035\001\255\255\255\255\255\255\255\255\
\040\001\041\001\042\001\043\001\040\001\045\001\046\001\047\001\
\048\001\049\001\255\255\255\255\255\255\049\001\054\001\055\001\
\255\255\057\001\058\001\059\001\255\255\061\001\006\001\007\001\
\008\001\061\001\010\001\011\001\012\001\013\001\255\255\255\255\
\255\255\017\001\018\001\255\255\255\255\021\001\022\001\255\255\
\000\000\255\255\255\255\027\001\028\001\029\001\030\001\255\255\
\032\001\255\255\255\255\035\001\255\255\255\255\255\255\255\255\
\040\001\041\001\042\001\043\001\255\255\045\001\046\001\047\001\
\048\001\049\001\255\255\255\255\255\255\255\255\054\001\055\001\
\255\255\057\001\058\001\059\001\255\255\061\001\006\001\007\001\
\008\001\255\255\010\001\011\001\012\001\013\001\255\255\255\255\
\255\255\017\001\018\001\255\255\255\255\021\001\022\001\255\255\
\000\000\255\255\255\255\027\001\028\001\029\001\030\001\255\255\
\032\001\255\255\255\255\035\001\255\255\255\255\255\255\255\255\
\040\001\041\001\042\001\043\001\255\255\045\001\046\001\047\001\
\048\001\049\001\255\255\255\255\255\255\255\255\054\001\055\001\
\255\255\057\001\058\001\059\001\255\255\061\001\006\001\007\001\
\008\001\255\255\010\001\011\001\012\001\013\001\255\255\255\255\
\255\255\017\001\018\001\255\255\000\000\021\001\022\001\255\255\
\255\255\255\255\255\255\027\001\028\001\029\001\030\001\255\255\
\032\001\255\255\255\255\035\001\255\255\255\255\255\255\255\255\
\040\001\041\001\042\001\043\001\255\255\045\001\046\001\047\001\
\048\001\049\001\255\255\255\255\255\255\255\255\054\001\055\001\
\255\255\057\001\058\001\059\001\255\255\061\001\006\001\007\001\
\008\001\255\255\255\255\011\001\012\001\013\001\255\255\255\255\
\000\000\017\001\018\001\255\255\255\255\021\001\022\001\255\255\
\255\255\255\255\255\255\027\001\028\001\029\001\030\001\255\255\
\032\001\255\255\255\255\035\001\255\255\255\255\255\255\255\255\
\040\001\041\001\042\001\043\001\255\255\045\001\046\001\255\255\
\048\001\049\001\255\255\000\000\255\255\255\255\054\001\055\001\
\255\255\255\255\058\001\255\255\255\255\061\001\006\001\007\001\
\008\001\255\255\255\255\011\001\012\001\013\001\255\255\255\255\
\255\255\017\001\018\001\000\000\255\255\021\001\022\001\255\255\
\255\255\255\255\255\255\027\001\028\001\029\001\030\001\255\255\
\032\001\255\255\255\255\035\001\255\255\255\255\255\255\255\255\
\040\001\041\001\042\001\043\001\255\255\045\001\046\001\255\255\
\048\001\049\001\255\255\255\255\255\255\255\255\054\001\055\001\
\255\255\255\255\058\001\255\255\255\255\061\001\006\001\007\001\
\008\001\255\255\255\255\011\001\012\001\013\001\255\255\000\000\
\255\255\017\001\018\001\255\255\255\255\021\001\022\001\255\255\
\255\255\255\255\255\255\027\001\028\001\029\001\030\001\255\255\
\032\001\255\255\255\255\035\001\255\255\255\255\255\255\000\000\
\040\001\041\001\042\001\010\001\255\255\045\001\046\001\014\001\
\255\255\049\001\255\255\255\255\255\255\255\255\054\001\055\001\
\255\255\255\255\058\001\255\255\255\255\061\001\006\001\007\001\
\008\001\255\255\255\255\011\001\012\001\013\001\255\255\038\001\
\255\255\017\001\018\001\255\255\043\001\021\001\000\000\255\255\
\047\001\048\001\255\255\027\001\255\255\029\001\255\255\255\255\
\032\001\255\255\057\001\255\255\059\001\255\255\255\255\255\255\
\040\001\041\001\255\255\255\255\255\255\000\000\046\001\255\255\
\255\255\049\001\255\255\255\255\000\000\255\255\054\001\055\001\
\255\255\255\255\058\001\007\001\008\001\061\001\255\255\011\001\
\012\001\013\001\255\255\255\255\255\255\017\001\018\001\255\255\
\255\255\021\001\255\255\000\000\255\255\255\255\000\000\027\001\
\255\255\029\001\255\255\255\255\032\001\000\000\255\255\255\255\
\255\255\255\255\255\255\255\255\040\001\041\001\255\255\255\255\
\255\255\255\255\046\001\255\255\255\255\049\001\255\255\255\255\
\255\255\255\255\054\001\055\001\000\000\255\255\058\001\007\001\
\008\001\061\001\255\255\011\001\012\001\013\001\000\000\255\255\
\255\255\017\001\018\001\255\255\255\255\021\001\255\255\255\255\
\255\255\255\255\255\255\027\001\000\000\029\001\255\255\255\255\
\032\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\040\001\041\001\007\001\255\255\255\255\255\255\011\001\012\001\
\013\001\049\001\255\255\255\255\017\001\018\001\054\001\055\001\
\021\001\255\255\058\001\255\255\255\255\061\001\027\001\255\255\
\029\001\255\255\007\001\032\001\255\255\255\255\011\001\012\001\
\013\001\255\255\255\255\040\001\017\001\018\001\255\255\255\255\
\021\001\255\255\255\255\255\255\049\001\255\255\027\001\255\255\
\029\001\054\001\055\001\032\001\255\255\058\001\255\255\255\255\
\061\001\255\255\255\255\040\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\049\001\255\255\255\255\255\255\
\255\255\054\001\055\001\255\255\255\255\058\001\007\001\255\255\
\061\001\255\255\011\001\012\001\013\001\255\255\255\255\255\255\
\017\001\018\001\255\255\255\255\021\001\255\255\255\255\255\255\
\255\255\255\255\027\001\255\255\029\001\255\255\007\001\032\001\
\255\255\255\255\011\001\012\001\013\001\255\255\255\255\040\001\
\017\001\018\001\255\255\255\255\021\001\255\255\255\255\255\255\
\049\001\255\255\027\001\255\255\029\001\054\001\055\001\032\001\
\255\255\058\001\255\255\255\255\061\001\255\255\255\255\040\001\
\255\255\255\255\255\255\255\255\255\255\007\001\255\255\255\255\
\049\001\011\001\012\001\013\001\255\255\054\001\055\001\017\001\
\018\001\058\001\255\255\021\001\061\001\255\255\255\255\255\255\
\255\255\027\001\255\255\029\001\255\255\008\001\032\001\255\255\
\011\001\012\001\255\255\255\255\255\255\255\255\040\001\011\001\
\012\001\255\255\255\255\255\255\255\255\255\255\255\255\049\001\
\027\001\255\255\029\001\255\255\054\001\055\001\255\255\027\001\
\058\001\029\001\255\255\061\001\255\255\040\001\011\001\012\001\
\255\255\011\001\012\001\255\255\040\001\255\255\049\001\255\255\
\011\001\012\001\255\255\255\255\255\255\049\001\027\001\255\255\
\029\001\027\001\061\001\029\001\255\255\255\255\255\255\255\255\
\027\001\061\001\029\001\040\001\255\255\255\255\040\001\011\001\
\012\001\255\255\255\255\255\255\049\001\040\001\255\255\049\001\
\255\255\011\001\012\001\255\255\255\255\255\255\049\001\027\001\
\061\001\029\001\255\255\061\001\255\255\255\255\255\255\011\001\
\012\001\027\001\061\001\029\001\040\001\255\255\255\255\255\255\
\001\001\002\001\255\255\004\001\005\001\049\001\040\001\027\001\
\255\255\029\001\255\255\255\255\255\255\255\255\255\255\049\001\
\255\255\061\001\019\001\255\255\040\001\255\255\023\001\024\001\
\025\001\026\001\255\255\061\001\255\255\049\001\031\001\255\255\
\255\255\255\255\255\255\036\001\037\001\038\001\255\255\255\255\
\255\255\061\001\043\001\044\001\006\001\255\255\008\001\255\255\
\010\001\255\255\255\255\255\255\014\001\255\255\255\255\017\001\
\255\255\255\255\255\255\060\001\022\001\255\255\255\255\255\255\
\255\255\255\255\028\001\255\255\030\001\255\255\255\255\255\255\
\255\255\035\001\255\255\255\255\038\001\255\255\255\255\041\001\
\042\001\043\001\255\255\045\001\046\001\047\001\048\001\255\255\
\006\001\255\255\008\001\255\255\010\001\255\255\255\255\057\001\
\014\001\059\001\255\255\255\255\255\255\255\255\255\255\255\255\
\022\001\255\255\255\255\255\255\255\255\255\255\028\001\255\255\
\030\001\255\255\255\255\255\255\255\255\035\001\255\255\255\255\
\038\001\255\255\255\255\041\001\042\001\043\001\255\255\045\001\
\046\001\047\001\048\001\255\255\255\255\255\255\006\001\255\255\
\008\001\255\255\010\001\057\001\058\001\059\001\014\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\022\001\255\255\
\255\255\255\255\255\255\255\255\028\001\255\255\030\001\255\255\
\255\255\255\255\255\255\035\001\255\255\255\255\038\001\255\255\
\255\255\041\001\042\001\043\001\255\255\045\001\046\001\047\001\
\048\001\255\255\255\255\255\255\255\255\255\255\054\001\255\255\
\006\001\057\001\008\001\059\001\010\001\255\255\255\255\255\255\
\014\001\255\255\255\255\017\001\255\255\255\255\255\255\255\255\
\022\001\255\255\255\255\255\255\255\255\255\255\028\001\255\255\
\030\001\255\255\255\255\255\255\255\255\035\001\255\255\255\255\
\038\001\255\255\255\255\041\001\042\001\043\001\255\255\045\001\
\046\001\047\001\048\001\255\255\006\001\255\255\008\001\255\255\
\010\001\255\255\255\255\057\001\014\001\059\001\255\255\017\001\
\255\255\255\255\255\255\255\255\022\001\255\255\255\255\255\255\
\255\255\255\255\028\001\255\255\030\001\255\255\255\255\255\255\
\255\255\035\001\255\255\255\255\038\001\255\255\255\255\041\001\
\042\001\043\001\255\255\045\001\046\001\047\001\048\001\255\255\
\006\001\255\255\008\001\255\255\010\001\255\255\255\255\057\001\
\014\001\059\001\255\255\255\255\255\255\255\255\255\255\021\001\
\022\001\255\255\255\255\255\255\255\255\255\255\028\001\255\255\
\030\001\255\255\255\255\255\255\255\255\035\001\255\255\255\255\
\038\001\255\255\255\255\041\001\042\001\043\001\255\255\045\001\
\046\001\047\001\048\001\255\255\006\001\255\255\008\001\255\255\
\010\001\255\255\255\255\057\001\014\001\059\001\255\255\255\255\
\255\255\255\255\255\255\255\255\022\001\255\255\255\255\255\255\
\255\255\255\255\028\001\255\255\030\001\255\255\032\001\255\255\
\255\255\035\001\255\255\255\255\038\001\255\255\255\255\041\001\
\042\001\043\001\255\255\045\001\046\001\047\001\048\001\255\255\
\006\001\255\255\008\001\255\255\010\001\255\255\255\255\057\001\
\014\001\059\001\255\255\255\255\018\001\255\255\255\255\255\255\
\022\001\255\255\255\255\255\255\255\255\255\255\028\001\255\255\
\030\001\255\255\255\255\255\255\255\255\035\001\255\255\255\255\
\038\001\255\255\255\255\041\001\042\001\043\001\255\255\045\001\
\046\001\047\001\048\001\255\255\006\001\007\001\008\001\255\255\
\010\001\255\255\255\255\057\001\014\001\059\001\255\255\255\255\
\255\255\255\255\255\255\255\255\022\001\255\255\255\255\255\255\
\255\255\255\255\028\001\255\255\030\001\255\255\255\255\255\255\
\255\255\035\001\255\255\255\255\038\001\255\255\255\255\041\001\
\042\001\043\001\255\255\045\001\046\001\047\001\048\001\255\255\
\006\001\255\255\008\001\255\255\010\001\255\255\255\255\057\001\
\014\001\059\001\255\255\255\255\255\255\255\255\255\255\255\255\
\022\001\255\255\255\255\255\255\255\255\255\255\028\001\255\255\
\030\001\255\255\255\255\255\255\255\255\035\001\006\001\255\255\
\038\001\255\255\010\001\041\001\042\001\043\001\014\001\045\001\
\046\001\047\001\048\001\255\255\255\255\255\255\022\001\255\255\
\255\255\255\255\255\255\057\001\028\001\059\001\030\001\255\255\
\255\255\255\255\255\255\035\001\006\001\255\255\038\001\255\255\
\010\001\255\255\042\001\043\001\014\001\045\001\046\001\047\001\
\048\001\255\255\255\255\255\255\022\001\255\255\255\255\255\255\
\255\255\057\001\028\001\059\001\030\001\255\255\255\255\255\255\
\255\255\035\001\255\255\255\255\038\001\255\255\010\001\255\255\
\042\001\043\001\014\001\045\001\255\255\047\001\048\001\255\255\
\255\255\255\255\022\001\255\255\255\255\255\255\255\255\057\001\
\028\001\059\001\030\001\255\255\255\255\255\255\255\255\035\001\
\255\255\255\255\038\001\255\255\255\255\255\255\042\001\043\001\
\255\255\045\001\255\255\047\001\048\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\057\001\255\255\059\001"

let yynames_const = "\
  AND\000\
  LEFTARROW\000\
  ARROW\000\
  AC\000\
  AT\000\
  AXIOM\000\
  REWRITING\000\
  BAR\000\
  HAT\000\
  BOOL\000\
  COLON\000\
  COMMA\000\
  PV\000\
  DISTINCT\000\
  DOT\000\
  ELSE\000\
  EOF\000\
  EQUAL\000\
  EXISTS\000\
  FALSE\000\
  VOID\000\
  FORALL\000\
  FUNCTION\000\
  GE\000\
  GOAL\000\
  GT\000\
  IF\000\
  IN\000\
  INT\000\
  BITV\000\
  LE\000\
  LET\000\
  LEFTPAR\000\
  LEFTSQ\000\
  LEFTBR\000\
  LOGIC\000\
  LRARROW\000\
  LT\000\
  MINUS\000\
  NOT\000\
  NOTEQ\000\
  OR\000\
  PERCENT\000\
  PLUS\000\
  PREDICATE\000\
  PROP\000\
  QUOTE\000\
  REAL\000\
  UNIT\000\
  RIGHTPAR\000\
  RIGHTSQ\000\
  RIGHTBR\000\
  SLASH\000\
  THEN\000\
  TIMES\000\
  TRUE\000\
  TYPE\000\
  "

let yynames_block = "\
  IDENT\000\
  INTEGER\000\
  FLOAT\000\
  NUM\000\
  STRING\000\
  "

let yyact = [|
  (fun _ -> failwith "parser")
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'list1_decl) in
    Obj.repr(
# 109 "why_parser.mly"
   ( _1 )
# 855 "why_parser.ml"
               : Why_ptree.file))
; (fun __caml_parser_env ->
    Obj.repr(
# 111 "why_parser.mly"
   ( [] )
# 861 "why_parser.ml"
               : Why_ptree.file))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'decl) in
    Obj.repr(
# 116 "why_parser.mly"
   ( [_1] )
# 868 "why_parser.ml"
               : 'list1_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'decl) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'list1_decl) in
    Obj.repr(
# 118 "why_parser.mly"
   ( _1 :: _2 )
# 876 "why_parser.ml"
               : 'list1_decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 124 "why_parser.mly"
   ( TypeDecl (loc_i 2, [], _2, []) )
# 883 "why_parser.ml"
               : 'decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'list1_constructors_sep_bar) in
    Obj.repr(
# 127 "why_parser.mly"
   ( TypeDecl (loc_i 2,[], _2, _4 ) )
# 891 "why_parser.ml"
               : 'decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'type_var) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 130 "why_parser.mly"
   ( TypeDecl (loc_ij 1 2, [_2], _3, []) )
# 899 "why_parser.ml"
               : 'decl))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'list1_type_var_sep_comma) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 132 "why_parser.mly"
   ( TypeDecl (loc_ij 2 5, _3, _5, []) )
# 907 "why_parser.ml"
               : 'decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'ac_modifier) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'list1_ident_sep_comma) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'logic_type) in
    Obj.repr(
# 136 "why_parser.mly"
   ( Logic (loc (), _2, _3, _5) )
# 916 "why_parser.ml"
               : 'decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 7 : 'ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 5 : 'list0_logic_binder_sep_comma) in
    let _7 = (Parsing.peek_val __caml_parser_env 2 : 'primitive_type) in
    let _9 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 139 "why_parser.mly"
   ( Function_def (loc (), _2, _4, _7, _9) )
# 926 "why_parser.ml"
               : 'decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 141 "why_parser.mly"
   ( Predicate_def (loc (), _2, [], _4) )
# 934 "why_parser.ml"
               : 'decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'list0_logic_binder_sep_comma) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 143 "why_parser.mly"
   ( Predicate_def (loc (), _2, _4, _7) )
# 943 "why_parser.ml"
               : 'decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 145 "why_parser.mly"
   ( Axiom (loc (), _2, _4) )
# 951 "why_parser.ml"
               : 'decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'list1_lexpr_sep_pv) in
    Obj.repr(
# 147 "why_parser.mly"
   ( Rewriting(loc (), _2, _4) )
# 959 "why_parser.ml"
               : 'decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 149 "why_parser.mly"
   ( Goal (loc (), _2, _4) )
# 967 "why_parser.ml"
               : 'decl))
; (fun __caml_parser_env ->
    Obj.repr(
# 153 "why_parser.mly"
        ( Symbols.Other )
# 973 "why_parser.ml"
               : 'ac_modifier))
; (fun __caml_parser_env ->
    Obj.repr(
# 154 "why_parser.mly"
        ( Symbols.Ac )
# 979 "why_parser.ml"
               : 'ac_modifier))
; (fun __caml_parser_env ->
    Obj.repr(
# 158 "why_parser.mly"
   ( PPTint )
# 985 "why_parser.ml"
               : 'primitive_type))
; (fun __caml_parser_env ->
    Obj.repr(
# 160 "why_parser.mly"
   ( PPTbool )
# 991 "why_parser.ml"
               : 'primitive_type))
; (fun __caml_parser_env ->
    Obj.repr(
# 162 "why_parser.mly"
   ( PPTreal )
# 997 "why_parser.ml"
               : 'primitive_type))
; (fun __caml_parser_env ->
    Obj.repr(
# 164 "why_parser.mly"
   ( PPTunit )
# 1003 "why_parser.ml"
               : 'primitive_type))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 166 "why_parser.mly"
   ( PPTbitv(int_of_string _3) )
# 1010 "why_parser.ml"
               : 'primitive_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 168 "why_parser.mly"
   ( PPTexternal ([], _1, loc ()) )
# 1017 "why_parser.ml"
               : 'primitive_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_var) in
    Obj.repr(
# 170 "why_parser.mly"
   ( PPTvarid (_1, loc ()) )
# 1024 "why_parser.ml"
               : 'primitive_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'primitive_type) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 172 "why_parser.mly"
   ( PPTexternal ([_1], _2, loc_i 2) )
# 1032 "why_parser.ml"
               : 'primitive_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'list1_primitive_type_sep_comma) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 174 "why_parser.mly"
   ( PPTexternal (_2, _4, loc_i 4) )
# 1040 "why_parser.ml"
               : 'primitive_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'list0_primitive_type_sep_comma) in
    Obj.repr(
# 179 "why_parser.mly"
   ( PPredicate _1 )
# 1047 "why_parser.ml"
               : 'logic_type))
; (fun __caml_parser_env ->
    Obj.repr(
# 181 "why_parser.mly"
   ( PPredicate [] )
# 1053 "why_parser.ml"
               : 'logic_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'list0_primitive_type_sep_comma) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'primitive_type) in
    Obj.repr(
# 183 "why_parser.mly"
   ( PFunction (_1, _3) )
# 1061 "why_parser.ml"
               : 'logic_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'primitive_type) in
    Obj.repr(
# 185 "why_parser.mly"
   ( PFunction ([], _1) )
# 1068 "why_parser.ml"
               : 'logic_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'primitive_type) in
    Obj.repr(
# 189 "why_parser.mly"
                                                      ( [_1] )
# 1075 "why_parser.ml"
               : 'list1_primitive_type_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'primitive_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'list1_primitive_type_sep_comma) in
    Obj.repr(
# 190 "why_parser.mly"
                                                      ( _1 :: _3 )
# 1083 "why_parser.ml"
               : 'list1_primitive_type_sep_comma))
; (fun __caml_parser_env ->
    Obj.repr(
# 194 "why_parser.mly"
                                 ( [] )
# 1089 "why_parser.ml"
               : 'list0_primitive_type_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'list1_primitive_type_sep_comma) in
    Obj.repr(
# 195 "why_parser.mly"
                                 ( _1 )
# 1096 "why_parser.ml"
               : 'list0_primitive_type_sep_comma))
; (fun __caml_parser_env ->
    Obj.repr(
# 199 "why_parser.mly"
                               ( [] )
# 1102 "why_parser.ml"
               : 'list0_logic_binder_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'list1_logic_binder_sep_comma) in
    Obj.repr(
# 200 "why_parser.mly"
                               ( _1 )
# 1109 "why_parser.ml"
               : 'list0_logic_binder_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'logic_binder) in
    Obj.repr(
# 204 "why_parser.mly"
                                                  ( [_1] )
# 1116 "why_parser.ml"
               : 'list1_logic_binder_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'logic_binder) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'list1_logic_binder_sep_comma) in
    Obj.repr(
# 205 "why_parser.mly"
                                                  ( _1 :: _3 )
# 1124 "why_parser.ml"
               : 'list1_logic_binder_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'primitive_type) in
    Obj.repr(
# 210 "why_parser.mly"
    ( (loc_i 1, _1, _3) )
# 1132 "why_parser.ml"
               : 'logic_binder))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 214 "why_parser.mly"
        ( [_1] )
# 1139 "why_parser.ml"
               : 'list1_constructors_sep_bar))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'list1_constructors_sep_bar) in
    Obj.repr(
# 215 "why_parser.mly"
                                       ( _1 :: _3)
# 1147 "why_parser.ml"
               : 'list1_constructors_sep_bar))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 223 "why_parser.mly"
   ( mk_pp (PPconst (ConstInt _1)) )
# 1154 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Num.num) in
    Obj.repr(
# 225 "why_parser.mly"
   ( mk_pp (PPconst (ConstReal _1)) )
# 1161 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    Obj.repr(
# 227 "why_parser.mly"
   ( mk_pp (PPconst ConstTrue) )
# 1167 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    Obj.repr(
# 229 "why_parser.mly"
   ( mk_pp (PPconst ConstFalse) )
# 1173 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    Obj.repr(
# 231 "why_parser.mly"
   ( mk_pp (PPconst ConstVoid) )
# 1179 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 237 "why_parser.mly"
   ( infix_pp _1 PPadd _3 )
# 1187 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 239 "why_parser.mly"
   ( infix_pp _1 PPsub _3 )
# 1195 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 241 "why_parser.mly"
   ( infix_pp _1 PPmul _3 )
# 1203 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 243 "why_parser.mly"
   ( infix_pp _1 PPdiv _3 )
# 1211 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 245 "why_parser.mly"
   ( infix_pp _1 PPmod _3 )
# 1219 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 247 "why_parser.mly"
   ( infix_pp _1 PPand _3 )
# 1227 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 249 "why_parser.mly"
   ( infix_pp _1 PPor _3 )
# 1235 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 251 "why_parser.mly"
   ( infix_pp _1 PPiff _3 )
# 1243 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 253 "why_parser.mly"
   ( infix_pp _1 PPimplies _3 )
# 1251 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'relation) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 255 "why_parser.mly"
   ( infix_pp _1 _2 _3 )
# 1260 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 260 "why_parser.mly"
   ( prefix_pp PPnot _2 )
# 1267 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 262 "why_parser.mly"
   ( prefix_pp PPneg _2 )
# 1274 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    Obj.repr(
# 267 "why_parser.mly"
    ( mk_pp (PPconst (ConstBitv (check_binary_mode _3))) )
# 1281 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : Why_ptree.lexpr) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 269 "why_parser.mly"
   ( let i =  mk_pp (PPconst (ConstInt _4)) in
     let j =  mk_pp (PPconst (ConstInt _6)) in
     mk_pp (PPextract (_1, i, j)) )
# 1292 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 273 "why_parser.mly"
   ( mk_pp (PPconcat(_1, _3)) )
# 1300 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : Why_ptree.lexpr) in
    Obj.repr(
# 278 "why_parser.mly"
    ( mk_pp(PPget(_1, _3)) )
# 1308 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'array_assignements) in
    Obj.repr(
# 280 "why_parser.mly"
    ( let acc, l = match _3 with
	| [] -> assert false
	| (i, v)::l -> mk_pp (PPset(_1, i, v)), l 
      in
      List.fold_left (fun acc (i,v) -> mk_pp (PPset(acc, i, v))) acc l
    )
# 1321 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 289 "why_parser.mly"
   ( mk_pp (PPvar _1) )
# 1328 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'list0_lexpr_sep_comma) in
    Obj.repr(
# 291 "why_parser.mly"
   ( mk_pp (PPapp (_1, _3)) )
# 1336 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'list2_lexpr_sep_comma) in
    Obj.repr(
# 293 "why_parser.mly"
   ( mk_pp (PPdistinct _3) )
# 1343 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : Why_ptree.lexpr) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 297 "why_parser.mly"
   ( mk_pp (PPif (_2, _4, _6)) )
# 1352 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'list1_ident_sep_comma) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'primitive_type) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'triggers) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 301 "why_parser.mly"
   ( mk_pp (PPforall (_2, _4, _5, _7)) )
# 1362 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'list1_ident_sep_comma) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'primitive_type) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 304 "why_parser.mly"
   ( mk_pp (PPexists (_2, _4, _6)) )
# 1371 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'ident_or_string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 307 "why_parser.mly"
   ( mk_pp (PPnamed (_1, _3)) )
# 1379 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 310 "why_parser.mly"
   ( mk_pp (PPlet (_2, _4, _6)) )
# 1388 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : Why_ptree.lexpr) in
    Obj.repr(
# 313 "why_parser.mly"
   ( _2 )
# 1395 "why_parser.ml"
               : Why_ptree.lexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'array_assignement) in
    Obj.repr(
# 317 "why_parser.mly"
                    ( [_1] )
# 1402 "why_parser.ml"
               : 'array_assignements))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'array_assignement) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'array_assignements) in
    Obj.repr(
# 318 "why_parser.mly"
                                             ( _1 :: _3 )
# 1410 "why_parser.ml"
               : 'array_assignements))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 322 "why_parser.mly"
                         ( _1, _3 )
# 1418 "why_parser.ml"
               : 'array_assignement))
; (fun __caml_parser_env ->
    Obj.repr(
# 326 "why_parser.mly"
                ( [] )
# 1424 "why_parser.ml"
               : 'triggers))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'list1_trigger_sep_bar) in
    Obj.repr(
# 327 "why_parser.mly"
                                       ( _2 )
# 1431 "why_parser.ml"
               : 'triggers))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr list) in
    Obj.repr(
# 331 "why_parser.mly"
          ( [_1] )
# 1438 "why_parser.ml"
               : 'list1_trigger_sep_bar))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'list1_trigger_sep_bar) in
    Obj.repr(
# 332 "why_parser.mly"
                                    ( _1 :: _3 )
# 1446 "why_parser.ml"
               : 'list1_trigger_sep_bar))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'list1_lexpr_sep_comma) in
    Obj.repr(
# 336 "why_parser.mly"
                        ( _1 )
# 1453 "why_parser.ml"
               : Why_ptree.lexpr list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 341 "why_parser.mly"
                              ( [_1] )
# 1460 "why_parser.ml"
               : 'list1_lexpr_sep_pv))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : Why_ptree.lexpr) in
    Obj.repr(
# 342 "why_parser.mly"
                              ( [_1] )
# 1467 "why_parser.ml"
               : 'list1_lexpr_sep_pv))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'list1_lexpr_sep_pv) in
    Obj.repr(
# 343 "why_parser.mly"
                              ( _1 :: _3 )
# 1475 "why_parser.ml"
               : 'list1_lexpr_sep_pv))
; (fun __caml_parser_env ->
    Obj.repr(
# 347 "why_parser.mly"
                                    ( [] )
# 1481 "why_parser.ml"
               : 'list0_lexpr_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 348 "why_parser.mly"
                                    ( [_1] )
# 1488 "why_parser.ml"
               : 'list0_lexpr_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'list1_lexpr_sep_comma) in
    Obj.repr(
# 349 "why_parser.mly"
                                    ( _1 :: _3 )
# 1496 "why_parser.ml"
               : 'list0_lexpr_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 353 "why_parser.mly"
                                    ( [_1] )
# 1503 "why_parser.ml"
               : 'list1_lexpr_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'list1_lexpr_sep_comma) in
    Obj.repr(
# 354 "why_parser.mly"
                                    ( _1 :: _3 )
# 1511 "why_parser.ml"
               : 'list1_lexpr_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : Why_ptree.lexpr) in
    Obj.repr(
# 358 "why_parser.mly"
                                    ( [_1; _3] )
# 1519 "why_parser.ml"
               : 'list2_lexpr_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : Why_ptree.lexpr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'list2_lexpr_sep_comma) in
    Obj.repr(
# 359 "why_parser.mly"
                                    ( _1 :: _3 )
# 1527 "why_parser.ml"
               : 'list2_lexpr_sep_comma))
; (fun __caml_parser_env ->
    Obj.repr(
# 363 "why_parser.mly"
     ( PPlt )
# 1533 "why_parser.ml"
               : 'relation))
; (fun __caml_parser_env ->
    Obj.repr(
# 364 "why_parser.mly"
     ( PPle )
# 1539 "why_parser.ml"
               : 'relation))
; (fun __caml_parser_env ->
    Obj.repr(
# 365 "why_parser.mly"
     ( PPgt )
# 1545 "why_parser.ml"
               : 'relation))
; (fun __caml_parser_env ->
    Obj.repr(
# 366 "why_parser.mly"
     ( PPge )
# 1551 "why_parser.ml"
               : 'relation))
; (fun __caml_parser_env ->
    Obj.repr(
# 367 "why_parser.mly"
        ( PPeq )
# 1557 "why_parser.ml"
               : 'relation))
; (fun __caml_parser_env ->
    Obj.repr(
# 368 "why_parser.mly"
        ( PPneq )
# 1563 "why_parser.ml"
               : 'relation))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 372 "why_parser.mly"
              ( _2 )
# 1570 "why_parser.ml"
               : 'type_var))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_var) in
    Obj.repr(
# 376 "why_parser.mly"
                                          ( [_1] )
# 1577 "why_parser.ml"
               : 'list1_type_var_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'type_var) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'list1_type_var_sep_comma) in
    Obj.repr(
# 377 "why_parser.mly"
                                          ( _1 :: _3 )
# 1585 "why_parser.ml"
               : 'list1_type_var_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 381 "why_parser.mly"
        ( _1 )
# 1592 "why_parser.ml"
               : 'ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 385 "why_parser.mly"
                                    ( [_1] )
# 1599 "why_parser.ml"
               : 'list1_ident_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'list1_ident_sep_comma) in
    Obj.repr(
# 386 "why_parser.mly"
                                    ( _1 :: _3 )
# 1607 "why_parser.ml"
               : 'list1_ident_sep_comma))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 390 "why_parser.mly"
         ( _1 )
# 1614 "why_parser.ml"
               : 'ident_or_string))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 391 "why_parser.mly"
         ( _1 )
# 1621 "why_parser.ml"
               : 'ident_or_string))
(* Entry trigger *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry lexpr *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry file *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
|]
let yytables =
  { Parsing.actions=yyact;
    Parsing.transl_const=yytransl_const;
    Parsing.transl_block=yytransl_block;
    Parsing.lhs=yylhs;
    Parsing.len=yylen;
    Parsing.defred=yydefred;
    Parsing.dgoto=yydgoto;
    Parsing.sindex=yysindex;
    Parsing.rindex=yyrindex;
    Parsing.gindex=yygindex;
    Parsing.tablesize=yytablesize;
    Parsing.table=yytable;
    Parsing.check=yycheck;
    Parsing.error_function=parse_error;
    Parsing.names_const=yynames_const;
    Parsing.names_block=yynames_block }
let trigger (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 1 lexfun lexbuf : Why_ptree.lexpr list)
let lexpr (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 2 lexfun lexbuf : Why_ptree.lexpr)
let file (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 3 lexfun lexbuf : Why_ptree.file)
end
include (IMPLEMENTATION : INTERFACE)
end
and Why_lexer: sig
#0 "why_lexer.mli"
val keywords : (string, Why_parser.token) Hashtbl.t
val newline : Lexing.lexbuf -> unit
val string_buf : Buffer.t
exception Lexical_error of string
val char_for_backslash : char -> char
val num0 : Num.num
val num10 : Num.num
val num16 : Num.num
val decnumber : string -> Num.num
val hexnumber : string -> Num.num
val __ocaml_lex_tables : Lexing.lex_tables
val token : Lexing.lexbuf -> Why_parser.token
val __ocaml_lex_token_rec : Lexing.lexbuf -> int -> Why_parser.token
val comment : Lexing.lexbuf -> unit
val __ocaml_lex_comment_rec : Lexing.lexbuf -> int -> unit
val string : Lexing.lexbuf -> Why_parser.token
val __ocaml_lex_string_rec : Lexing.lexbuf -> int -> Why_parser.token
end = struct
let _ = Printf.fprintf stderr "Executing why_lexer.ml\n%!"module type INTERFACE = sig
#0 "why_lexer.mli"
val keywords : (string, Why_parser.token) Hashtbl.t
val newline : Lexing.lexbuf -> unit
val string_buf : Buffer.t
exception Lexical_error of string
val char_for_backslash : char -> char
val num0 : Num.num
val num10 : Num.num
val num16 : Num.num
val decnumber : string -> Num.num
val hexnumber : string -> Num.num
val __ocaml_lex_tables : Lexing.lex_tables
val token : Lexing.lexbuf -> Why_parser.token
val __ocaml_lex_token_rec : Lexing.lexbuf -> int -> Why_parser.token
val comment : Lexing.lexbuf -> unit
val __ocaml_lex_comment_rec : Lexing.lexbuf -> int -> unit
val string : Lexing.lexbuf -> Why_parser.token
val __ocaml_lex_string_rec : Lexing.lexbuf -> int -> Why_parser.token
end
module IMPLEMENTATION = struct
#0 "why_lexer.ml"
# 36 "why_lexer.mll"
 
  open Lexing
  open Why_parser

  let keywords = Hashtbl.create 97
  let () = 
    List.iter 
      (fun (x,y) -> Hashtbl.add keywords x y)
      [ "ac", AC;
	"and", AND;
	"axiom", AXIOM;
	"bitv", BITV;
        "bool", BOOL;
        "distinct", DISTINCT;
        "else", ELSE;
	"exists", EXISTS;
        "false", FALSE;
	"forall", FORALL;
	"function", FUNCTION;
	"goal", GOAL;
	"if", IF;
	"in", IN; 
	"int", INT;
	"let", LET;
	"logic", LOGIC;
	"not", NOT;
	"or", OR;
	"predicate", PREDICATE;
	"prop", PROP;
	"real", REAL;
	"rewriting", REWRITING;
	"then", THEN;
	"true", TRUE;
	"type", TYPE;
	"unit", UNIT;
	"void", VOID]
	       
  let newline lexbuf =
    let pos = lexbuf.lex_curr_p in
    lexbuf.lex_curr_p <- 
      { pos with pos_lnum = pos.pos_lnum + 1; pos_bol = pos.pos_cnum }

  let string_buf = Buffer.create 1024

  exception Lexical_error of string

  let char_for_backslash = function
    | 'n' -> '\n'
    | 't' -> '\t'
    | c -> c

  let num0 = Num.Int 0
  let num10 = Num.Int 10
  let num16 = Num.Int 16

  let decnumber s =
    let r = ref num0 in
    for i=0 to String.length s - 1 do
      r := Num.add_num (Num.mult_num num10 !r) 
	(Num.num_of_int (Char.code s.[i] - Char.code '0'))
    done;
    !r

  let hexnumber s =
    let r = ref num0 in
    for i=0 to String.length s - 1 do
      let c = s.[i] in
      let v = 
	match c with
	  | '0'..'9' -> Char.code c - Char.code '0'
	  | 'a'..'f' -> Char.code c - Char.code 'a' + 10
	  | 'A'..'F' -> Char.code c - Char.code 'A' + 10
	  | _ -> assert false
      in
      r := Num.add_num (Num.mult_num num16 !r) (Num.num_of_int v)
    done;
    !r


# 82 "why_lexer.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\218\255\219\255\220\255\221\255\222\255\223\255\224\255\
    \225\255\226\255\228\255\229\255\230\255\231\255\233\255\031\000\
    \239\255\081\000\034\000\243\255\244\255\246\255\247\255\248\255\
    \085\000\080\000\098\000\120\000\194\000\003\000\255\255\013\001\
    \131\000\153\000\108\000\163\000\041\001\051\001\073\001\174\000\
    \083\001\093\001\105\001\117\001\150\001\182\001\215\001\247\001\
    \001\002\011\002\021\002\031\002\053\002\063\002\073\002\249\255\
    \242\255\234\255\237\255\076\000\240\255\235\255\245\000\251\255\
    \252\255\253\255\097\000\099\000\255\255\254\255\154\001\251\255\
    \252\255\253\255\002\000\255\255\254\255";
  Lexing.lex_backtrk = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\019\000\
    \255\255\017\000\023\000\255\255\255\255\255\255\255\255\255\255\
    \010\000\028\000\003\000\003\000\002\000\001\000\255\255\255\255\
    \004\000\255\255\004\000\255\255\255\255\004\000\255\255\004\000\
    \255\255\004\000\255\255\255\255\255\255\255\255\255\255\005\000\
    \255\255\005\000\255\255\004\000\255\255\004\000\255\255\255\255\
    \255\255\255\255\255\255\014\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\004\000\004\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\004\000\255\255\255\255";
  Lexing.lex_default = 
   "\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\255\255\
    \000\000\255\255\255\255\000\000\000\000\000\000\000\000\000\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
    \000\000\000\000\000\000\255\255\000\000\000\000\063\000\000\000\
    \000\000\000\000\255\255\255\255\000\000\000\000\071\000\000\000\
    \000\000\000\000\076\000\000\000\000\000";
  Lexing.lex_trans = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\029\000\030\000\000\000\029\000\029\000\000\000\000\000\
    \029\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \029\000\000\000\003\000\029\000\000\000\011\000\000\000\023\000\
    \024\000\020\000\013\000\014\000\022\000\018\000\025\000\012\000\
    \027\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\019\000\021\000\017\000\016\000\015\000\028\000\
    \010\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\009\000\061\000\008\000\004\000\028\000\
    \056\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\007\000\005\000\006\000\059\000\055\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\060\000\069\000\068\000\000\000\058\000\057\000\
    \032\000\000\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\032\000\033\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\000\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\033\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\035\000\000\000\035\000\033\000\
    \036\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\033\000\039\000\039\000\
    \039\000\039\000\039\000\039\000\039\000\039\000\039\000\039\000\
    \036\000\028\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \031\000\000\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\000\000\000\000\000\000\065\000\
    \002\000\028\000\255\255\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\066\000\000\000\067\000\
    \000\000\028\000\000\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\043\000\043\000\043\000\
    \043\000\043\000\043\000\043\000\043\000\043\000\043\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\043\000\043\000\
    \043\000\043\000\043\000\043\000\042\000\000\000\042\000\000\000\
    \000\000\041\000\041\000\041\000\041\000\041\000\041\000\041\000\
    \041\000\041\000\041\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\000\000\043\000\043\000\
    \043\000\043\000\043\000\043\000\040\000\000\000\040\000\000\000\
    \038\000\039\000\039\000\039\000\039\000\039\000\039\000\039\000\
    \039\000\039\000\039\000\039\000\039\000\039\000\039\000\039\000\
    \039\000\039\000\039\000\039\000\039\000\041\000\041\000\041\000\
    \041\000\041\000\041\000\041\000\041\000\041\000\041\000\000\000\
    \038\000\041\000\041\000\041\000\041\000\041\000\041\000\041\000\
    \041\000\041\000\041\000\045\000\073\000\043\000\043\000\043\000\
    \043\000\043\000\043\000\043\000\043\000\043\000\043\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\043\000\043\000\
    \043\000\043\000\043\000\043\000\075\000\000\000\000\000\000\000\
    \000\000\050\000\000\000\050\000\000\000\044\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\043\000\043\000\
    \043\000\043\000\043\000\043\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\044\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \000\000\000\000\000\000\000\000\000\000\064\000\074\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\000\000\000\000\000\000\
    \000\000\000\000\048\000\000\000\048\000\000\000\046\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\000\000\000\000\000\000\000\000\000\000\000\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\046\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \054\000\000\000\054\000\000\000\052\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\000\000\052\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\072\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000";
  Lexing.lex_check = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\255\255\029\000\000\000\255\255\255\255\
    \029\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\000\000\029\000\255\255\000\000\255\255\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\
    \018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\017\000\024\000\
    \025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\
    \025\000\025\000\059\000\066\000\067\000\255\255\017\000\017\000\
    \026\000\255\255\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\027\000\026\000\
    \027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\
    \027\000\027\000\255\255\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\027\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\033\000\255\255\033\000\026\000\
    \032\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\027\000\039\000\039\000\
    \039\000\039\000\039\000\039\000\039\000\039\000\039\000\039\000\
    \032\000\028\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \027\000\255\255\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\255\255\255\255\255\255\062\000\
    \000\000\028\000\074\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\062\000\255\255\062\000\
    \255\255\028\000\255\255\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\031\000\031\000\
    \031\000\031\000\031\000\031\000\036\000\255\255\036\000\255\255\
    \255\255\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\255\255\031\000\031\000\
    \031\000\031\000\031\000\031\000\038\000\255\255\038\000\255\255\
    \037\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\040\000\040\000\040\000\040\000\040\000\
    \040\000\040\000\040\000\040\000\040\000\041\000\041\000\041\000\
    \041\000\041\000\041\000\041\000\041\000\041\000\041\000\255\255\
    \037\000\042\000\042\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\042\000\042\000\043\000\070\000\043\000\043\000\043\000\
    \043\000\043\000\043\000\043\000\043\000\043\000\043\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\043\000\043\000\
    \043\000\043\000\043\000\043\000\070\000\255\255\255\255\255\255\
    \255\255\044\000\255\255\044\000\255\255\043\000\044\000\044\000\
    \044\000\044\000\044\000\044\000\044\000\044\000\044\000\044\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\043\000\043\000\
    \043\000\043\000\043\000\043\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\043\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \255\255\255\255\255\255\255\255\255\255\062\000\070\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\255\255\255\255\255\255\
    \255\255\255\255\046\000\255\255\046\000\255\255\045\000\046\000\
    \046\000\046\000\046\000\046\000\046\000\046\000\046\000\046\000\
    \046\000\255\255\255\255\255\255\255\255\255\255\255\255\045\000\
    \045\000\045\000\045\000\045\000\045\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\045\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \052\000\255\255\052\000\255\255\051\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \054\000\054\000\054\000\255\255\051\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\070\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255";
  Lexing.lex_base_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\010\000\022\000\044\000\000\000\000\000\000\000\081\000\
    \055\000\109\000\032\000\119\000\141\000\151\000\173\000\183\000\
    \193\000\205\000\215\000\227\000\000\000\009\001\071\000\000\000\
    \000\000\000\000\000\000\043\001\074\001\084\001\097\001\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_backtrk_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \048\000\000\000\069\000\000\000\000\000\048\000\000\000\069\000\
    \000\000\069\000\000\000\000\000\000\000\000\000\000\000\102\000\
    \000\000\113\000\000\000\048\000\000\000\069\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_default_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_trans_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\096\000\000\000\096\000\001\000\000\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\014\000\000\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\033\000\026\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\000\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\038\000\096\000\000\000\096\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\026\000\038\000\000\000\000\000\000\000\
    \000\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\038\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \061\000\000\000\061\000\000\000\038\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\000\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \061\000\000\000\061\000\000\000\000\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \061\000\000\000\061\000\000\000\038\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\000\000\038\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\086\000\000\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\091\000\000\000\000\000\000\000\000\000\
    \000\000\099\000\099\000\099\000\099\000\099\000\099\000\099\000\
    \099\000\099\000\099\000\000\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\099\000\099\000\099\000\099\000\099\000\099\000\
    \000\000\000\000\000\000\091\000\000\000\000\000\000\000\000\000\
    \000\000\091\000\000\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\000\000\000\000\000\000\
    \000\000\000\000\099\000\099\000\099\000\099\000\099\000\099\000\
    \038\000\000\000\000\000\000\000\000\000\061\000\000\000\061\000\
    \000\000\091\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\000\000\000\000\
    \038\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000";
  Lexing.lex_check_code = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\044\000\255\255\044\000\000\000\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\025\000\025\000\025\000\025\000\025\000\025\000\
    \025\000\025\000\025\000\025\000\026\000\255\255\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\027\000\026\000\027\000\027\000\027\000\027\000\
    \027\000\027\000\027\000\027\000\027\000\027\000\255\255\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\027\000\046\000\255\255\046\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\026\000\032\000\255\255\255\255\255\255\
    \255\255\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\027\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \033\000\255\255\033\000\255\255\032\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\255\255\031\000\031\000\031\000\031\000\031\000\031\000\
    \036\000\255\255\036\000\255\255\255\255\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \038\000\255\255\038\000\255\255\037\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\039\000\
    \039\000\039\000\039\000\039\000\039\000\039\000\039\000\039\000\
    \039\000\040\000\040\000\040\000\040\000\040\000\040\000\040\000\
    \040\000\040\000\040\000\255\255\037\000\041\000\041\000\041\000\
    \041\000\041\000\041\000\041\000\041\000\041\000\041\000\042\000\
    \042\000\042\000\042\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\043\000\255\255\043\000\043\000\043\000\043\000\043\000\
    \043\000\043\000\043\000\043\000\043\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\043\000\043\000\043\000\043\000\
    \043\000\043\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\043\000\255\255\255\255\255\255\255\255\
    \255\255\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\255\255\043\000\043\000\043\000\043\000\
    \043\000\043\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \255\255\255\255\255\255\043\000\255\255\255\255\255\255\255\255\
    \255\255\045\000\255\255\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\255\255\255\255\255\255\
    \255\255\255\255\045\000\045\000\045\000\045\000\045\000\045\000\
    \051\000\255\255\255\255\255\255\255\255\052\000\255\255\052\000\
    \255\255\045\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\255\255\255\255\
    \051\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \054\000\054\000\054\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255";
  Lexing.lex_code = 
   "\255\010\255\255\011\255\010\255\009\255\255\011\255\255\010\255\
    \011\255\255\009\255\010\255\011\255\255\012\255\014\255\013\255\
    \255\011\255\010\255\255\014\255\013\255\012\255\255\016\255\255\
    \007\255\001\255\005\008\004\009\003\010\002\011\255\014\255\013\
    \255\255\015\255\255\007\012\006\014\005\008\004\009\003\010\002\
    \011\001\013\000\015\255\020\255\019\255\255\018\255\017\255\255\
    \018\255\255\020\255\255\001\017\002\018\004\019\003\020\000\016\
    \255\004\255\001\017\002\018\000\016\255";
}

let rec token lexbuf =
lexbuf.Lexing.lex_mem <- Array.create 21 (-1) ; (* L=2 [9] <- p ; [8] <- p ;  *)
  lexbuf.Lexing.lex_mem.(9) <- lexbuf.Lexing.lex_curr_pos ;
  lexbuf.Lexing.lex_mem.(8) <- lexbuf.Lexing.lex_curr_pos ;
  __ocaml_lex_token_rec lexbuf 0
and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
  match Lexing.new_engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 126 "why_lexer.mll"
      ( newline lexbuf; token lexbuf )
# 541 "why_lexer.ml"

  | 1 ->
# 128 "why_lexer.mll"
      ( token lexbuf )
# 546 "why_lexer.ml"

  | 2 ->
let
# 129 "why_lexer.mll"
             id
# 552 "why_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 130 "why_lexer.mll"
      ( try Hashtbl.find keywords id with Not_found -> IDENT id )
# 556 "why_lexer.ml"

  | 3 ->
let
# 131 "why_lexer.mll"
              s
# 562 "why_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 132 "why_lexer.mll"
      ( INTEGER s )
# 566 "why_lexer.ml"

  | 4 ->
let
# 133 "why_lexer.mll"
               i
# 572 "why_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_mem.(5) lexbuf.Lexing.lex_mem.(4)
and
# 133 "why_lexer.mll"
                         f
# 577 "why_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_mem.(3) lexbuf.Lexing.lex_mem.(2)
and
# 133 "why_lexer.mll"
                                                     sign
# 582 "why_lexer.ml"
= Lexing.sub_lexeme_opt lexbuf lexbuf.Lexing.lex_mem.(7) lexbuf.Lexing.lex_mem.(6)
and
# 133 "why_lexer.mll"
                                                                     exp
# 587 "why_lexer.ml"
= Lexing.sub_lexeme_opt lexbuf lexbuf.Lexing.lex_mem.(1) lexbuf.Lexing.lex_mem.(0) in
# 139 "why_lexer.mll"
      ( (*
          Format.eprintf "decimal real literal found: i=%s f=%s sign=%a exp=%a" 
          i f so sign so exp;
	*)
        let v =
	  match exp,sign with
	    | Some exp,Some "-" ->
		Num.div_num (decnumber (i^f)) 
		  (Num.power_num (Num.Int 10) (decnumber exp))
	    | Some exp,_ -> 
		Num.mult_num (decnumber (i^f)) 
		  (Num.power_num (Num.Int 10) (decnumber exp))
	    | None,_ -> decnumber (i^f) 
	in
	let v = 
	  Num.div_num v 
	    (Num.power_num (Num.Int 10) (Num.num_of_int (String.length f))) 
	in
	(* Format.eprintf " -> value = %s@." (Num.string_of_num v); *)
	NUM v
      )
# 611 "why_lexer.ml"

  | 5 ->
let
# 162 "why_lexer.mll"
                       e
# 617 "why_lexer.ml"
= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 2) lexbuf.Lexing.lex_mem.(0)
and
# 162 "why_lexer.mll"
                                             f
# 622 "why_lexer.ml"
= Lexing.sub_lexeme_opt lexbuf lexbuf.Lexing.lex_mem.(4) lexbuf.Lexing.lex_mem.(3)
and
# 163 "why_lexer.mll"
                             sign
# 627 "why_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_mem.(1) lexbuf.Lexing.lex_mem.(2)
and
# 163 "why_lexer.mll"
                                              exp
# 632 "why_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_mem.(2) lexbuf.Lexing.lex_curr_pos in
# 164 "why_lexer.mll"
      ( (* Format.eprintf "hex num found: %s" (lexeme lexbuf); *)
	let f = match f with None -> "" | Some f -> f in
	let v =
	  match sign with
	    | "-" ->
		Num.div_num (hexnumber (e^f)) 
		  (Num.power_num (Num.Int 2) (decnumber exp))
	    | _ -> 
		Num.mult_num (hexnumber (e^f)) 
		  (Num.power_num (Num.Int 2) (decnumber exp))
	in
	let v = 
	  Num.div_num v 
	    (Num.power_num (Num.Int 16) (Num.num_of_int (String.length f))) 
	in
	(* Format.eprintf " -> value = %s@." (Num.string_of_num v); *)
	NUM v
      )
# 653 "why_lexer.ml"

  | 6 ->
# 183 "why_lexer.mll"
      ( comment lexbuf; token lexbuf )
# 658 "why_lexer.ml"

  | 7 ->
# 185 "why_lexer.mll"
      ( QUOTE )
# 663 "why_lexer.ml"

  | 8 ->
# 187 "why_lexer.mll"
      ( COMMA )
# 668 "why_lexer.ml"

  | 9 ->
# 189 "why_lexer.mll"
      ( PV )
# 673 "why_lexer.ml"

  | 10 ->
# 191 "why_lexer.mll"
      ( LEFTPAR )
# 678 "why_lexer.ml"

  | 11 ->
# 193 "why_lexer.mll"
      ( RIGHTPAR )
# 683 "why_lexer.ml"

  | 12 ->
# 195 "why_lexer.mll"
      ( COLON )
# 688 "why_lexer.ml"

  | 13 ->
# 197 "why_lexer.mll"
      ( ARROW )
# 693 "why_lexer.ml"

  | 14 ->
# 199 "why_lexer.mll"
      ( LEFTARROW )
# 698 "why_lexer.ml"

  | 15 ->
# 201 "why_lexer.mll"
      ( LRARROW )
# 703 "why_lexer.ml"

  | 16 ->
# 203 "why_lexer.mll"
      ( EQUAL )
# 708 "why_lexer.ml"

  | 17 ->
# 205 "why_lexer.mll"
      ( LT )
# 713 "why_lexer.ml"

  | 18 ->
# 207 "why_lexer.mll"
      ( LE )
# 718 "why_lexer.ml"

  | 19 ->
# 209 "why_lexer.mll"
      ( GT )
# 723 "why_lexer.ml"

  | 20 ->
# 211 "why_lexer.mll"
      ( GE )
# 728 "why_lexer.ml"

  | 21 ->
# 213 "why_lexer.mll"
      ( NOTEQ )
# 733 "why_lexer.ml"

  | 22 ->
# 215 "why_lexer.mll"
      ( PLUS )
# 738 "why_lexer.ml"

  | 23 ->
# 217 "why_lexer.mll"
      ( MINUS )
# 743 "why_lexer.ml"

  | 24 ->
# 219 "why_lexer.mll"
      ( TIMES )
# 748 "why_lexer.ml"

  | 25 ->
# 221 "why_lexer.mll"
      ( SLASH )
# 753 "why_lexer.ml"

  | 26 ->
# 223 "why_lexer.mll"
      ( PERCENT )
# 758 "why_lexer.ml"

  | 27 ->
# 225 "why_lexer.mll"
      ( AT )
# 763 "why_lexer.ml"

  | 28 ->
# 227 "why_lexer.mll"
      ( DOT )
# 768 "why_lexer.ml"

  | 29 ->
# 229 "why_lexer.mll"
      ( LEFTSQ )
# 773 "why_lexer.ml"

  | 30 ->
# 231 "why_lexer.mll"
      ( RIGHTSQ )
# 778 "why_lexer.ml"

  | 31 ->
# 233 "why_lexer.mll"
      ( LEFTBR )
# 783 "why_lexer.ml"

  | 32 ->
# 235 "why_lexer.mll"
      ( RIGHTBR )
# 788 "why_lexer.ml"

  | 33 ->
# 237 "why_lexer.mll"
      ( BAR )
# 793 "why_lexer.ml"

  | 34 ->
# 239 "why_lexer.mll"
      ( HAT )
# 798 "why_lexer.ml"

  | 35 ->
# 241 "why_lexer.mll"
      ( Buffer.clear string_buf; string lexbuf )
# 803 "why_lexer.ml"

  | 36 ->
# 243 "why_lexer.mll"
      ( EOF )
# 808 "why_lexer.ml"

  | 37 ->
let
# 244 "why_lexer.mll"
         c
# 814 "why_lexer.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 245 "why_lexer.mll"
      ( raise (Lexical_error ("illegal character: " ^ String.make 1 c)) )
# 818 "why_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_token_rec lexbuf __ocaml_lex_state

and comment lexbuf =
  __ocaml_lex_comment_rec lexbuf 62
and __ocaml_lex_comment_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 249 "why_lexer.mll"
      ( () )
# 829 "why_lexer.ml"

  | 1 ->
# 251 "why_lexer.mll"
      ( comment lexbuf; comment lexbuf )
# 834 "why_lexer.ml"

  | 2 ->
# 253 "why_lexer.mll"
      ( newline lexbuf; comment lexbuf )
# 839 "why_lexer.ml"

  | 3 ->
# 255 "why_lexer.mll"
      ( raise (Lexical_error "unterminated comment") )
# 844 "why_lexer.ml"

  | 4 ->
# 257 "why_lexer.mll"
      ( comment lexbuf )
# 849 "why_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_comment_rec lexbuf __ocaml_lex_state

and string lexbuf =
  __ocaml_lex_string_rec lexbuf 70
and __ocaml_lex_string_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 261 "why_lexer.mll"
      ( STRING (Buffer.contents string_buf) )
# 860 "why_lexer.ml"

  | 1 ->
let
# 262 "why_lexer.mll"
               c
# 866 "why_lexer.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 1) in
# 263 "why_lexer.mll"
      ( Buffer.add_char string_buf (char_for_backslash c); string lexbuf )
# 870 "why_lexer.ml"

  | 2 ->
# 265 "why_lexer.mll"
      ( newline lexbuf; Buffer.add_char string_buf '\n'; string lexbuf )
# 875 "why_lexer.ml"

  | 3 ->
# 267 "why_lexer.mll"
      ( raise (Lexical_error "unterminated string") )
# 880 "why_lexer.ml"

  | 4 ->
let
# 268 "why_lexer.mll"
         c
# 886 "why_lexer.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 269 "why_lexer.mll"
      ( Buffer.add_char string_buf c; string lexbuf )
# 890 "why_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_string_rec lexbuf __ocaml_lex_state

;;

end
include (IMPLEMENTATION : INTERFACE)
end
and Pretty: sig
#0 "pretty.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

val print_term : Format.formatter -> ('a tterm, 'a) annoted -> unit
val print_term_list : Format.formatter -> ('a tterm, 'a) annoted list -> unit

val print_form : Format.formatter -> ('a tform, 'a) annoted -> unit
end = struct
let _ = Printf.fprintf stderr "Executing pretty.ml\n%!"module type INTERFACE = sig
#0 "pretty.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

val print_term : Format.formatter -> ('a tterm, 'a) annoted -> unit
val print_term_list : Format.formatter -> ('a tterm, 'a) annoted list -> unit

val print_form : Format.formatter -> ('a tform, 'a) annoted -> unit
end
module IMPLEMENTATION = struct
#0 "pretty.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Format
open Why_ptree

(* not quite ''pretty''-printing, but helps for quick debugging *)

let rec print_term fmt t = 
  print_term_desc fmt t.c.tt_desc
and print_term_desc fmt =  function
  | TTconst Ttrue -> fprintf fmt "true"
  | TTconst Tfalse -> fprintf fmt "false"
  | TTconst Tint s -> fprintf fmt "%s" s
  | TTconst Treal s -> fprintf fmt "%s" (Num.string_of_num s)
  | TTvar x -> Symbols.print fmt x
  | TTinfix(t1,op,t2) -> 
      fprintf fmt "%a%a%a" print_term t1 Symbols.print op print_term t2
  | TTapp(f,l) -> 
      fprintf fmt "%a(%a)" Symbols.print f print_term_list l
  | _ -> failwith "not implemented"
and print_term_list fmt = List.iter (fprintf fmt "%a," print_term)

let rec print_atom fmt a = match a.c with
  | TAtrue -> fprintf fmt "@true"
  | TAfalse -> fprintf fmt "@false"
  | TAeq tl -> fprintf fmt "=(%a)" print_term_list tl
  | TAneq tl -> fprintf fmt "<>(%a)" print_term_list tl
  | TAdistinct tl -> fprintf fmt "distinct(%a)" print_term_list tl
  | TAle tl -> fprintf fmt "<=(%a)" print_term_list tl
  | TAlt tl -> fprintf fmt "<(%a)" print_term_list tl
  | TApred t -> fprintf fmt "%a" print_term t 
  | TAbuilt(s, tl) -> fprintf fmt "%s(%a)" (Hstring.view s) print_term_list tl

let print_op fmt = function
  | OPand -> fprintf fmt "/\\"
  | OPor -> fprintf fmt "\\/"
  | OPimp -> fprintf fmt "=>"
  | OPnot -> fprintf fmt "~"
  | OPif t -> fprintf fmt "if (%a) " print_term t
  | OPiff -> fprintf fmt "<=>"

let rec print_form fmt f = match f.c with
  | TFatom a -> fprintf fmt "%a" print_atom a
  | TFop (op,tl) -> fprintf fmt "%a(%a)" print_op op print_form_list tl
  | TFforall qf -> fprintf fmt "forall ..., %a" print_form qf.qf_form
  | TFexists qf -> fprintf fmt "exists ..., %a" print_form qf.qf_form
  | TFlet (up,var,t,f) -> fprintf fmt "let ..., %a" print_form f
  | TFnamed(lbl, f) -> fprintf fmt "%s:%a" (Hstring.view lbl) print_form f
and print_form_list fmt = List.iter (fprintf fmt "%a," print_form)
end
include (IMPLEMENTATION : INTERFACE)
end
and Smt_ast : sig
#0 "smt_ast.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type loc = Lexing.position * Lexing.position

type annot = string * string option
type binder = { var: string ; sort: string }

type term = { term: term_node; tloc: loc}
and term_node = 
  | Num of string
  | Rat of string
  | Var of string
  | Fun of string * term list 
  | Ite of formula * term * term
and formula = { formula : form_node; floc : loc }
and form_node =
    Flet of string * formula * formula 
  | Let of string * term * formula 
  | Forall of binder list * formula
  | Exists of binder list * formula
  | And of formula list 
  | Or of formula list 
  | Not of formula
  | Implies of formula * formula
  | Xor of formula list 
  | Iff of formula list 
  | Fite of formula * formula * formula 
  | True
  | False
  | Fvar of string
  | Distinct of term list 
  | Equals of term list
  | Pred of string * term list 

type pred_sig = { 
  pname: string;  
  pargs: (loc * string) list; }

type fun_sig = {
  fname: string;
  fargs: (loc * string) list;
  fres: loc * string }

type ptheory_attrib =
    Tsorts of (loc *string) list
  | Funs of (loc * fun_sig) list 
  | Preds of (loc * pred_sig) list
  | Definition of string 
  | Axioms of formula list
  | Tcomment

type ptheory = string * ptheory_attrib list

type plogic_attrib = Ltheory of string | Lcomment

type plogic = string * plogic_attrib list

type status = Sat | Unsat | Unknown

type pbench_attrib = 
    Pblogic of string
  | Pbstatus of status
  | Pbextr_sorts of (loc * string) list
  | Pbextr_funs of (loc * fun_sig) list
  | Pbextr_preds of (loc *pred_sig) list
  | Pbformula of loc * formula 
  | Pbassumption of loc * formula 
  | Pbrewriting of loc * formula list
  | Pannotation

type pbench = string * pbench_attrib list * status
	  






end = struct
#0 "smt_ast.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type loc = Lexing.position * Lexing.position

type annot = string * string option
type binder = { var: string ; sort: string }

type term = { term: term_node; tloc: loc}
and term_node = 
  | Num of string
  | Rat of string
  | Var of string
  | Fun of string * term list 
  | Ite of formula * term * term
and formula = { formula : form_node; floc : loc }
and form_node =
    Flet of string * formula * formula 
  | Let of string * term * formula 
  | Forall of binder list * formula
  | Exists of binder list * formula
  | And of formula list 
  | Or of formula list 
  | Not of formula
  | Implies of formula * formula
  | Xor of formula list 
  | Iff of formula list 
  | Fite of formula * formula * formula 
  | True
  | False
  | Fvar of string
  | Distinct of term list 
  | Equals of term list
  | Pred of string * term list 

type pred_sig = { 
  pname: string;  
  pargs: (loc * string) list; }

type fun_sig = {
  fname: string;
  fargs: (loc * string) list;
  fres: loc * string }

type ptheory_attrib =
    Tsorts of (loc *string) list
  | Funs of (loc * fun_sig) list 
  | Preds of (loc * pred_sig) list
  | Definition of string 
  | Axioms of formula list
  | Tcomment

type ptheory = string * ptheory_attrib list

type plogic_attrib = Ltheory of string | Lcomment

type plogic = string * plogic_attrib list

type status = Sat | Unsat | Unknown

type pbench_attrib = 
    Pblogic of string
  | Pbstatus of status
  | Pbextr_sorts of (loc * string) list
  | Pbextr_funs of (loc * fun_sig) list
  | Pbextr_preds of (loc *pred_sig) list
  | Pbformula of loc * formula 
  | Pbassumption of loc * formula 
  | Pbrewriting of loc * formula list
  | Pannotation

type pbench = string * pbench_attrib list * status
	  






end
and Smt_parser: sig
#0 "smt_parser.mli"
type token =
  | BENCHMARK
  | LOGIC
  | THEORY
  | ASSUMPTION_ATRB
  | AXIOMS_ATRB
  | DEFINITION_ATRB
  | EXTENSIONS_ATRB
  | FORMULA_ATRB
  | FUNS_ATRB
  | EXTRAFUNS_ATRB
  | EXTRASORTS_ATRB
  | EXTRAPREDS_ATRB
  | LANGUAGE_ATRB
  | LOGIC_ATRB
  | NOTES_ATRB
  | PREDS_ATRB
  | REWRITING_ATRB
  | SORTS_ATRB
  | STATUS_ATRB
  | THEORY_ATRB
  | ATTRIBUTE of (string)
  | SAT
  | UNSAT
  | UNKNOWN
  | NUMERAL of (string)
  | RATIONAL of (string)
  | ID of (string)
  | ARSYMB of (string)
  | USER_VALUE of (string)
  | VAR of (string)
  | FVAR of (string)
  | STRING of (string)
  | EQUALS
  | DISTINCT
  | ITE
  | NOT
  | IMPLIES
  | IFTHENELSE
  | AND
  | OR
  | XOR
  | IFF
  | TRUE
  | FALSE
  | EXISTS
  | FORALL
  | LET
  | FLET
  | LP
  | RP
  | EOF

val benchmark :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Smt_ast.pbench
val logic :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Smt_ast.plogic
val theory :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Smt_ast.ptheory
end = struct
let _ = Printf.fprintf stderr "Executing smt_parser.ml\n%!"module type INTERFACE = sig
#0 "smt_parser.mli"
type token =
  | BENCHMARK
  | LOGIC
  | THEORY
  | ASSUMPTION_ATRB
  | AXIOMS_ATRB
  | DEFINITION_ATRB
  | EXTENSIONS_ATRB
  | FORMULA_ATRB
  | FUNS_ATRB
  | EXTRAFUNS_ATRB
  | EXTRASORTS_ATRB
  | EXTRAPREDS_ATRB
  | LANGUAGE_ATRB
  | LOGIC_ATRB
  | NOTES_ATRB
  | PREDS_ATRB
  | REWRITING_ATRB
  | SORTS_ATRB
  | STATUS_ATRB
  | THEORY_ATRB
  | ATTRIBUTE of (string)
  | SAT
  | UNSAT
  | UNKNOWN
  | NUMERAL of (string)
  | RATIONAL of (string)
  | ID of (string)
  | ARSYMB of (string)
  | USER_VALUE of (string)
  | VAR of (string)
  | FVAR of (string)
  | STRING of (string)
  | EQUALS
  | DISTINCT
  | ITE
  | NOT
  | IMPLIES
  | IFTHENELSE
  | AND
  | OR
  | XOR
  | IFF
  | TRUE
  | FALSE
  | EXISTS
  | FORALL
  | LET
  | FLET
  | LP
  | RP
  | EOF

val benchmark :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Smt_ast.pbench
val logic :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Smt_ast.plogic
val theory :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Smt_ast.ptheory
end
module IMPLEMENTATION = struct
#0 "smt_parser.ml"
type token =
  | BENCHMARK
  | LOGIC
  | THEORY
  | ASSUMPTION_ATRB
  | AXIOMS_ATRB
  | DEFINITION_ATRB
  | EXTENSIONS_ATRB
  | FORMULA_ATRB
  | FUNS_ATRB
  | EXTRAFUNS_ATRB
  | EXTRASORTS_ATRB
  | EXTRAPREDS_ATRB
  | LANGUAGE_ATRB
  | LOGIC_ATRB
  | NOTES_ATRB
  | PREDS_ATRB
  | REWRITING_ATRB
  | SORTS_ATRB
  | STATUS_ATRB
  | THEORY_ATRB
  | ATTRIBUTE of (string)
  | SAT
  | UNSAT
  | UNKNOWN
  | NUMERAL of (string)
  | RATIONAL of (string)
  | ID of (string)
  | ARSYMB of (string)
  | USER_VALUE of (string)
  | VAR of (string)
  | FVAR of (string)
  | STRING of (string)
  | EQUALS
  | DISTINCT
  | ITE
  | NOT
  | IMPLIES
  | IFTHENELSE
  | AND
  | OR
  | XOR
  | IFF
  | TRUE
  | FALSE
  | EXISTS
  | FORALL
  | LET
  | FLET
  | LP
  | RP
  | EOF

open Parsing;;
# 19 "smt_parser.mly"
  open Smt_ast

  let loc () = symbol_start_pos (), symbol_end_pos ()

  let mk_term t = { term = t; tloc = loc () }

  let mk_form f = { formula = f; floc = loc () }

  let status = ref Unknown

# 67 "smt_parser.ml"
let yytransl_const = [|
  257 (* BENCHMARK *);
  258 (* LOGIC *);
  259 (* THEORY *);
  260 (* ASSUMPTION_ATRB *);
  261 (* AXIOMS_ATRB *);
  262 (* DEFINITION_ATRB *);
  263 (* EXTENSIONS_ATRB *);
  264 (* FORMULA_ATRB *);
  265 (* FUNS_ATRB *);
  266 (* EXTRAFUNS_ATRB *);
  267 (* EXTRASORTS_ATRB *);
  268 (* EXTRAPREDS_ATRB *);
  269 (* LANGUAGE_ATRB *);
  270 (* LOGIC_ATRB *);
  271 (* NOTES_ATRB *);
  272 (* PREDS_ATRB *);
  273 (* REWRITING_ATRB *);
  274 (* SORTS_ATRB *);
  275 (* STATUS_ATRB *);
  276 (* THEORY_ATRB *);
  278 (* SAT *);
  279 (* UNSAT *);
  280 (* UNKNOWN *);
  289 (* EQUALS *);
  290 (* DISTINCT *);
  291 (* ITE *);
  292 (* NOT *);
  293 (* IMPLIES *);
  294 (* IFTHENELSE *);
  295 (* AND *);
  296 (* OR *);
  297 (* XOR *);
  298 (* IFF *);
  299 (* TRUE *);
  300 (* FALSE *);
  301 (* EXISTS *);
  302 (* FORALL *);
  303 (* LET *);
  304 (* FLET *);
  305 (* LP *);
  306 (* RP *);
    0 (* EOF *);
    0|]

let yytransl_block = [|
  277 (* ATTRIBUTE *);
  281 (* NUMERAL *);
  282 (* RATIONAL *);
  283 (* ID *);
  284 (* ARSYMB *);
  285 (* USER_VALUE *);
  286 (* VAR *);
  287 (* FVAR *);
  288 (* STRING *);
    0|]

let yylhs = "\255\255\
\003\000\004\000\004\000\005\000\005\000\005\000\005\000\005\000\
\005\000\005\000\002\000\011\000\011\000\012\000\012\000\012\000\
\012\000\012\000\001\000\013\000\013\000\013\000\014\000\014\000\
\014\000\014\000\014\000\014\000\014\000\014\000\014\000\016\000\
\016\000\016\000\017\000\017\000\007\000\007\000\018\000\018\000\
\008\000\008\000\020\000\021\000\021\000\006\000\006\000\009\000\
\009\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
\015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
\015\000\015\000\015\000\015\000\015\000\015\000\019\000\019\000\
\022\000\022\000\010\000\010\000\024\000\024\000\026\000\023\000\
\023\000\025\000\025\000\025\000\025\000\025\000\025\000\027\000\
\027\000\027\000\027\000\000\000\000\000\000\000"

let yylen = "\002\000\
\005\000\001\000\002\000\004\000\004\000\004\000\002\000\004\000\
\002\000\001\000\005\000\001\000\002\000\002\000\002\000\002\000\
\002\000\001\000\005\000\001\000\003\000\002\000\002\000\002\000\
\002\000\002\000\004\000\004\000\004\000\002\000\001\000\001\000\
\001\000\001\000\001\000\001\000\002\000\001\000\005\000\005\000\
\002\000\001\000\005\000\000\000\001\000\001\000\002\000\001\000\
\002\000\001\000\004\000\001\000\004\000\001\000\004\000\001\000\
\005\000\005\000\005\000\005\000\006\000\007\000\005\000\005\000\
\005\000\005\000\006\000\006\000\009\000\009\000\000\000\001\000\
\001\000\002\000\001\000\002\000\001\000\002\000\004\000\001\000\
\002\000\001\000\004\000\005\000\005\000\005\000\007\000\001\000\
\001\000\001\000\001\000\002\000\002\000\002\000"

let yydefred = "\000\000\
\000\000\000\000\000\000\000\000\000\000\092\000\000\000\093\000\
\000\000\094\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\031\000\000\000\020\000\000\000\000\000\000\000\000\000\
\018\000\000\000\012\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\002\000\010\000\056\000\054\000\050\000\052\000\
\000\000\024\000\025\000\000\000\000\000\000\000\023\000\030\000\
\000\000\032\000\033\000\034\000\026\000\076\000\000\000\019\000\
\022\000\016\000\015\000\017\000\014\000\011\000\013\000\000\000\
\007\000\000\000\009\000\000\000\000\000\001\000\003\000\035\000\
\036\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\038\000\046\000\000\000\000\000\
\000\000\042\000\049\000\021\000\000\000\000\000\000\000\000\000\
\073\000\000\000\090\000\091\000\089\000\088\000\000\000\000\000\
\080\000\082\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\077\000\000\000\
\000\000\000\000\000\000\000\000\000\000\028\000\037\000\047\000\
\027\000\000\000\029\000\041\000\008\000\005\000\006\000\004\000\
\055\000\074\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\081\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\051\000\053\000\000\000\000\000\000\000\078\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\059\000\058\000\060\000\
\000\000\000\000\063\000\064\000\065\000\066\000\000\000\000\000\
\000\000\000\000\000\000\057\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\083\000\061\000\000\000\079\000\068\000\
\067\000\000\000\000\000\040\000\039\000\043\000\084\000\086\000\
\085\000\000\000\062\000\000\000\000\000\000\000\000\000\000\000\
\087\000\069\000\070\000"

let yydgoto = "\004\000\
\006\000\008\000\010\000\042\000\043\000\103\000\100\000\105\000\
\056\000\113\000\034\000\035\000\027\000\028\000\057\000\061\000\
\098\000\101\000\160\000\106\000\184\000\161\000\120\000\134\000\
\121\000\135\000\122\000"

let yysindex = "\157\000\
\216\254\220\254\244\254\000\000\048\255\000\000\051\255\000\000\
\053\255\000\000\046\255\069\255\073\255\013\000\200\255\030\000\
\112\255\112\255\061\255\075\255\083\255\091\255\112\255\152\255\
\093\255\000\000\040\255\000\000\104\255\113\255\120\255\138\255\
\000\000\025\255\000\000\128\255\147\255\151\255\177\255\162\255\
\163\255\148\255\000\000\000\000\000\000\000\000\000\000\000\000\
\224\255\000\000\000\000\165\255\189\255\168\255\000\000\000\000\
\112\255\000\000\000\000\000\000\000\000\000\000\186\255\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\112\255\
\000\000\165\255\000\000\168\255\189\255\000\000\000\000\000\000\
\000\000\198\255\121\255\121\255\112\255\112\255\112\255\112\255\
\112\255\112\255\112\255\198\255\198\255\185\255\185\255\188\255\
\204\255\121\255\074\255\015\255\000\000\000\000\236\254\088\255\
\079\255\000\000\000\000\000\000\174\255\118\255\122\255\239\254\
\000\000\241\254\000\000\000\000\000\000\000\000\027\000\178\255\
\000\000\000\000\178\255\198\255\112\255\112\255\198\255\198\255\
\198\255\198\255\247\254\249\254\195\255\179\255\000\000\179\255\
\201\255\225\255\178\255\227\255\189\255\000\000\000\000\000\000\
\000\000\189\255\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\121\255\121\255\121\255\112\255\198\255\209\255\
\198\255\000\000\226\255\228\255\198\255\112\255\232\255\234\255\
\235\255\237\255\000\000\000\000\247\255\202\255\198\255\000\000\
\198\255\121\255\112\255\243\255\198\255\246\254\248\255\198\255\
\178\255\178\255\178\255\121\255\013\255\000\000\000\000\000\000\
\244\255\198\255\000\000\000\000\000\000\000\000\246\255\249\255\
\253\255\255\255\006\000\000\000\008\000\009\000\010\000\011\000\
\014\000\015\000\121\255\000\000\000\000\016\000\000\000\000\000\
\000\000\112\255\112\255\000\000\000\000\000\000\000\000\000\000\
\000\000\198\255\000\000\198\255\198\255\017\000\018\000\019\000\
\000\000\000\000\000\000"

let yyrindex = "\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\176\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\123\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\020\000\
\000\000\000\000\020\000\020\000\000\000\000\000\020\000\020\000\
\020\000\020\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\020\000\000\000\000\000\000\000\000\000\000\000\
\000\000\026\255\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\012\000\000\000\021\000\000\000\000\000\000\000\
\022\000\000\000\000\000\000\000\020\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\020\000\000\000\
\020\000\000\000\000\000\000\000\020\000\020\000\039\255\020\000\
\020\000\020\000\020\000\000\000\000\000\000\000\000\000\000\000\
\000\000\020\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\020\000\000\000\020\000\020\000\000\000\000\000\000\000\
\000\000\000\000\000\000"

let yygindex = "\000\000\
\000\000\000\000\000\000\000\000\255\000\181\255\226\000\230\000\
\023\000\245\255\000\000\029\001\000\000\044\001\239\255\000\000\
\250\255\223\255\153\255\173\255\000\000\182\255\187\255\234\000\
\175\255\214\255\211\000"

let yytablesize = 330
let yytable = "\050\000\
\051\000\112\000\026\000\033\000\044\000\025\000\144\000\114\000\
\005\000\144\000\025\000\025\000\007\000\025\000\123\000\026\000\
\144\000\131\000\132\000\163\000\164\000\148\000\033\000\167\000\
\168\000\169\000\170\000\148\000\139\000\145\000\044\000\029\000\
\152\000\025\000\153\000\180\000\009\000\030\000\162\000\031\000\
\171\000\162\000\172\000\017\000\032\000\025\000\044\000\018\000\
\011\000\019\000\020\000\021\000\012\000\022\000\063\000\013\000\
\023\000\162\000\024\000\045\000\025\000\193\000\212\000\099\000\
\142\000\182\000\143\000\124\000\125\000\126\000\183\000\200\000\
\014\000\201\000\070\000\044\000\143\000\205\000\206\000\107\000\
\207\000\208\000\209\000\210\000\189\000\185\000\186\000\187\000\
\045\000\064\000\214\000\176\000\141\000\176\000\109\000\015\000\
\202\000\146\000\140\000\016\000\080\000\081\000\154\000\162\000\
\162\000\162\000\211\000\165\000\166\000\052\000\127\000\128\000\
\129\000\130\000\080\000\081\000\175\000\055\000\177\000\154\000\
\154\000\062\000\230\000\053\000\231\000\232\000\048\000\104\000\
\147\000\226\000\048\000\054\000\048\000\048\000\048\000\066\000\
\048\000\048\000\045\000\048\000\188\000\048\000\046\000\048\000\
\067\000\115\000\116\000\117\000\194\000\154\000\118\000\068\000\
\036\000\037\000\047\000\048\000\038\000\001\000\002\000\003\000\
\049\000\203\000\039\000\040\000\069\000\041\000\099\000\150\000\
\025\000\119\000\104\000\151\000\048\000\058\000\059\000\060\000\
\072\000\154\000\073\000\075\000\075\000\075\000\075\000\075\000\
\075\000\075\000\075\000\075\000\075\000\075\000\075\000\075\000\
\075\000\075\000\075\000\075\000\075\000\078\000\025\000\074\000\
\228\000\229\000\115\000\116\000\117\000\045\000\029\000\118\000\
\075\000\046\000\076\000\077\000\030\000\099\000\031\000\102\000\
\104\000\108\000\025\000\032\000\025\000\047\000\048\000\149\000\
\173\000\075\000\119\000\174\000\080\000\081\000\178\000\173\000\
\082\000\133\000\083\000\084\000\137\000\085\000\086\000\087\000\
\088\000\089\000\090\000\091\000\092\000\093\000\094\000\095\000\
\096\000\097\000\080\000\081\000\138\000\181\000\082\000\179\000\
\083\000\084\000\190\000\085\000\086\000\087\000\088\000\089\000\
\090\000\091\000\092\000\093\000\094\000\095\000\096\000\097\000\
\017\000\199\000\144\000\191\000\018\000\192\000\019\000\020\000\
\021\000\195\000\022\000\196\000\197\000\023\000\198\000\024\000\
\089\000\025\000\036\000\037\000\204\000\213\000\038\000\215\000\
\079\000\088\000\216\000\110\000\039\000\040\000\217\000\041\000\
\218\000\111\000\025\000\115\000\116\000\155\000\156\000\219\000\
\157\000\220\000\221\000\222\000\223\000\158\000\071\000\224\000\
\225\000\227\000\233\000\234\000\235\000\071\000\065\000\072\000\
\136\000\159\000"

let yycheck = "\017\000\
\018\000\077\000\014\000\015\000\016\000\021\001\027\001\082\000\
\049\001\027\001\021\001\021\001\049\001\021\001\084\000\027\000\
\027\001\092\000\093\000\123\000\124\000\105\000\034\000\127\000\
\128\000\129\000\130\000\111\000\098\000\050\001\042\000\007\001\
\050\001\021\001\050\001\139\000\049\001\013\001\120\000\015\001\
\050\001\123\000\050\001\004\001\020\001\021\001\021\001\008\001\
\001\001\010\001\011\001\012\001\002\001\014\001\015\001\003\001\
\017\001\139\000\019\001\021\001\021\001\165\000\050\001\049\001\
\050\001\141\000\100\000\085\000\086\000\087\000\146\000\175\000\
\027\001\177\000\050\001\050\001\110\000\181\000\182\000\057\000\
\184\000\185\000\186\000\187\000\159\000\155\000\156\000\157\000\
\050\001\050\001\194\000\134\000\099\000\136\000\072\000\027\001\
\178\000\104\000\025\001\027\001\027\001\028\001\114\000\185\000\
\186\000\187\000\188\000\125\000\126\000\049\001\088\000\089\000\
\090\000\091\000\027\001\028\001\134\000\027\001\136\000\131\000\
\132\000\029\001\226\000\049\001\228\000\229\000\004\001\049\001\
\050\001\211\000\008\001\049\001\010\001\011\001\012\001\032\001\
\014\001\015\001\027\001\017\001\158\000\019\001\031\001\021\001\
\032\001\025\001\026\001\027\001\166\000\161\000\030\001\032\001\
\005\001\006\001\043\001\044\001\009\001\001\000\002\000\003\000\
\049\001\179\000\015\001\016\001\027\001\018\001\049\001\050\001\
\021\001\049\001\049\001\050\001\050\001\022\001\023\001\024\001\
\049\001\189\000\032\001\004\001\005\001\006\001\007\001\008\001\
\009\001\010\001\011\001\012\001\013\001\014\001\015\001\016\001\
\017\001\018\001\019\001\020\001\021\001\050\001\021\001\049\001\
\218\000\219\000\025\001\026\001\027\001\027\001\007\001\030\001\
\032\001\031\001\049\001\049\001\013\001\049\001\015\001\027\001\
\049\001\032\001\021\001\020\001\021\001\043\001\044\001\050\001\
\030\001\050\001\049\001\049\001\027\001\028\001\030\001\030\001\
\031\001\049\001\033\001\034\001\049\001\036\001\037\001\038\001\
\039\001\040\001\041\001\042\001\043\001\044\001\045\001\046\001\
\047\001\048\001\027\001\028\001\049\001\027\001\031\001\031\001\
\033\001\034\001\050\001\036\001\037\001\038\001\039\001\040\001\
\041\001\042\001\043\001\044\001\045\001\046\001\047\001\048\001\
\004\001\027\001\027\001\050\001\008\001\050\001\010\001\011\001\
\012\001\050\001\014\001\050\001\050\001\017\001\050\001\019\001\
\021\001\021\001\005\001\006\001\050\001\050\001\009\001\050\001\
\042\000\021\001\050\001\074\000\015\001\016\001\050\001\018\001\
\050\001\076\000\021\001\025\001\026\001\027\001\028\001\050\001\
\030\001\050\001\050\001\050\001\050\001\035\001\034\000\050\001\
\050\001\050\001\050\001\050\001\050\001\050\001\027\000\050\001\
\095\000\119\000"

let yynames_const = "\
  BENCHMARK\000\
  LOGIC\000\
  THEORY\000\
  ASSUMPTION_ATRB\000\
  AXIOMS_ATRB\000\
  DEFINITION_ATRB\000\
  EXTENSIONS_ATRB\000\
  FORMULA_ATRB\000\
  FUNS_ATRB\000\
  EXTRAFUNS_ATRB\000\
  EXTRASORTS_ATRB\000\
  EXTRAPREDS_ATRB\000\
  LANGUAGE_ATRB\000\
  LOGIC_ATRB\000\
  NOTES_ATRB\000\
  PREDS_ATRB\000\
  REWRITING_ATRB\000\
  SORTS_ATRB\000\
  STATUS_ATRB\000\
  THEORY_ATRB\000\
  SAT\000\
  UNSAT\000\
  UNKNOWN\000\
  EQUALS\000\
  DISTINCT\000\
  ITE\000\
  NOT\000\
  IMPLIES\000\
  IFTHENELSE\000\
  AND\000\
  OR\000\
  XOR\000\
  IFF\000\
  TRUE\000\
  FALSE\000\
  EXISTS\000\
  FORALL\000\
  LET\000\
  FLET\000\
  LP\000\
  RP\000\
  EOF\000\
  "

let yynames_block = "\
  ATTRIBUTE\000\
  NUMERAL\000\
  RATIONAL\000\
  ID\000\
  ARSYMB\000\
  USER_VALUE\000\
  VAR\000\
  FVAR\000\
  STRING\000\
  "

let yyact = [|
  (fun _ -> failwith "parser")
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'theory_attributes) in
    Obj.repr(
# 98 "smt_parser.mly"
                                    ( _3 , List.rev _4 )
# 415 "smt_parser.ml"
               : Smt_ast.ptheory))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'theory_attribute) in
    Obj.repr(
# 102 "smt_parser.mly"
                   ( [_1] )
# 422 "smt_parser.ml"
               : 'theory_attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'theory_attributes) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'theory_attribute) in
    Obj.repr(
# 103 "smt_parser.mly"
                                     ( _2::_1 )
# 430 "smt_parser.ml"
               : 'theory_attributes))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'ids) in
    Obj.repr(
# 107 "smt_parser.mly"
                       ( Tsorts _3 )
# 437 "smt_parser.ml"
               : 'theory_attribute))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'fun_decls) in
    Obj.repr(
# 108 "smt_parser.mly"
                            ( Funs _3 )
# 444 "smt_parser.ml"
               : 'theory_attribute))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'pred_decls) in
    Obj.repr(
# 109 "smt_parser.mly"
                              ( Preds _3 )
# 451 "smt_parser.ml"
               : 'theory_attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 110 "smt_parser.mly"
                         ( Definition _2 )
# 458 "smt_parser.ml"
               : 'theory_attribute))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'formulas) in
    Obj.repr(
# 111 "smt_parser.mly"
                             ( Axioms _3 )
# 465 "smt_parser.ml"
               : 'theory_attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 112 "smt_parser.mly"
                    ( Tcomment )
# 472 "smt_parser.ml"
               : 'theory_attribute))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'annot) in
    Obj.repr(
# 113 "smt_parser.mly"
        ( Tcomment )
# 479 "smt_parser.ml"
               : 'theory_attribute))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'logic_attributes) in
    Obj.repr(
# 117 "smt_parser.mly"
                                  ( _3 , List.rev _4 )
# 487 "smt_parser.ml"
               : Smt_ast.plogic))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'logic_attribute) in
    Obj.repr(
# 121 "smt_parser.mly"
                  ( [_1] )
# 494 "smt_parser.ml"
               : 'logic_attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'logic_attributes) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'logic_attribute) in
    Obj.repr(
# 122 "smt_parser.mly"
                                   ( _2::_1 )
# 502 "smt_parser.ml"
               : 'logic_attributes))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 126 "smt_parser.mly"
                 ( Ltheory _2 )
# 509 "smt_parser.ml"
               : 'logic_attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 127 "smt_parser.mly"
                       ( Lcomment )
# 516 "smt_parser.ml"
               : 'logic_attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 128 "smt_parser.mly"
                         ( Lcomment )
# 523 "smt_parser.ml"
               : 'logic_attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 129 "smt_parser.mly"
                    ( Lcomment )
# 530 "smt_parser.ml"
               : 'logic_attribute))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'annot) in
    Obj.repr(
# 130 "smt_parser.mly"
        ( Lcomment )
# 537 "smt_parser.ml"
               : 'logic_attribute))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'bench_attributes) in
    Obj.repr(
# 134 "smt_parser.mly"
                                      ( _3 , List.rev _4 , !status)
# 545 "smt_parser.ml"
               : Smt_ast.pbench))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bench_attribute) in
    Obj.repr(
# 138 "smt_parser.mly"
                  ( [_1] )
# 552 "smt_parser.ml"
               : 'bench_attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'bench_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 139 "smt_parser.mly"
                                     (_1)
# 560 "smt_parser.ml"
               : 'bench_attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'bench_attributes) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'bench_attribute) in
    Obj.repr(
# 140 "smt_parser.mly"
                                    ( _2::_1 )
# 568 "smt_parser.ml"
               : 'bench_attributes))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 144 "smt_parser.mly"
                                   ( Pblogic _2 )
# 575 "smt_parser.ml"
               : 'bench_attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'formula) in
    Obj.repr(
# 145 "smt_parser.mly"
                                   ( Pbassumption (loc (), _2) )
# 582 "smt_parser.ml"
               : 'bench_attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'formula) in
    Obj.repr(
# 146 "smt_parser.mly"
                                   ( Pbformula (loc (), _2) )
# 589 "smt_parser.ml"
               : 'bench_attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'status) in
    Obj.repr(
# 147 "smt_parser.mly"
                                   ( status:=_2;Pbstatus _2 )
# 596 "smt_parser.ml"
               : 'bench_attribute))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'ids) in
    Obj.repr(
# 148 "smt_parser.mly"
                                   ( Pbextr_sorts (List.rev _3) )
# 603 "smt_parser.ml"
               : 'bench_attribute))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'fun_decls) in
    Obj.repr(
# 149 "smt_parser.mly"
                                   ( Pbextr_funs (List.rev _3) )
# 610 "smt_parser.ml"
               : 'bench_attribute))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'pred_decls) in
    Obj.repr(
# 150 "smt_parser.mly"
                                   ( Pbextr_preds (List.rev _3) )
# 617 "smt_parser.ml"
               : 'bench_attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'formulas) in
    Obj.repr(
# 151 "smt_parser.mly"
                                   ( Pbrewriting (loc (), _2) )
# 624 "smt_parser.ml"
               : 'bench_attribute))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'annot) in
    Obj.repr(
# 152 "smt_parser.mly"
                                   ( Pannotation )
# 631 "smt_parser.ml"
               : 'bench_attribute))
; (fun __caml_parser_env ->
    Obj.repr(
# 156 "smt_parser.mly"
          ( Sat )
# 637 "smt_parser.ml"
               : 'status))
; (fun __caml_parser_env ->
    Obj.repr(
# 157 "smt_parser.mly"
          ( Unsat )
# 643 "smt_parser.ml"
               : 'status))
; (fun __caml_parser_env ->
    Obj.repr(
# 158 "smt_parser.mly"
          ( Unknown )
# 649 "smt_parser.ml"
               : 'status))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 162 "smt_parser.mly"
          ( _1 )
# 656 "smt_parser.ml"
               : 'symb))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 163 "smt_parser.mly"
          ( _1 )
# 663 "smt_parser.ml"
               : 'symb))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'fun_decls) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'fun_decl) in
    Obj.repr(
# 166 "smt_parser.mly"
                     ( _2::_1 )
# 671 "smt_parser.ml"
               : 'fun_decls))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'fun_decl) in
    Obj.repr(
# 167 "smt_parser.mly"
           ( [_1] )
# 678 "smt_parser.ml"
               : 'fun_decls))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'symb) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'ids) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 172 "smt_parser.mly"
    ( match _3 with 
	  r::l -> (loc (), {fname=_2; fargs=List.rev l; fres=r } )
	| [] -> assert false )
# 689 "smt_parser.ml"
               : 'fun_decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 175 "smt_parser.mly"
                              ( (loc (), {fname=_2; fargs=[]; fres=(loc (), _3) } ) )
# 698 "smt_parser.ml"
               : 'fun_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'pred_decls) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pred_decl) in
    Obj.repr(
# 179 "smt_parser.mly"
                       ( _2::_1 )
# 706 "smt_parser.ml"
               : 'pred_decls))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pred_decl) in
    Obj.repr(
# 180 "smt_parser.mly"
            ( [_1] )
# 713 "smt_parser.ml"
               : 'pred_decls))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'symb) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'opt_ids) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 184 "smt_parser.mly"
                                 ( (loc (), {pname=_2; pargs=List.rev _3}) )
# 722 "smt_parser.ml"
               : 'pred_decl))
; (fun __caml_parser_env ->
    Obj.repr(
# 188 "smt_parser.mly"
                ( [] )
# 728 "smt_parser.ml"
               : 'opt_ids))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ids) in
    Obj.repr(
# 189 "smt_parser.mly"
                ( _1 )
# 735 "smt_parser.ml"
               : 'opt_ids))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 193 "smt_parser.mly"
            ( [(loc (),_1)] )
# 742 "smt_parser.ml"
               : 'ids))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'ids) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 194 "smt_parser.mly"
         ( (loc (),_2)::_1 )
# 750 "smt_parser.ml"
               : 'ids))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'formula) in
    Obj.repr(
# 198 "smt_parser.mly"
          ( [_1] )
# 757 "smt_parser.ml"
               : 'formulas))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'formula) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'formulas) in
    Obj.repr(
# 199 "smt_parser.mly"
                   ( _1::_2 )
# 765 "smt_parser.ml"
               : 'formulas))
; (fun __caml_parser_env ->
    Obj.repr(
# 204 "smt_parser.mly"
   ( mk_form True )
# 771 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'annots) in
    Obj.repr(
# 206 "smt_parser.mly"
   ( mk_form True )
# 778 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    Obj.repr(
# 208 "smt_parser.mly"
   ( mk_form False )
# 784 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'annots) in
    Obj.repr(
# 210 "smt_parser.mly"
   ( mk_form False )
# 791 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 212 "smt_parser.mly"
   ( mk_form (Fvar _1) )
# 798 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'annots) in
    Obj.repr(
# 214 "smt_parser.mly"
   ( mk_form (Fvar _2) )
# 806 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 216 "smt_parser.mly"
   ( mk_form (Pred(_1,[]) ))
# 813 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'symb) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'terms) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 218 "smt_parser.mly"
   ( mk_form (Pred(_2,List.rev _3)) )
# 822 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'terms) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 220 "smt_parser.mly"
   ( mk_form (Distinct (List.rev _3)))
# 830 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'terms) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 222 "smt_parser.mly"
   ( mk_form (Equals (List.rev _3)))
# 838 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'formula) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 224 "smt_parser.mly"
   ( mk_form (Not _3) )
# 846 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'formula) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'formula) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 226 "smt_parser.mly"
   ( mk_form (Implies(_3,_4)) )
# 855 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'formula) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'formula) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'formula) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 228 "smt_parser.mly"
   ( mk_form (Fite(_3,_4,_5)) )
# 865 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'formulas) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 230 "smt_parser.mly"
   ( mk_form (And _3) )
# 873 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'formulas) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 232 "smt_parser.mly"
   ( mk_form (Or _3) )
# 881 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'formulas) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 234 "smt_parser.mly"
   ( mk_form (Xor _3) )
# 889 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'formulas) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 236 "smt_parser.mly"
   ( mk_form (Iff _3) )
# 897 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'binders) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'formula) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 238 "smt_parser.mly"
   ( mk_form (Forall(List.rev _3,_4)) )
# 906 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'binders) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'formula) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 240 "smt_parser.mly"
   ( mk_form (Exists(List.rev _3,_4)) )
# 915 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _4 = (Parsing.peek_val __caml_parser_env 5 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 4 : 'term) in
    let _7 = (Parsing.peek_val __caml_parser_env 2 : 'formula) in
    let _8 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 242 "smt_parser.mly"
   ( mk_form (Let(_4,mk_term _5,_7)) )
# 925 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    let _4 = (Parsing.peek_val __caml_parser_env 5 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 4 : 'formula) in
    let _7 = (Parsing.peek_val __caml_parser_env 2 : 'formula) in
    let _8 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 244 "smt_parser.mly"
   ( mk_form (Flet(_4,_5,_7)) )
# 935 "smt_parser.ml"
               : 'formula))
; (fun __caml_parser_env ->
    Obj.repr(
# 248 "smt_parser.mly"
                (  )
# 941 "smt_parser.ml"
               : 'opt_annots))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'annots) in
    Obj.repr(
# 249 "smt_parser.mly"
           (  )
# 948 "smt_parser.ml"
               : 'opt_annots))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'annot) in
    Obj.repr(
# 253 "smt_parser.mly"
        ()
# 955 "smt_parser.ml"
               : 'annots))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'annots) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'annot) in
    Obj.repr(
# 254 "smt_parser.mly"
               ()
# 963 "smt_parser.ml"
               : 'annots))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 258 "smt_parser.mly"
                       ( )
# 970 "smt_parser.ml"
               : 'annot))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 259 "smt_parser.mly"
                       ( )
# 978 "smt_parser.ml"
               : 'annot))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'binder) in
    Obj.repr(
# 263 "smt_parser.mly"
                 ( [_1] )
# 985 "smt_parser.ml"
               : 'binders))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'binders) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'binder) in
    Obj.repr(
# 264 "smt_parser.mly"
                 ( _2::_1 )
# 993 "smt_parser.ml"
               : 'binders))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 268 "smt_parser.mly"
                 ( { var=_2 ; sort=_3 } )
# 1001 "smt_parser.ml"
               : 'binder))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'term) in
    Obj.repr(
# 272 "smt_parser.mly"
             ( [mk_term _1] )
# 1008 "smt_parser.ml"
               : 'terms))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'terms) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'term) in
    Obj.repr(
# 273 "smt_parser.mly"
             ( (mk_term _2)::_1 )
# 1016 "smt_parser.ml"
               : 'terms))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'baseterm) in
    Obj.repr(
# 276 "smt_parser.mly"
            ( _1 )
# 1023 "smt_parser.ml"
               : 'term))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'baseterm) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'annots) in
    Obj.repr(
# 277 "smt_parser.mly"
                        ( _2 )
# 1031 "smt_parser.ml"
               : 'term))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'terms) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 278 "smt_parser.mly"
                            ( Fun(_2,List.rev _3) )
# 1040 "smt_parser.ml"
               : 'term))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'terms) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 279 "smt_parser.mly"
                             ( Fun(_2,List.rev _3) )
# 1049 "smt_parser.ml"
               : 'term))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'terms) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 280 "smt_parser.mly"
                                ( Fun(_2,List.rev _3) )
# 1058 "smt_parser.ml"
               : 'term))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'formula) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'term) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'term) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'opt_annots) in
    Obj.repr(
# 281 "smt_parser.mly"
                                         ( Ite(_3,mk_term _4,mk_term _5) )
# 1068 "smt_parser.ml"
               : 'term))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 285 "smt_parser.mly"
      ( Var _1 )
# 1075 "smt_parser.ml"
               : 'baseterm))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 286 "smt_parser.mly"
      ( Fun(_1,[]) )
# 1082 "smt_parser.ml"
               : 'baseterm))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 287 "smt_parser.mly"
          ( Num _1 )
# 1089 "smt_parser.ml"
               : 'baseterm))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 288 "smt_parser.mly"
           ( Rat _1 )
# 1096 "smt_parser.ml"
               : 'baseterm))
(* Entry benchmark *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry logic *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry theory *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
|]
let yytables =
  { Parsing.actions=yyact;
    Parsing.transl_const=yytransl_const;
    Parsing.transl_block=yytransl_block;
    Parsing.lhs=yylhs;
    Parsing.len=yylen;
    Parsing.defred=yydefred;
    Parsing.dgoto=yydgoto;
    Parsing.sindex=yysindex;
    Parsing.rindex=yyrindex;
    Parsing.gindex=yygindex;
    Parsing.tablesize=yytablesize;
    Parsing.table=yytable;
    Parsing.check=yycheck;
    Parsing.error_function=parse_error;
    Parsing.names_const=yynames_const;
    Parsing.names_block=yynames_block }
let benchmark (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 1 lexfun lexbuf : Smt_ast.pbench)
let logic (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 2 lexfun lexbuf : Smt_ast.plogic)
let theory (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 3 lexfun lexbuf : Smt_ast.ptheory)
end
include (IMPLEMENTATION : INTERFACE)
end
and Smt_lex: sig
#0 "smt_lex.mli"
exception Lexical_error of string
val attribute : string -> Smt_parser.token
val id_or_keyword : string -> Smt_parser.token
val newline : Lexing.lexbuf -> unit
val __ocaml_lex_tables : Lexing.lex_tables
val token : Lexing.lexbuf -> Smt_parser.token
val __ocaml_lex_token_rec : Lexing.lexbuf -> int -> Smt_parser.token
val user_value : Buffer.t -> Lexing.lexbuf -> Smt_parser.token
val __ocaml_lex_user_value_rec :
  Buffer.t -> Lexing.lexbuf -> int -> Smt_parser.token
val string : Buffer.t -> Lexing.lexbuf -> Smt_parser.token
val __ocaml_lex_string_rec :
  Buffer.t -> Lexing.lexbuf -> int -> Smt_parser.token
end = struct
let _ = Printf.fprintf stderr "Executing smt_lex.ml\n%!"module type INTERFACE = sig
#0 "smt_lex.mli"
exception Lexical_error of string
val attribute : string -> Smt_parser.token
val id_or_keyword : string -> Smt_parser.token
val newline : Lexing.lexbuf -> unit
val __ocaml_lex_tables : Lexing.lex_tables
val token : Lexing.lexbuf -> Smt_parser.token
val __ocaml_lex_token_rec : Lexing.lexbuf -> int -> Smt_parser.token
val user_value : Buffer.t -> Lexing.lexbuf -> Smt_parser.token
val __ocaml_lex_user_value_rec :
  Buffer.t -> Lexing.lexbuf -> int -> Smt_parser.token
val string : Buffer.t -> Lexing.lexbuf -> Smt_parser.token
val __ocaml_lex_string_rec :
  Buffer.t -> Lexing.lexbuf -> int -> Smt_parser.token
end
module IMPLEMENTATION = struct
#0 "smt_lex.ml"
# 18 "smt_lex.mll"
 
  (* This program is free software.  See LICENSE for more information *)
  open Lexing
  open Smt_parser
    
  exception Lexical_error of string

  let attribute = 
    let h = Hashtbl.create 17 in
    List.iter (fun (s,k) -> Hashtbl.add h s k)
      [	"assumption", ASSUMPTION_ATRB;
	"axioms", AXIOMS_ATRB;
	"definition", DEFINITION_ATRB;
	"extensions", EXTENSIONS_ATRB;
	"formula", FORMULA_ATRB;
	"funs", FUNS_ATRB;
	"extrafuns", EXTRAFUNS_ATRB;
	"extrasorts", EXTRASORTS_ATRB;
	"extrapreds", EXTRAPREDS_ATRB;
	"language", LANGUAGE_ATRB;
	"logic", LOGIC_ATRB;
	"notes", NOTES_ATRB;
	"preds", PREDS_ATRB;
	"sorts", SORTS_ATRB;
	"status", STATUS_ATRB;
	"theory" , THEORY_ATRB
      ];
    fun s -> 
      try Hashtbl.find h s with Not_found -> ATTRIBUTE s


  let id_or_keyword = 
    let h = Hashtbl.create 17 in
    List.iter (fun (s,k) -> Hashtbl.add h s k)
      [ "true", TRUE;
	"false", FALSE;
	"ite",  ITE;
	"not", NOT;
	"implies", IMPLIES;
	"if_then_else",  IFTHENELSE;
	"and", AND;
	"or",  OR;
	"xor", XOR;
	"iff", IFF;
	"exists", EXISTS;
	"forall", FORALL;
	"let", LET;
	"flet", FLET;
	"sat", SAT ;
	"unsat", UNSAT;
	"unknown", UNKNOWN;
	"benchmark", BENCHMARK;
	"theory", THEORY;
	"logic", LOGIC;
	"distinct", DISTINCT
      ];
    fun s -> 
      try Hashtbl.find h s with Not_found -> ID s

  let newline lexbuf =
    let pos = lexbuf.lex_curr_p in
    lexbuf.lex_curr_p <- 
      { pos with pos_lnum = pos.pos_lnum + 1; pos_bol = pos.pos_cnum; 
        pos_cnum=0 }


# 69 "smt_lex.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\238\255\239\255\062\000\120\000\192\000\197\000\020\001\
    \108\001\050\001\136\001\250\255\251\255\252\255\253\255\254\255\
    \255\255\247\255\029\000\051\001\052\001\201\000\205\000\055\001\
    \068\001\057\001\070\001\073\001\153\001\101\001\069\001\147\000\
    \102\001\081\000\135\001\028\000\178\001\038\000\039\000\038\000\
    \047\000\046\000\096\000\108\000\103\000\106\000\248\255\168\001\
    \189\001\010\002\094\002\178\002\103\001\252\255\253\255\254\255\
    \255\255\155\001\251\255\252\255\010\000\254\255\255\255\253\255\
    ";
  Lexing.lex_backtrk = 
   "\255\255\255\255\255\255\017\000\017\000\017\000\011\000\010\000\
    \009\000\017\000\006\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\008\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \012\000\013\000\014\000\015\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\003\000\255\255\255\255\255\255\
    ";
  Lexing.lex_default = 
   "\001\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\018\000\255\255\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\033\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\
    \255\255\255\255\255\255\255\255\054\000\000\000\000\000\000\000\
    \000\000\059\000\000\000\000\000\255\255\000\000\000\000\000\000\
    ";
  Lexing.lex_trans = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\015\000\016\000\000\000\000\000\015\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \015\000\000\000\014\000\008\000\004\000\008\000\008\000\017\000\
    \012\000\011\000\008\000\008\000\063\000\008\000\000\000\008\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\003\000\009\000\008\000\010\000\008\000\005\000\
    \008\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\034\000\000\000\000\000\000\000\000\000\
    \000\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\013\000\008\000\037\000\008\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\038\000\039\000\040\000\041\000\017\000\042\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\017\000\043\000\044\000\045\000\017\000\
    \046\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\047\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\032\000\
    \002\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\000\000\000\000\255\255\000\000\000\000\
    \000\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\007\000\017\000\017\000\017\000\023\000\
    \022\000\017\000\007\000\017\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\017\000\017\000\
    \017\000\255\255\020\000\017\000\020\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\017\000\
    \017\000\056\000\000\000\007\000\000\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\008\000\
    \036\000\008\000\008\000\255\255\036\000\000\000\008\000\008\000\
    \021\000\008\000\000\000\008\000\000\000\000\000\000\000\000\000\
    \024\000\000\000\026\000\017\000\019\000\061\000\019\000\036\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\000\000\
    \028\000\000\000\008\000\008\000\027\000\008\000\000\000\008\000\
    \025\000\029\000\031\000\036\000\000\000\062\000\000\000\036\000\
    \000\000\035\000\000\000\000\000\008\000\008\000\008\000\000\000\
    \008\000\255\255\000\000\033\000\000\000\255\255\000\000\000\000\
    \000\000\000\000\036\000\000\000\000\000\000\000\000\000\030\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\000\000\000\000\055\000\000\000\000\000\000\000\
    \008\000\000\000\008\000\000\000\035\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\060\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\008\000\000\000\008\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\049\000\255\255\255\255\255\255\000\000\000\000\255\255\
    \049\000\255\255\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\255\255\255\255\255\255\000\000\
    \000\000\255\255\000\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\255\255\255\255\053\000\
    \000\000\049\000\000\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\050\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\050\000\000\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \000\000\255\255\000\000\058\000\000\000\000\000\000\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\000\000\000\000\000\000\000\000\050\000\000\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\051\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \051\000\000\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\000\000\000\000\000\000\
    \000\000\051\000\000\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000";
  Lexing.lex_check = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\255\255\255\255\000\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\000\000\000\000\000\000\000\000\000\000\018\000\
    \000\000\000\000\000\000\000\000\060\000\000\000\255\255\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\033\000\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\035\000\000\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\037\000\038\000\039\000\040\000\031\000\041\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\021\000\042\000\043\000\044\000\022\000\
    \045\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\006\000\255\255\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\031\000\
    \000\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\255\255\255\255\018\000\255\255\255\255\
    \255\255\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\007\000\009\000\019\000\020\000\022\000\
    \021\000\023\000\007\000\025\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\024\000\030\000\
    \026\000\033\000\009\000\027\000\020\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\029\000\
    \032\000\052\000\255\255\007\000\255\255\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\008\000\
    \034\000\008\000\008\000\031\000\034\000\255\255\008\000\008\000\
    \019\000\008\000\255\255\008\000\255\255\255\255\255\255\255\255\
    \023\000\255\255\025\000\028\000\009\000\057\000\020\000\034\000\
    \008\000\008\000\008\000\010\000\008\000\010\000\010\000\255\255\
    \027\000\255\255\010\000\010\000\026\000\010\000\255\255\010\000\
    \024\000\028\000\030\000\036\000\255\255\057\000\255\255\036\000\
    \255\255\034\000\255\255\255\255\010\000\010\000\010\000\255\255\
    \010\000\021\000\255\255\032\000\255\255\022\000\255\255\255\255\
    \255\255\255\255\036\000\255\255\255\255\255\255\255\255\029\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\255\255\255\255\052\000\255\255\255\255\255\255\
    \008\000\255\255\008\000\255\255\036\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\057\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\010\000\255\255\010\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\049\000\009\000\019\000\020\000\255\255\255\255\023\000\
    \049\000\025\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\024\000\030\000\026\000\255\255\
    \255\255\027\000\255\255\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\029\000\032\000\052\000\
    \255\255\049\000\255\255\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\050\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\050\000\255\255\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \255\255\028\000\255\255\057\000\255\255\255\255\255\255\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\255\255\255\255\255\255\255\255\050\000\255\255\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\051\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \051\000\255\255\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\255\255\255\255\255\255\
    \255\255\051\000\255\255\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255";
  Lexing.lex_base_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\010\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    ";
  Lexing.lex_backtrk_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    ";
  Lexing.lex_default_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    ";
  Lexing.lex_trans_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\001\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000";
  Lexing.lex_check_code = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255";
  Lexing.lex_code = 
   "\255\001\255\255\000\001\255";
}

let rec token lexbuf =
lexbuf.Lexing.lex_mem <- Array.create 2 (-1) ;   __ocaml_lex_token_rec lexbuf 0
and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
  match Lexing.new_engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 94 "smt_lex.mll"
      ( newline lexbuf ; token lexbuf )
# 452 "smt_lex.ml"

  | 1 ->
# 96 "smt_lex.mll"
      ( token lexbuf )
# 457 "smt_lex.ml"

  | 2 ->
# 98 "smt_lex.mll"
      ( string (Buffer.create 1024) lexbuf )
# 462 "smt_lex.ml"

  | 3 ->
# 100 "smt_lex.mll"
      ( user_value (Buffer.create 1024) lexbuf )
# 467 "smt_lex.ml"

  | 4 ->
# 102 "smt_lex.mll"
      ( LP )
# 472 "smt_lex.ml"

  | 5 ->
# 104 "smt_lex.mll"
      ( RP )
# 477 "smt_lex.ml"

  | 6 ->
# 106 "smt_lex.mll"
      ( EQUALS )
# 482 "smt_lex.ml"

  | 7 ->
# 108 "smt_lex.mll"
      ( newline lexbuf; REWRITING_ATRB )
# 487 "smt_lex.ml"

  | 8 ->
# 110 "smt_lex.mll"
      ( newline lexbuf; token lexbuf )
# 492 "smt_lex.ml"

  | 9 ->
# 112 "smt_lex.mll"
      ( ARSYMB(Lexing.lexeme lexbuf) )
# 497 "smt_lex.ml"

  | 10 ->
# 114 "smt_lex.mll"
      ( id_or_keyword (Lexing.lexeme lexbuf) )
# 502 "smt_lex.ml"

  | 11 ->
# 116 "smt_lex.mll"
      ( NUMERAL(Lexing.lexeme lexbuf) )
# 507 "smt_lex.ml"

  | 12 ->
let
# 117 "smt_lex.mll"
                e
# 513 "smt_lex.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_mem.(0)
and
# 117 "smt_lex.mll"
                                   d
# 518 "smt_lex.ml"
= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_mem.(0) + 1) lexbuf.Lexing.lex_curr_pos in
# 118 "smt_lex.mll"
      ( let s = "1"^(String.make (String.length d) '0') in
	(* RATIONAL(e^d^"/"^s) } *)
      NUMERAL(e^d^"/"^s) )
# 524 "smt_lex.ml"

  | 13 ->
# 124 "smt_lex.mll"
      ( VAR(Lexing.lexeme lexbuf) )
# 529 "smt_lex.ml"

  | 14 ->
# 126 "smt_lex.mll"
      ( FVAR(Lexing.lexeme lexbuf) )
# 534 "smt_lex.ml"

  | 15 ->
let
# 127 "smt_lex.mll"
                        id
# 540 "smt_lex.ml"
= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 1) lexbuf.Lexing.lex_curr_pos in
# 128 "smt_lex.mll"
      ( attribute id )
# 544 "smt_lex.ml"

  | 16 ->
# 130 "smt_lex.mll"
      ( EOF )
# 549 "smt_lex.ml"

  | 17 ->
# 132 "smt_lex.mll"
      ( raise (Lexical_error ("illegal character: " ^ lexeme lexbuf)) )
# 554 "smt_lex.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_token_rec lexbuf __ocaml_lex_state

and user_value buf lexbuf =
  __ocaml_lex_user_value_rec buf lexbuf 52
and __ocaml_lex_user_value_rec buf lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 135 "smt_lex.mll"
         ( newline lexbuf; Buffer.add_char buf '\n' ; user_value buf lexbuf)
# 565 "smt_lex.ml"

  | 1 ->
# 136 "smt_lex.mll"
         ( USER_VALUE (Buffer.contents buf) )
# 570 "smt_lex.ml"

  | 2 ->
let
# 137 "smt_lex.mll"
       c
# 576 "smt_lex.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 137 "smt_lex.mll"
         ( Buffer.add_char buf c; user_value buf lexbuf )
# 580 "smt_lex.ml"

  | 3 ->
# 138 "smt_lex.mll"
         ( raise (Lexical_error ("unterminated annotation")) )
# 585 "smt_lex.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_user_value_rec buf lexbuf __ocaml_lex_state

and string buf lexbuf =
  __ocaml_lex_string_rec buf lexbuf 57
and __ocaml_lex_string_rec buf lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 141 "smt_lex.mll"
         ( STRING (Buffer.contents buf) )
# 596 "smt_lex.ml"

  | 1 ->
# 142 "smt_lex.mll"
         ( newline lexbuf; Buffer.add_char buf '\n' ; string buf lexbuf)
# 601 "smt_lex.ml"

  | 2 ->
# 143 "smt_lex.mll"
         ( Buffer.add_char buf '"'; string buf lexbuf )
# 606 "smt_lex.ml"

  | 3 ->
let
# 144 "smt_lex.mll"
       c
# 612 "smt_lex.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 144 "smt_lex.mll"
         ( Buffer.add_char buf c; string buf lexbuf )
# 616 "smt_lex.ml"

  | 4 ->
# 145 "smt_lex.mll"
         ( raise (Lexical_error ("unterminated string")) )
# 621 "smt_lex.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_string_rec buf lexbuf __ocaml_lex_state

;;

end
include (IMPLEMENTATION : INTERFACE)
end
and Smt_to_why: sig
#0 "smt_to_why.mli"
val dpos : Lexing.position
val dloc : Lexing.position * Lexing.position
exception Not_Implemented
val sort_to_type : Why_ptree.loc -> string -> Why_ptree.ppure_type
val curry_sort_to_type : Why_ptree.loc * string -> Why_ptree.ppure_type
val pexp : Why_ptree.loc -> Why_ptree.pp_desc -> Why_ptree.lexpr
val mlexpr : Why_ptree.pp_desc -> Why_ptree.lexpr
val make_forall : Why_ptree.lexpr -> Smt_ast.binder list -> Why_ptree.pp_desc
val make_exists : Why_ptree.lexpr -> Smt_ast.binder list -> Why_ptree.pp_desc
val make_infix :
  Why_ptree.pp_infix -> Why_ptree.lexpr list -> Why_ptree.pp_desc
val make_distinct_aux :
  Why_ptree.lexpr -> Why_ptree.lexpr list -> Why_ptree.pp_desc list
val make_distinct : Why_ptree.lexpr list -> Why_ptree.lexpr list
val wequal : Why_ptree.lexpr -> Why_ptree.lexpr -> Why_ptree.pp_desc
val make_equal : Why_ptree.lexpr list -> Why_ptree.pp_desc
val infix : string -> Why_ptree.pp_infix
val product :
  ('a -> 'b -> 'c) ->
  (Why_ptree.lexpr option * 'a) list ->
  (Why_ptree.lexpr option * 'b) list -> (Why_ptree.lexpr option * 'c) list
val term_to_formula :
  ('a -> Why_ptree.pp_desc) ->
  (Why_ptree.lexpr option * 'a) list -> Why_ptree.pp_desc
val apply_list_product :
  ('a list -> Why_ptree.pp_desc) ->
  (Why_ptree.lexpr option * 'a) list list -> Why_ptree.pp_desc
val concat_product :
  ('a -> 'b) -> ('b * 'c) list -> ('a * 'c) list -> ('b * 'c) list
module StringMap :
  sig
    type key = String.t
    type 'a t = 'a Map.Make(String).t
    val empty : 'a t
    val is_empty : 'a t -> bool
    val mem : key -> 'a t -> bool
    val add : key -> 'a -> 'a t -> 'a t
    val singleton : key -> 'a -> 'a t
    val remove : key -> 'a t -> 'a t
    val merge :
      (key -> 'a option -> 'b option -> 'c option) -> 'a t -> 'b t -> 'c t
    val compare : ('a -> 'a -> int) -> 'a t -> 'a t -> int
    val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
    val iter : (key -> 'a -> unit) -> 'a t -> unit
    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
    val for_all : (key -> 'a -> bool) -> 'a t -> bool
    val exists : (key -> 'a -> bool) -> 'a t -> bool
    val filter : (key -> 'a -> bool) -> 'a t -> 'a t
    val partition : (key -> 'a -> bool) -> 'a t -> 'a t * 'a t
    val cardinal : 'a t -> int
    val bindings : 'a t -> (key * 'a) list
    val min_binding : 'a t -> key * 'a
    val max_binding : 'a t -> key * 'a
    val choose : 'a t -> key * 'a
    val split : key -> 'a t -> 'a t * 'a option * 'a t
    val find : key -> 'a t -> 'a
    val map : ('a -> 'b) -> 'a t -> 'b t
    val mapi : (key -> 'a -> 'b) -> 'a t -> 'b t
  end
type env_unfold = {
  uterm : (Why_ptree.lexpr option * Why_ptree.pp_desc) list StringMap.t;
  uformula : Why_ptree.pp_desc StringMap.t;
}
val term_to_desc :
  env_unfold ->
  Smt_ast.term_node -> (Why_ptree.lexpr option * Why_ptree.pp_desc) list
val term :
  env_unfold ->
  Smt_ast.term -> (Why_ptree.lexpr option * Why_ptree.lexpr) list
val form_to_desc : env_unfold -> Smt_ast.form_node -> Why_ptree.pp_desc
val envformula : env_unfold -> Smt_ast.formula -> Why_ptree.lexpr
val formula : Smt_ast.formula -> Why_ptree.lexpr
val psig_to_pdef : Why_ptree.loc * Smt_ast.pred_sig -> Why_ptree.decl
val fsig_to_fdef : Why_ptree.loc * Smt_ast.fun_sig -> Why_ptree.decl
val sortdecl_to_type : Why_ptree.loc * string -> Why_ptree.decl
val bench_to_why : Smt_ast.pbench_attrib -> Why_ptree.decl list
end = struct
let _ = Printf.fprintf stderr "Executing smt_to_why.ml\n%!"module type INTERFACE = sig
#0 "smt_to_why.mli"
val dpos : Lexing.position
val dloc : Lexing.position * Lexing.position
exception Not_Implemented
val sort_to_type : Why_ptree.loc -> string -> Why_ptree.ppure_type
val curry_sort_to_type : Why_ptree.loc * string -> Why_ptree.ppure_type
val pexp : Why_ptree.loc -> Why_ptree.pp_desc -> Why_ptree.lexpr
val mlexpr : Why_ptree.pp_desc -> Why_ptree.lexpr
val make_forall : Why_ptree.lexpr -> Smt_ast.binder list -> Why_ptree.pp_desc
val make_exists : Why_ptree.lexpr -> Smt_ast.binder list -> Why_ptree.pp_desc
val make_infix :
  Why_ptree.pp_infix -> Why_ptree.lexpr list -> Why_ptree.pp_desc
val make_distinct_aux :
  Why_ptree.lexpr -> Why_ptree.lexpr list -> Why_ptree.pp_desc list
val make_distinct : Why_ptree.lexpr list -> Why_ptree.lexpr list
val wequal : Why_ptree.lexpr -> Why_ptree.lexpr -> Why_ptree.pp_desc
val make_equal : Why_ptree.lexpr list -> Why_ptree.pp_desc
val infix : string -> Why_ptree.pp_infix
val product :
  ('a -> 'b -> 'c) ->
  (Why_ptree.lexpr option * 'a) list ->
  (Why_ptree.lexpr option * 'b) list -> (Why_ptree.lexpr option * 'c) list
val term_to_formula :
  ('a -> Why_ptree.pp_desc) ->
  (Why_ptree.lexpr option * 'a) list -> Why_ptree.pp_desc
val apply_list_product :
  ('a list -> Why_ptree.pp_desc) ->
  (Why_ptree.lexpr option * 'a) list list -> Why_ptree.pp_desc
val concat_product :
  ('a -> 'b) -> ('b * 'c) list -> ('a * 'c) list -> ('b * 'c) list
module StringMap :
  sig
    type key = String.t
    type 'a t = 'a Map.Make(String).t
    val empty : 'a t
    val is_empty : 'a t -> bool
    val mem : key -> 'a t -> bool
    val add : key -> 'a -> 'a t -> 'a t
    val singleton : key -> 'a -> 'a t
    val remove : key -> 'a t -> 'a t
    val merge :
      (key -> 'a option -> 'b option -> 'c option) -> 'a t -> 'b t -> 'c t
    val compare : ('a -> 'a -> int) -> 'a t -> 'a t -> int
    val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
    val iter : (key -> 'a -> unit) -> 'a t -> unit
    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
    val for_all : (key -> 'a -> bool) -> 'a t -> bool
    val exists : (key -> 'a -> bool) -> 'a t -> bool
    val filter : (key -> 'a -> bool) -> 'a t -> 'a t
    val partition : (key -> 'a -> bool) -> 'a t -> 'a t * 'a t
    val cardinal : 'a t -> int
    val bindings : 'a t -> (key * 'a) list
    val min_binding : 'a t -> key * 'a
    val max_binding : 'a t -> key * 'a
    val choose : 'a t -> key * 'a
    val split : key -> 'a t -> 'a t * 'a option * 'a t
    val find : key -> 'a t -> 'a
    val map : ('a -> 'b) -> 'a t -> 'b t
    val mapi : (key -> 'a -> 'b) -> 'a t -> 'b t
  end
type env_unfold = {
  uterm : (Why_ptree.lexpr option * Why_ptree.pp_desc) list StringMap.t;
  uformula : Why_ptree.pp_desc StringMap.t;
}
val term_to_desc :
  env_unfold ->
  Smt_ast.term_node -> (Why_ptree.lexpr option * Why_ptree.pp_desc) list
val term :
  env_unfold ->
  Smt_ast.term -> (Why_ptree.lexpr option * Why_ptree.lexpr) list
val form_to_desc : env_unfold -> Smt_ast.form_node -> Why_ptree.pp_desc
val envformula : env_unfold -> Smt_ast.formula -> Why_ptree.lexpr
val formula : Smt_ast.formula -> Why_ptree.lexpr
val psig_to_pdef : Why_ptree.loc * Smt_ast.pred_sig -> Why_ptree.decl
val fsig_to_fdef : Why_ptree.loc * Smt_ast.fun_sig -> Why_ptree.decl
val sortdecl_to_type : Why_ptree.loc * string -> Why_ptree.decl
val bench_to_why : Smt_ast.pbench_attrib -> Why_ptree.decl list
end
module IMPLEMENTATION = struct
#0 "smt_to_why.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Smt_ast
open Why_ptree
open Lexing

let dpos = {pos_fname="";pos_lnum=0;pos_bol=0;pos_cnum=0}
let dloc = dpos, dpos

exception Not_Implemented

let sort_to_type pos = function
  | "Int" -> PPTint
  | "Real" -> PPTreal
  | "Array" -> PPTexternal([PPTint;PPTint],"Array_poly",pos)
  | "Array1" -> PPTexternal([PPTint;PPTreal],"Array_poly",pos)
  | "Array2" -> 
      PPTexternal([PPTint;PPTexternal([PPTint;PPTreal],"Array_poly",pos)],
		  "Array_poly",pos)
  | s -> PPTexternal ([], s, pos)
  
let curry_sort_to_type (pos,sort) =
  sort_to_type pos sort

let pexp pos f = {pp_loc = pos; pp_desc = f}
let mlexpr f = pexp dloc f

let make_forall f bl  =
  let f = List.fold_left
           (fun f x -> pexp f.pp_loc
                        (PPforall ([x.var], 
                         sort_to_type f.pp_loc x.sort, [], f ))) f bl
  in f.pp_desc

let make_exists f bl =
  let f = 
    List.fold_left 
      (fun f x -> pexp f.pp_loc 
        (PPexists ([x.var], sort_to_type f.pp_loc x.sort, f))) f bl
  in f.pp_desc

let make_infix op = function
  | x::l -> let f = List.fold_left 
                     (fun f x -> pexp x.pp_loc (PPinfix (f,op,x)))
                     x l
            in
              f.pp_desc
  | _ -> assert false

let make_distinct_aux elem l =
  List.map ( fun x -> PPinfix (elem, PPneq, x)) l

let make_distinct l =
  let rec aux = function
    | [] -> []
    | (x::xs) -> 
        List.rev_append (make_distinct_aux x xs) (aux xs)
  in
    List.map mlexpr (aux l)

let wequal x y = PPinfix (x, PPeq, y)

let rec make_equal = function
  | [] -> PPconst ConstTrue
  | [x] -> PPconst ConstTrue
  | [x;y] -> wequal x y
  | (x::y::z::xs) -> 
      PPinfix (mlexpr (wequal x y),
               PPand,
               mlexpr (make_equal (y::z::xs)))

let infix = function
  | "<" -> PPlt
  | "<=" -> PPle
  | ">" -> PPgt
  | ">=" -> PPge
  | "+" -> PPadd
  | "-" -> PPsub
  | "*" -> PPmul
  | "/" | "int___div" -> PPdiv
  | "int___mod" -> PPmod
  | _ -> assert false

let product f_map l1 l2 = 
  List.fold_left 
    (fun res (f1,t1) -> 
       List.fold_left 
	 (fun res (f2,t2) -> 
	    let f = match f1, f2 with
	      | None, None -> None
	      | (None, (Some _ as f)) | (Some _ as f, None) -> f
              | Some f1, Some f2 -> 
		  Some (pexp f2.pp_loc (PPinfix (f1,PPand,f2))) in
            (f,f_map t1 t2)::res) 
         res l2) [] l1

let term_to_formula f1 = 
  function 
    | [None,t] -> f1 t
    | l -> 
	make_infix PPand 
	  (List.map (function (Some f,x) ->
		       mlexpr (PPinfix (f,PPimplies,mlexpr (f1 x))) 
                     | _ -> assert false) l)

(* !inverse l1! *)
let apply_list_product f1 l1 = 
  term_to_formula f1 (List.fold_left (product (fun l x -> x::l)) [None,[]] l1)

let concat_product f1 = List.fold_left (fun env (f,t) -> (f1 f,t)::env)

module StringMap = Map.Make(String)

type env_unfold = {
  uterm : ((Why_ptree.lexpr option * Why_ptree.pp_desc) list) StringMap.t ; 
  uformula : Why_ptree.pp_desc StringMap.t
}

let rec term_to_desc env = function
  | Num str -> [None,PPconst (ConstInt str)]
  | Rat str -> assert false (*[None,PPconst (ConstReal str)]*)
  | Var str ->  (try StringMap.find str env.uterm
                with Not_found -> [None,PPvar str])
  | Fun ("+" | "-" | "*" | "/" | "int___mod" | "int___div" as s, [a;b]) -> 
      let ta = term env a and tb = term env b in
      (*PPinfix (ta, infix s, tb)*)
      product (fun x y -> PPinfix (x, infix s, y)) ta tb
        (* Le - est pour AUFLIRA *)
  | Fun (("-"|"~"), [a]) -> 
      List.map (fun (f,x) -> f,PPprefix(PPneg, x)) (term env a)
  | Fun (str,tlist) ->  
      List.map (fun (f,l) -> (f,PPapp (str,l )))
	(List.fold_left 
	   (product (fun l x -> x::l)) 
	   [None,[]]  (List.rev_map (term env) tlist))
	
  | Ite (f,t1,t2) ->  
      let ff = envformula env f in 
      let not_ff = 
	{ff with pp_desc = PPprefix (PPnot,pexp ff.pp_loc ff.pp_desc)} in
      let aux ff2 = function 
	  None -> Some ff2
        | Some f -> 
	    Some (pexp ff.pp_loc 
		    (PPinfix (ff2,PPand,pexp ff2.pp_loc f.pp_desc))) 
      in
      concat_product (aux ff) 
	(concat_product (aux not_ff) [] 
	   (term_to_desc env t2.term)) (term_to_desc env t1.term)

and term env a = 
  List.map (fun (f,t) -> (f,pexp a.tloc t)) (term_to_desc env a.term)

and form_to_desc env = function
    (* Pour l'instant on unfold *)
  | Flet (ident,f1,f2) -> (*raise Not_Implemented*)
      form_to_desc 
	{env with
	   uformula = 
	    StringMap.add ident 
	      (form_to_desc env f1.formula) env.uformula} f2.formula
      (*incorrect*)

  | Let (ident,t,f) -> 
(*      let f' = envformula env f in
      term_to_formula (fun x -> PPlet (ident,x,f')) (term env t)
*)

  (*Pforall ([ident],PPTvarid(ident,f1.floc),[],mlexpr (PPinfix(mlexpr
    (apply_list_product make_equal [(term env t);[None,mlexpr (PPvar
    ident)]]),PPimplies,envformula env f1)))*)
  form_to_desc {env with uterm = StringMap.add ident (term_to_desc
    env t.term) env.uterm} f.formula

  | Forall (binders,f1) -> 
      make_forall (envformula env f1) binders 
  | Exists (binders,f1) -> 
      make_exists (envformula env f1) binders
  | And l -> 
      make_infix PPand (List.map (envformula env) l)
  | Or l -> 
      make_infix PPor (List.map (envformula env) l)
  | Not f -> 
      PPprefix (PPnot, envformula env f)
  | Implies (f1,f2) -> 
      make_infix PPimplies (List.map (envformula env) [f1;f2])
  | Xor l -> 
      raise Not_Implemented
  | Iff l -> 
      make_infix PPiff (List.map (envformula env) l )
  | Fite (f,f_if,f_else) -> 
      PPif (envformula env f,envformula env f_if,envformula env f_else)

  | True -> PPconst ConstTrue
  | False -> PPconst ConstFalse

  | Fvar str -> 
      (try StringMap.find str env.uformula with Not_found -> PPvar str)
	
  | Distinct l -> 
      apply_list_product 
	(fun x -> (make_infix PPand (make_distinct x))) 
	(List.rev_map (term env) l)
	
  | Equals l -> apply_list_product make_equal (List.rev_map (term env) l)
  | Pred (("<" | "<=" | ">" | ">=" as s), [a; b]) -> 
      apply_list_product 
	(function [x;y] -> PPinfix (x,infix s,y) |_-> assert false) 
	(List.rev_map (term env) [a;b])

  | Pred (str,tlist) -> 
      apply_list_product 
	(fun x -> PPapp (str, x)) (List.rev_map (term env) tlist)

and envformula env f = pexp f.floc (form_to_desc env f.formula)

let formula  = envformula {uterm = StringMap.empty ; uformula = StringMap.empty}

let psig_to_pdef (pos,psig) =
  Logic (pos, Symbols.Other, [psig.pname],
	 PPredicate (List.map curry_sort_to_type psig.pargs))

let fsig_to_fdef (pos,fsig) =
  Logic (pos, Symbols.Other, [fsig.fname],
	 PFunction ((List.map curry_sort_to_type fsig.fargs),
                    curry_sort_to_type fsig.fres ))

let sortdecl_to_type (pos,s) =
  TypeDecl (pos,[], s, [])
    

let bench_to_why = function
  | Pblogic _ -> [] (* this seems to be comments only, throw away *)
  | Pbstatus s -> []
  | Pbextr_preds plist -> 
      List.map psig_to_pdef plist
  | Pbextr_funs flist -> 
      List.map fsig_to_fdef flist
  | Pbextr_sorts sorts -> 
      List.map sortdecl_to_type sorts
  | Pbformula (pos,f) -> 
      [Goal (pos, "", formula f)]
  | Pbassumption (pos,f) -> 
      [Axiom (pos, "", formula f)]
  | Pbrewriting (pos, lf) -> 
      [Rewriting (pos, "", List.map formula lf)]
  | Pannotation  -> []

end
include (IMPLEMENTATION : INTERFACE)
end
and Smtlib2_util: sig
#0 "smtlib2_util.mli"
type extradata = unit
val initial_data : unit -> unit
val file : string ref
val line : int ref
type pos = int
val string_of_pos : int -> string
val cur_pd : unit -> int * unit
type pd = pos * extradata
end = struct
let _ = Printf.fprintf stderr "Executing smtlib2_util.ml\n%!"module type INTERFACE = sig
#0 "smtlib2_util.mli"
type extradata = unit
val initial_data : unit -> unit
val file : string ref
val line : int ref
type pos = int
val string_of_pos : int -> string
val cur_pd : unit -> int * unit
type pd = pos * extradata
end
module IMPLEMENTATION = struct
#0 "smtlib2_util.ml"
(* auto-generated by gt *)

(* no extra data from grammar file. *)
type extradata = unit;;
let initial_data() = ();;

let file = ref "stdin";;
let line = ref 1;;
type pos = int;;
let string_of_pos p = "line "^(string_of_int p);;
let cur_pd() = (!line, initial_data());;   (* "pd": pos + extradata *) 
type pd = pos * extradata;;
end
include (IMPLEMENTATION : INTERFACE)
end
and Smtlib2_ast: sig
#0 "smtlib2_ast.mli"
type loc = Lexing.position * Lexing.position
type specconstant =
    SpecConstsDec of loc * string
  | SpecConstNum of loc * string
  | SpecConstString of loc * string
  | SpecConstsHex of loc * string
  | SpecConstsBinary of loc * string
type symbol = Symbol of loc * string | SymbolWithOr of loc * string
type sexpr =
    SexprSpecConst of loc * specconstant
  | SexprSymbol of loc * symbol
  | SexprKeyword of loc * string
  | SexprInParen of loc * (loc * sexpr list)
type attributevalue =
    AttributeValSpecConst of loc * specconstant
  | AttributeValSymbol of loc * symbol
  | AttributeValSexpr of loc * (loc * sexpr list)
type attribute =
    AttributeKeyword of loc * string
  | AttributeKeywordValue of loc * string * attributevalue
type an_option = AnOptionAttribute of loc * attribute
type infoflag = InfoFlagKeyword of loc * string
type identifier =
    IdSymbol of loc * symbol
  | IdUnderscoreSymNum of loc * symbol * (loc * string list)
type sort =
    SortIdentifier of loc * identifier
  | SortIdSortMulti of loc * identifier * (loc * sort list)
type qualidentifier =
    QualIdentifierId of loc * identifier
  | QualIdentifierAs of loc * identifier * sort
type sortedvar = SortedVarSymSort of loc * symbol * sort
type varbinding = VarBindingSymTerm of loc * symbol * term
and term =
    TermSpecConst of loc * specconstant
  | TermQualIdentifier of loc * qualidentifier
  | TermQualIdTerm of loc * qualidentifier * (loc * term list)
  | TermLetTerm of loc * (loc * varbinding list) * term
  | TermForAllTerm of loc * (loc * sortedvar list) * term
  | TermExistsTerm of loc * (loc * sortedvar list) * term
  | TermExclimationPt of loc * term * (loc * attribute list)
type command =
    CSetLogic of loc * symbol
  | CSetOption of loc * an_option
  | CSetInfo of loc * attribute
  | CDeclareSort of loc * symbol * string
  | CDefineSort of loc * symbol * (loc * symbol list) * sort
  | CDeclareFun of loc * symbol * (loc * sort list) * sort
  | CDefineFun of loc * symbol * (loc * sortedvar list) * sort * term
  | CPush of loc * string
  | CPop of loc * string
  | CAssert of loc * term
  | CCheckSat of loc
  | CGetAssert of loc
  | CGetProof of loc
  | CGetUnsatCore of loc
  | CGetValue of loc * (loc * term list)
  | CGetAssign of loc
  | CGetOption of loc * string
  | CGetInfo of loc * infoflag
  | CExit of loc
type commands = Commands of loc * (loc * command list)
val loc_an_option : an_option -> loc
val loc_attribute : attribute -> loc
val loc_attributevalue : attributevalue -> loc
val loc_command : command -> loc
val loc_commands : commands -> loc
val loc_identifier : identifier -> loc
val loc_infoflag : infoflag -> loc
val loc_qualidentifier : qualidentifier -> loc
val loc_sexpr : sexpr -> loc
val loc_sort : sort -> loc
val loc_sortedvar : sortedvar -> loc
val loc_specconstant : specconstant -> loc
val loc_symbol : symbol -> loc
val loc_term : term -> loc
val loc_varbinding : varbinding -> loc
val loc_couple : 'a * 'b -> 'a
val loc_of : commands -> loc
end = struct
let _ = Printf.fprintf stderr "Executing smtlib2_ast.ml\n%!"module type INTERFACE = sig
#0 "smtlib2_ast.mli"
type loc = Lexing.position * Lexing.position
type specconstant =
    SpecConstsDec of loc * string
  | SpecConstNum of loc * string
  | SpecConstString of loc * string
  | SpecConstsHex of loc * string
  | SpecConstsBinary of loc * string
type symbol = Symbol of loc * string | SymbolWithOr of loc * string
type sexpr =
    SexprSpecConst of loc * specconstant
  | SexprSymbol of loc * symbol
  | SexprKeyword of loc * string
  | SexprInParen of loc * (loc * sexpr list)
type attributevalue =
    AttributeValSpecConst of loc * specconstant
  | AttributeValSymbol of loc * symbol
  | AttributeValSexpr of loc * (loc * sexpr list)
type attribute =
    AttributeKeyword of loc * string
  | AttributeKeywordValue of loc * string * attributevalue
type an_option = AnOptionAttribute of loc * attribute
type infoflag = InfoFlagKeyword of loc * string
type identifier =
    IdSymbol of loc * symbol
  | IdUnderscoreSymNum of loc * symbol * (loc * string list)
type sort =
    SortIdentifier of loc * identifier
  | SortIdSortMulti of loc * identifier * (loc * sort list)
type qualidentifier =
    QualIdentifierId of loc * identifier
  | QualIdentifierAs of loc * identifier * sort
type sortedvar = SortedVarSymSort of loc * symbol * sort
type varbinding = VarBindingSymTerm of loc * symbol * term
and term =
    TermSpecConst of loc * specconstant
  | TermQualIdentifier of loc * qualidentifier
  | TermQualIdTerm of loc * qualidentifier * (loc * term list)
  | TermLetTerm of loc * (loc * varbinding list) * term
  | TermForAllTerm of loc * (loc * sortedvar list) * term
  | TermExistsTerm of loc * (loc * sortedvar list) * term
  | TermExclimationPt of loc * term * (loc * attribute list)
type command =
    CSetLogic of loc * symbol
  | CSetOption of loc * an_option
  | CSetInfo of loc * attribute
  | CDeclareSort of loc * symbol * string
  | CDefineSort of loc * symbol * (loc * symbol list) * sort
  | CDeclareFun of loc * symbol * (loc * sort list) * sort
  | CDefineFun of loc * symbol * (loc * sortedvar list) * sort * term
  | CPush of loc * string
  | CPop of loc * string
  | CAssert of loc * term
  | CCheckSat of loc
  | CGetAssert of loc
  | CGetProof of loc
  | CGetUnsatCore of loc
  | CGetValue of loc * (loc * term list)
  | CGetAssign of loc
  | CGetOption of loc * string
  | CGetInfo of loc * infoflag
  | CExit of loc
type commands = Commands of loc * (loc * command list)
val loc_an_option : an_option -> loc
val loc_attribute : attribute -> loc
val loc_attributevalue : attributevalue -> loc
val loc_command : command -> loc
val loc_commands : commands -> loc
val loc_identifier : identifier -> loc
val loc_infoflag : infoflag -> loc
val loc_qualidentifier : qualidentifier -> loc
val loc_sexpr : sexpr -> loc
val loc_sort : sort -> loc
val loc_sortedvar : sortedvar -> loc
val loc_specconstant : specconstant -> loc
val loc_symbol : symbol -> loc
val loc_term : term -> loc
val loc_varbinding : varbinding -> loc
val loc_couple : 'a * 'b -> 'a
val loc_of : commands -> loc
end
module IMPLEMENTATION = struct
#0 "smtlib2_ast.ml"
open Smtlib2_util

type loc = Lexing.position * Lexing.position

type specconstant = 
  | SpecConstsDec of loc * string 
  | SpecConstNum of loc * string
  | SpecConstString of loc * string
  | SpecConstsHex of loc * string
  | SpecConstsBinary of loc * string

type symbol = 
  | Symbol of loc * string 
  | SymbolWithOr of loc * string

type sexpr = 
  | SexprSpecConst of loc * specconstant 
  | SexprSymbol of loc * symbol 
  | SexprKeyword of loc * string 
  | SexprInParen of loc * (loc * sexpr list)

type attributevalue = 
  | AttributeValSpecConst of loc * specconstant 
  | AttributeValSymbol of loc * symbol 
  | AttributeValSexpr of loc * (loc * sexpr list)

type attribute = 
  | AttributeKeyword of loc * string 
  | AttributeKeywordValue of loc * string * attributevalue

type an_option = AnOptionAttribute of loc * attribute

type infoflag = InfoFlagKeyword of loc * string

type identifier = 
  | IdSymbol of loc * symbol
  | IdUnderscoreSymNum of loc * symbol * (loc * string list)

type sort = 
  | SortIdentifier of loc * identifier 
  | SortIdSortMulti of loc * identifier * (loc * sort list)

type qualidentifier = 
  | QualIdentifierId of loc * identifier 
  | QualIdentifierAs of loc * identifier * sort

type sortedvar = 
  | SortedVarSymSort of loc * symbol * sort

type varbinding = VarBindingSymTerm of loc * symbol * term

and term = 
  | TermSpecConst of loc * specconstant
  | TermQualIdentifier of loc * qualidentifier
  | TermQualIdTerm of loc * qualidentifier * (loc * term list)
  | TermLetTerm of loc * (loc * varbinding list) * term
  | TermForAllTerm of loc * (loc * sortedvar list) * term
  | TermExistsTerm of loc * (loc * sortedvar list) * term
  | TermExclimationPt of loc * term * (loc * attribute list)

type command = 
  | CSetLogic of loc * symbol 
  | CSetOption of loc * an_option 
  | CSetInfo of loc * attribute 
  | CDeclareSort of loc * symbol * string 
  | CDefineSort of loc * symbol * (loc * symbol list) * sort
  | CDeclareFun of loc * symbol * (loc * sort list) * sort 
  | CDefineFun of loc * symbol * (loc * sortedvar list) * sort * term 
  | CPush of loc * string 
  | CPop of loc * string 
  | CAssert of loc * term 
  | CCheckSat of loc 
  | CGetAssert of loc 
  | CGetProof of loc 
  | CGetUnsatCore of loc 
  | CGetValue of loc * (loc * term list)
  | CGetAssign of loc
  | CGetOption of loc * string
  | CGetInfo of loc * infoflag 
  | CExit of loc

type commands = Commands of loc * (loc * command list)


(* loc stands for pos (position) and extradata *)

let loc_an_option = function 
  | AnOptionAttribute(d,_) -> d

let loc_attribute = function 
  | AttributeKeyword(d,_) -> d
  | AttributeKeywordValue(d,_,_) -> d

let loc_attributevalue = function 
  | AttributeValSpecConst(d,_) -> d
  | AttributeValSymbol(d,_) -> d
  | AttributeValSexpr(d,_) -> d

let loc_command = function 
  | CSetLogic(d,_) -> d
  | CSetOption(d,_) -> d
  | CSetInfo(d,_) -> d
  | CDeclareSort(d,_,_) -> d
  | CDefineSort(d,_,_,_) -> d
  | CDeclareFun(d,_,_,_) -> d
  | CDefineFun(d,_,_,_,_) -> d
  | CPush(d,_) -> d
  | CPop(d,_) -> d
  | CAssert(d,_) -> d
  | CCheckSat(d) -> d
  | CGetAssert(d) -> d
  | CGetProof(d) -> d
  | CGetUnsatCore(d) -> d
  | CGetValue(d,_) -> d
  | CGetAssign(d) -> d
  | CGetOption(d,_) -> d
  | CGetInfo(d,_) -> d
  | CExit(d) -> d

let loc_commands = function 
  | Commands(d,_) -> d

let loc_identifier = function 
  | IdSymbol(d,_) -> d
  | IdUnderscoreSymNum(d,_,_) -> d

let loc_infoflag = function 
  | InfoFlagKeyword(d,_) -> d

let loc_qualidentifier = function 
  | QualIdentifierId(d,_) -> d
  | QualIdentifierAs(d,_,_) -> d

let loc_sexpr = function 
  | SexprSpecConst(d,_) -> d
  | SexprSymbol(d,_) -> d
  | SexprKeyword(d,_) -> d
  | SexprInParen(d,_) -> d

let loc_sort = function 
  | SortIdentifier(d,_) -> d
  | SortIdSortMulti(d,_,_) -> d

let loc_sortedvar = function 
  | SortedVarSymSort(d,_,_) -> d

let loc_specconstant = function 
  | SpecConstsDec(d,_) -> d
  | SpecConstNum(d,_) -> d
  | SpecConstString(d,_) -> d
  | SpecConstsHex(d,_) -> d
  | SpecConstsBinary(d,_) -> d

let loc_symbol = function 
  | Symbol(d,_) -> d
  | SymbolWithOr(d,_) -> d

let loc_term = function 
  | TermSpecConst(d,_) -> d
  | TermQualIdentifier(d,_) -> d
  | TermQualIdTerm(d,_,_) -> d
  | TermLetTerm(d,_,_) -> d
  | TermForAllTerm(d,_,_) -> d
  | TermExistsTerm(d,_,_) -> d
  | TermExclimationPt(d,_,_) -> d

let loc_varbinding = function 
  | VarBindingSymTerm(d,_,_) -> d

let loc_couple = fst

let loc_of e = loc_commands e;;
end
include (IMPLEMENTATION : INTERFACE)
end
and Smtlib2_parse: sig
#0 "smtlib2_parse.mli"
type token =
  | EXCLIMATIONPT
  | UNDERSCORE
  | AS
  | EXISTS
  | FORALL
  | LET
  | SETLOGIC
  | SETOPTION
  | SETINFO
  | DECLARESORT
  | DEFINESORT
  | DECLAREFUN
  | DEFINEFUN
  | PUSH
  | POP
  | ASSERT
  | CHECKSAT
  | GETASSERT
  | GETPROOF
  | GETUNSATCORE
  | GETVALUE
  | GETASSIGN
  | GETOPTION
  | GETINFO
  | EXIT
  | LPAREN
  | RPAREN
  | EOF
  | NUMERAL of (string)
  | DECIMAL of (string)
  | HEXADECIMAL of (string)
  | BINARY of (string)
  | STRINGLIT of (string)
  | ASCIIWOR of (string)
  | KEYWORD of (string)
  | SYMBOL of (string)

val main :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Smtlib2_ast.commands option
end = struct
let _ = Printf.fprintf stderr "Executing smtlib2_parse.ml\n%!"module type INTERFACE = sig
#0 "smtlib2_parse.mli"
type token =
  | EXCLIMATIONPT
  | UNDERSCORE
  | AS
  | EXISTS
  | FORALL
  | LET
  | SETLOGIC
  | SETOPTION
  | SETINFO
  | DECLARESORT
  | DEFINESORT
  | DECLAREFUN
  | DEFINEFUN
  | PUSH
  | POP
  | ASSERT
  | CHECKSAT
  | GETASSERT
  | GETPROOF
  | GETUNSATCORE
  | GETVALUE
  | GETASSIGN
  | GETOPTION
  | GETINFO
  | EXIT
  | LPAREN
  | RPAREN
  | EOF
  | NUMERAL of (string)
  | DECIMAL of (string)
  | HEXADECIMAL of (string)
  | BINARY of (string)
  | STRINGLIT of (string)
  | ASCIIWOR of (string)
  | KEYWORD of (string)
  | SYMBOL of (string)

val main :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Smtlib2_ast.commands option
end
module IMPLEMENTATION = struct
#0 "smtlib2_parse.ml"
type token =
  | EXCLIMATIONPT
  | UNDERSCORE
  | AS
  | EXISTS
  | FORALL
  | LET
  | SETLOGIC
  | SETOPTION
  | SETINFO
  | DECLARESORT
  | DEFINESORT
  | DECLAREFUN
  | DEFINEFUN
  | PUSH
  | POP
  | ASSERT
  | CHECKSAT
  | GETASSERT
  | GETPROOF
  | GETUNSATCORE
  | GETVALUE
  | GETASSIGN
  | GETOPTION
  | GETINFO
  | EXIT
  | LPAREN
  | RPAREN
  | EOF
  | NUMERAL of (string)
  | DECIMAL of (string)
  | HEXADECIMAL of (string)
  | BINARY of (string)
  | STRINGLIT of (string)
  | ASCIIWOR of (string)
  | KEYWORD of (string)
  | SYMBOL of (string)

open Parsing;;
# 2 "smtlib2_parse.mly"

   open Smtlib2_ast

(* let parse_error s = *)
(*    print_string s; *)
(*   print_string " on line "; *)
(*   print_int !Smtlib_util.line; *)
(*   print_string "\n" *)


  let loc () = symbol_start_pos (), symbol_end_pos ()

# 54 "smtlib2_parse.ml"
let yytransl_const = [|
  257 (* EXCLIMATIONPT *);
  258 (* UNDERSCORE *);
  259 (* AS *);
  260 (* EXISTS *);
  261 (* FORALL *);
  262 (* LET *);
  263 (* SETLOGIC *);
  264 (* SETOPTION *);
  265 (* SETINFO *);
  266 (* DECLARESORT *);
  267 (* DEFINESORT *);
  268 (* DECLAREFUN *);
  269 (* DEFINEFUN *);
  270 (* PUSH *);
  271 (* POP *);
  272 (* ASSERT *);
  273 (* CHECKSAT *);
  274 (* GETASSERT *);
  275 (* GETPROOF *);
  276 (* GETUNSATCORE *);
  277 (* GETVALUE *);
  278 (* GETASSIGN *);
  279 (* GETOPTION *);
  280 (* GETINFO *);
  281 (* EXIT *);
  282 (* LPAREN *);
  283 (* RPAREN *);
    0 (* EOF *);
    0|]

let yytransl_block = [|
  284 (* NUMERAL *);
  285 (* DECIMAL *);
  286 (* HEXADECIMAL *);
  287 (* BINARY *);
  288 (* STRINGLIT *);
  289 (* ASCIIWOR *);
  290 (* KEYWORD *);
  291 (* SYMBOL *);
    0|]

let yylhs = "\255\255\
\001\000\001\000\002\000\003\000\003\000\017\000\017\000\004\000\
\004\000\004\000\018\000\018\000\019\000\019\000\020\000\020\000\
\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
\005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
\005\000\005\000\005\000\022\000\022\000\006\000\023\000\023\000\
\007\000\007\000\008\000\009\000\009\000\010\000\010\000\010\000\
\010\000\024\000\024\000\011\000\011\000\012\000\013\000\013\000\
\013\000\013\000\013\000\014\000\014\000\021\000\021\000\025\000\
\025\000\026\000\026\000\027\000\027\000\015\000\015\000\015\000\
\015\000\015\000\015\000\015\000\016\000\000\000"

let yylen = "\002\000\
\001\000\001\000\001\000\001\000\002\000\000\000\002\000\001\000\
\001\000\003\000\000\000\002\000\000\000\002\000\000\000\002\000\
\004\000\004\000\004\000\005\000\008\000\008\000\009\000\004\000\
\004\000\004\000\003\000\003\000\003\000\003\000\006\000\003\000\
\004\000\004\000\003\000\000\000\002\000\001\000\001\000\002\000\
\001\000\005\000\001\000\001\000\005\000\001\000\001\000\001\000\
\003\000\001\000\002\000\001\000\004\000\004\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\002\000\001\000\
\002\000\001\000\002\000\001\000\002\000\001\000\001\000\004\000\
\007\000\007\000\007\000\005\000\004\000\002\000"

let yydefred = "\000\000\
\000\000\000\000\000\000\002\000\078\000\000\000\001\000\038\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\037\000\061\000\060\000\000\000\000\000\
\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\056\000\055\000\058\000\059\000\057\000\044\000\
\071\000\070\000\041\000\000\000\027\000\028\000\029\000\030\000\
\000\000\032\000\000\000\043\000\000\000\035\000\017\000\000\000\
\005\000\008\000\009\000\018\000\019\000\000\000\000\000\000\000\
\000\000\024\000\025\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\026\000\000\000\000\000\033\000\034\000\
\000\000\048\000\000\000\046\000\047\000\000\000\020\000\000\000\
\000\000\000\000\052\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\063\000\000\000\000\000\007\000\010\000\012\000\000\000\000\000\
\014\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\072\000\031\000\049\000\000\000\000\000\000\000\000\000\000\000\
\000\000\069\000\076\000\040\000\042\000\045\000\067\000\000\000\
\000\000\000\000\065\000\000\000\021\000\051\000\053\000\022\000\
\054\000\000\000\000\000\000\000\000\000\000\000\023\000\075\000\
\074\000\077\000\073\000"

let yydgoto = "\002\000\
\005\000\033\000\126\000\065\000\006\000\007\000\048\000\061\000\
\049\000\091\000\100\000\131\000\050\000\051\000\085\000\135\000\
\094\000\097\000\101\000\104\000\086\000\008\000\129\000\142\000\
\136\000\132\000\127\000"

let yysindex = "\015\000\
\001\000\000\000\091\255\000\000\000\000\249\254\000\000\000\000\
\238\254\250\254\250\254\238\254\238\254\238\254\238\254\003\255\
\010\255\093\255\014\255\017\255\025\255\030\255\034\255\036\255\
\037\255\040\255\052\255\000\000\000\000\000\000\054\255\121\255\
\058\255\000\000\060\255\061\255\062\255\064\255\066\255\067\255\
\068\255\020\255\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\069\255\000\000\000\000\000\000\000\000\
\093\255\000\000\090\255\000\000\103\255\000\000\000\000\111\255\
\000\000\000\000\000\000\000\000\000\000\104\255\238\254\021\255\
\092\255\000\000\000\000\093\255\238\254\047\255\094\255\106\255\
\107\255\000\255\093\255\000\000\093\255\128\255\000\000\000\000\
\111\255\000\000\111\255\000\000\000\000\130\255\000\000\238\254\
\131\255\043\255\000\000\021\255\132\255\238\254\092\255\133\255\
\250\254\065\255\146\255\021\255\092\255\092\255\135\255\136\255\
\000\000\137\255\138\255\000\000\000\000\000\000\021\255\021\255\
\000\000\021\255\021\255\000\000\021\255\250\254\139\255\065\255\
\140\255\141\255\092\255\142\255\143\255\238\254\135\255\144\255\
\000\000\000\000\000\000\145\255\021\255\147\255\148\255\149\255\
\093\255\000\000\000\000\000\000\000\000\000\000\000\000\093\255\
\093\255\093\255\000\000\093\255\000\000\000\000\000\000\000\000\
\000\000\150\255\151\255\152\255\153\255\154\255\000\000\000\000\
\000\000\000\000\000\000"

let yyrindex = "\000\000\
\162\000\000\000\000\000\000\000\000\000\162\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\234\254\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\155\255\
\000\000\000\000\000\000\000\000\000\000\000\000\156\255\157\255\
\158\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\052\255\000\000\000\000\000\000\
\155\255\000\000\155\255\000\000\000\000\000\000\000\000\156\255\
\000\000\000\000\000\000\157\255\000\000\000\000\158\255\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\058\255\000\000\160\255\
\000\000\000\000\161\255\000\000\000\000\000\000\162\255\000\000\
\000\000\000\000\000\000\000\000\163\255\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000"

let yygindex = "\000\000\
\000\000\000\000\038\000\000\000\000\000\000\000\198\255\000\000\
\131\000\000\000\166\255\189\255\235\255\251\255\238\255\000\000\
\204\255\090\000\091\000\089\000\248\255\187\000\066\000\054\000\
\061\000\159\255\071\000"

let yytablesize = 283
let yytable = "\052\000\
\004\000\077\000\078\000\031\000\004\000\103\000\036\000\037\000\
\038\000\039\000\066\000\004\000\133\000\099\000\029\000\001\000\
\030\000\130\000\003\000\108\000\076\000\077\000\078\000\079\000\
\080\000\081\000\067\000\032\000\140\000\141\000\040\000\143\000\
\144\000\151\000\145\000\103\000\115\000\041\000\116\000\120\000\
\053\000\099\000\092\000\054\000\077\000\082\000\098\000\034\000\
\035\000\099\000\141\000\055\000\029\000\029\000\030\000\030\000\
\056\000\105\000\093\000\057\000\099\000\099\000\058\000\099\000\
\099\000\096\000\099\000\092\000\107\000\092\000\059\000\106\000\
\107\000\060\000\112\000\029\000\113\000\030\000\062\000\029\000\
\063\000\030\000\099\000\093\000\068\000\093\000\069\000\071\000\
\070\000\072\000\096\000\073\000\128\000\074\000\075\000\084\000\
\123\000\009\000\010\000\011\000\012\000\013\000\014\000\015\000\
\016\000\017\000\018\000\019\000\020\000\021\000\022\000\023\000\
\024\000\025\000\026\000\027\000\087\000\102\000\042\000\109\000\
\043\000\044\000\045\000\046\000\047\000\029\000\162\000\030\000\
\154\000\088\000\095\000\110\000\111\000\163\000\164\000\165\000\
\089\000\166\000\043\000\044\000\045\000\046\000\047\000\029\000\
\090\000\030\000\064\000\077\000\043\000\044\000\045\000\046\000\
\047\000\029\000\114\000\030\000\117\000\119\000\122\000\125\000\
\134\000\036\000\137\000\138\000\139\000\147\000\149\000\150\000\
\152\000\153\000\156\000\157\000\083\000\159\000\160\000\161\000\
\167\000\168\000\169\000\170\000\171\000\006\000\011\000\013\000\
\015\000\118\000\039\000\066\000\064\000\050\000\121\000\124\000\
\028\000\148\000\158\000\155\000\146\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\003\000"

let yycheck = "\018\000\
\000\000\002\001\003\001\009\000\027\001\073\000\012\000\013\000\
\014\000\015\000\032\000\034\001\110\000\072\000\033\001\001\000\
\035\001\108\000\026\001\078\000\001\001\002\001\003\001\004\001\
\005\001\006\001\032\000\034\001\119\000\120\000\028\001\122\000\
\123\000\131\000\125\000\103\000\089\000\028\001\091\000\098\000\
\027\001\100\000\064\000\027\001\002\001\026\001\026\001\010\000\
\011\000\108\000\141\000\027\001\033\001\033\001\035\001\035\001\
\027\001\076\000\064\000\026\001\119\000\120\000\027\001\122\000\
\123\000\071\000\125\000\089\000\026\001\091\000\034\001\077\000\
\026\001\034\001\083\000\033\001\085\000\035\001\027\001\033\001\
\027\001\035\001\141\000\089\000\027\001\091\000\027\001\026\001\
\028\001\026\001\096\000\026\001\028\001\027\001\027\001\027\001\
\102\000\007\001\008\001\009\001\010\001\011\001\012\001\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\022\001\023\001\024\001\025\001\027\001\026\001\026\001\026\001\
\028\001\029\001\030\001\031\001\032\001\033\001\145\000\035\001\
\134\000\027\001\027\001\026\001\026\001\152\000\153\000\154\000\
\026\001\156\000\028\001\029\001\030\001\031\001\032\001\033\001\
\034\001\035\001\026\001\002\001\028\001\029\001\030\001\031\001\
\032\001\033\001\027\001\035\001\027\001\027\001\027\001\027\001\
\026\001\000\000\027\001\027\001\027\001\027\001\027\001\027\001\
\027\001\027\001\027\001\027\001\042\000\027\001\027\001\027\001\
\027\001\027\001\027\001\027\001\027\001\027\001\027\001\027\001\
\027\001\096\000\027\001\027\001\027\001\027\001\100\000\103\000\
\006\000\128\000\141\000\135\000\126\000\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\026\001"

let yynames_const = "\
  EXCLIMATIONPT\000\
  UNDERSCORE\000\
  AS\000\
  EXISTS\000\
  FORALL\000\
  LET\000\
  SETLOGIC\000\
  SETOPTION\000\
  SETINFO\000\
  DECLARESORT\000\
  DEFINESORT\000\
  DECLAREFUN\000\
  DEFINEFUN\000\
  PUSH\000\
  POP\000\
  ASSERT\000\
  CHECKSAT\000\
  GETASSERT\000\
  GETPROOF\000\
  GETUNSATCORE\000\
  GETVALUE\000\
  GETASSIGN\000\
  GETOPTION\000\
  GETINFO\000\
  EXIT\000\
  LPAREN\000\
  RPAREN\000\
  EOF\000\
  "

let yynames_block = "\
  NUMERAL\000\
  DECIMAL\000\
  HEXADECIMAL\000\
  BINARY\000\
  STRINGLIT\000\
  ASCIIWOR\000\
  KEYWORD\000\
  SYMBOL\000\
  "

let yyact = [|
  (fun _ -> failwith "parser")
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.commands) in
    Obj.repr(
# 96 "smtlib2_parse.mly"
           ( Some(_1) )
# 331 "smtlib2_parse.ml"
               : Smtlib2_ast.commands option))
; (fun __caml_parser_env ->
    Obj.repr(
# 97 "smtlib2_parse.mly"
      ( None )
# 337 "smtlib2_parse.ml"
               : Smtlib2_ast.commands option))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.attribute) in
    Obj.repr(
# 101 "smtlib2_parse.mly"
            ( AnOptionAttribute(loc_attribute _1, _1) )
# 344 "smtlib2_parse.ml"
               : Smtlib2_ast.an_option))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 105 "smtlib2_parse.mly"
          ( AttributeKeyword(loc (), _1) )
# 351 "smtlib2_parse.ml"
               : Smtlib2_ast.attribute))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.attributevalue) in
    Obj.repr(
# 106 "smtlib2_parse.mly"
                         ( AttributeKeywordValue(loc (), _1, _2) )
# 359 "smtlib2_parse.ml"
               : Smtlib2_ast.attribute))
; (fun __caml_parser_env ->
    Obj.repr(
# 112 "smtlib2_parse.mly"
  ( (loc (), []) )
# 365 "smtlib2_parse.ml"
               : 'sexpr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.sexpr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'sexpr_list) in
    Obj.repr(
# 113 "smtlib2_parse.mly"
                   ( let (_, l1) = _2 in (loc_sexpr _1, (_1)::(l1)) )
# 373 "smtlib2_parse.ml"
               : 'sexpr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.specconstant) in
    Obj.repr(
# 117 "smtlib2_parse.mly"
               ( AttributeValSpecConst(loc_specconstant _1, _1) )
# 380 "smtlib2_parse.ml"
               : Smtlib2_ast.attributevalue))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.symbol) in
    Obj.repr(
# 118 "smtlib2_parse.mly"
         ( AttributeValSymbol(loc_symbol _1, _1) )
# 387 "smtlib2_parse.ml"
               : Smtlib2_ast.attributevalue))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'sexpr_list) in
    Obj.repr(
# 119 "smtlib2_parse.mly"
                           ( AttributeValSexpr(loc (), _2) )
# 394 "smtlib2_parse.ml"
               : Smtlib2_ast.attributevalue))
; (fun __caml_parser_env ->
    Obj.repr(
# 123 "smtlib2_parse.mly"
  ( (loc (), []) )
# 400 "smtlib2_parse.ml"
               : 'symbol_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.symbol) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'symbol_list) in
    Obj.repr(
# 124 "smtlib2_parse.mly"
                     ( let (_, l1) = _2 in (loc_symbol _1, (_1)::(l1)) )
# 408 "smtlib2_parse.ml"
               : 'symbol_list))
; (fun __caml_parser_env ->
    Obj.repr(
# 128 "smtlib2_parse.mly"
  ( (loc (), []) )
# 414 "smtlib2_parse.ml"
               : 'sort_list0))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.sort) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'sort_list0) in
    Obj.repr(
# 129 "smtlib2_parse.mly"
                  ( let (_, l1) = _2 in (loc_sort _1, (_1)::(l1)) )
# 422 "smtlib2_parse.ml"
               : 'sort_list0))
; (fun __caml_parser_env ->
    Obj.repr(
# 133 "smtlib2_parse.mly"
  ( (loc (), []) )
# 428 "smtlib2_parse.ml"
               : 'sortedvar_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.sortedvar) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'sortedvar_list) in
    Obj.repr(
# 135 "smtlib2_parse.mly"
    ( let (_, l1) = _2 in (loc_sortedvar _1, (_1)::(l1)) )
# 436 "smtlib2_parse.ml"
               : 'sortedvar_list))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.symbol) in
    Obj.repr(
# 140 "smtlib2_parse.mly"
    ( CSetLogic(loc (), _3) )
# 443 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.an_option) in
    Obj.repr(
# 142 "smtlib2_parse.mly"
    ( CSetOption(loc (), _3) )
# 450 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.attribute) in
    Obj.repr(
# 144 "smtlib2_parse.mly"
    ( CSetInfo(loc (), _3) )
# 457 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : Smtlib2_ast.symbol) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 146 "smtlib2_parse.mly"
    ( CDeclareSort(loc (), _3, _4) )
# 465 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 5 : Smtlib2_ast.symbol) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'symbol_list) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.sort) in
    Obj.repr(
# 148 "smtlib2_parse.mly"
    ( CDefineSort(loc (), _3, _5, _7) )
# 474 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 5 : Smtlib2_ast.symbol) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'sort_list0) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.sort) in
    Obj.repr(
# 150 "smtlib2_parse.mly"
    ( CDeclareFun(loc (), _3, _5, _7) )
# 483 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 6 : Smtlib2_ast.symbol) in
    let _5 = (Parsing.peek_val __caml_parser_env 4 : 'sortedvar_list) in
    let _7 = (Parsing.peek_val __caml_parser_env 2 : Smtlib2_ast.sort) in
    let _8 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.term) in
    Obj.repr(
# 152 "smtlib2_parse.mly"
    ( CDefineFun(loc (), _3, _5, _7, _8) )
# 493 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 154 "smtlib2_parse.mly"
    ( CPush(loc (), _3) )
# 500 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 156 "smtlib2_parse.mly"
    ( CPop(loc (), _3) )
# 507 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.term) in
    Obj.repr(
# 158 "smtlib2_parse.mly"
    ( CAssert(loc (), _3) )
# 514 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    Obj.repr(
# 160 "smtlib2_parse.mly"
    ( CCheckSat(loc ()) )
# 520 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    Obj.repr(
# 162 "smtlib2_parse.mly"
    ( CGetAssert(loc ()) )
# 526 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    Obj.repr(
# 164 "smtlib2_parse.mly"
    ( CGetProof(loc ()) )
# 532 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    Obj.repr(
# 166 "smtlib2_parse.mly"
    ( CGetUnsatCore(loc ()) )
# 538 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'term_list1) in
    Obj.repr(
# 168 "smtlib2_parse.mly"
    ( CGetValue(loc (), _4) )
# 545 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    Obj.repr(
# 170 "smtlib2_parse.mly"
    ( CGetAssign(loc ()) )
# 551 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 172 "smtlib2_parse.mly"
    ( CGetOption(loc (), _3) )
# 558 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.infoflag) in
    Obj.repr(
# 174 "smtlib2_parse.mly"
    ( CGetInfo(loc (), _3) )
# 565 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    Obj.repr(
# 176 "smtlib2_parse.mly"
    ( CExit(loc ()) )
# 571 "smtlib2_parse.ml"
               : Smtlib2_ast.command))
; (fun __caml_parser_env ->
    Obj.repr(
# 181 "smtlib2_parse.mly"
  ( (loc (), []) )
# 577 "smtlib2_parse.ml"
               : 'command_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.command) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'command_list) in
    Obj.repr(
# 182 "smtlib2_parse.mly"
                       ( let (_, l1) = _2 in (loc_command _1, (_1)::(l1)) )
# 585 "smtlib2_parse.ml"
               : 'command_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'command_list) in
    Obj.repr(
# 186 "smtlib2_parse.mly"
               ( Commands(loc_couple _1, _1) )
# 592 "smtlib2_parse.ml"
               : Smtlib2_ast.commands))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 190 "smtlib2_parse.mly"
          ( (loc (), (_1)::[]) )
# 599 "smtlib2_parse.ml"
               : 'numeral_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'numeral_list) in
    Obj.repr(
# 191 "smtlib2_parse.mly"
                       ( let (_, l1) = _2 in (loc (), (_1)::(l1)) )
# 607 "smtlib2_parse.ml"
               : 'numeral_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.symbol) in
    Obj.repr(
# 195 "smtlib2_parse.mly"
         ( IdSymbol(loc_symbol _1, _1) )
# 614 "smtlib2_parse.ml"
               : Smtlib2_ast.identifier))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : Smtlib2_ast.symbol) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'numeral_list) in
    Obj.repr(
# 197 "smtlib2_parse.mly"
    ( IdUnderscoreSymNum(loc (), _3, _4) )
# 622 "smtlib2_parse.ml"
               : Smtlib2_ast.identifier))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 201 "smtlib2_parse.mly"
          ( InfoFlagKeyword(loc (), _1) )
# 629 "smtlib2_parse.ml"
               : Smtlib2_ast.infoflag))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.identifier) in
    Obj.repr(
# 205 "smtlib2_parse.mly"
             ( QualIdentifierId(loc_identifier _1, _1) )
# 636 "smtlib2_parse.ml"
               : Smtlib2_ast.qualidentifier))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : Smtlib2_ast.identifier) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.sort) in
    Obj.repr(
# 206 "smtlib2_parse.mly"
                                   ( QualIdentifierAs(loc (), _3, _4) )
# 644 "smtlib2_parse.ml"
               : Smtlib2_ast.qualidentifier))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.specconstant) in
    Obj.repr(
# 210 "smtlib2_parse.mly"
               ( SexprSpecConst(loc_specconstant _1, _1) )
# 651 "smtlib2_parse.ml"
               : Smtlib2_ast.sexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.symbol) in
    Obj.repr(
# 211 "smtlib2_parse.mly"
         ( SexprSymbol(loc_symbol _1, _1) )
# 658 "smtlib2_parse.ml"
               : Smtlib2_ast.sexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 212 "smtlib2_parse.mly"
          ( SexprKeyword(loc (), _1) )
# 665 "smtlib2_parse.ml"
               : Smtlib2_ast.sexpr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'sexpr_list) in
    Obj.repr(
# 213 "smtlib2_parse.mly"
                           ( SexprInParen(loc (), _2) )
# 672 "smtlib2_parse.ml"
               : Smtlib2_ast.sexpr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.sort) in
    Obj.repr(
# 218 "smtlib2_parse.mly"
       ( (loc_sort _1, (_1)::[]) )
# 679 "smtlib2_parse.ml"
               : 'sort_list1))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.sort) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'sort_list1) in
    Obj.repr(
# 219 "smtlib2_parse.mly"
                  ( let (_, l1) = _2 in (loc_sort _1, (_1)::(l1)) )
# 687 "smtlib2_parse.ml"
               : 'sort_list1))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.identifier) in
    Obj.repr(
# 223 "smtlib2_parse.mly"
             ( SortIdentifier(loc_identifier _1, _1) )
# 694 "smtlib2_parse.ml"
               : Smtlib2_ast.sort))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : Smtlib2_ast.identifier) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'sort_list1) in
    Obj.repr(
# 224 "smtlib2_parse.mly"
                                      ( SortIdSortMulti(loc (), _2, _3) )
# 702 "smtlib2_parse.ml"
               : Smtlib2_ast.sort))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : Smtlib2_ast.symbol) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.sort) in
    Obj.repr(
# 228 "smtlib2_parse.mly"
                            ( SortedVarSymSort(loc (), _2, _3) )
# 710 "smtlib2_parse.ml"
               : Smtlib2_ast.sortedvar))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 232 "smtlib2_parse.mly"
          ( SpecConstsDec(loc (), _1) )
# 717 "smtlib2_parse.ml"
               : Smtlib2_ast.specconstant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 233 "smtlib2_parse.mly"
          ( SpecConstNum(loc (), _1) )
# 724 "smtlib2_parse.ml"
               : Smtlib2_ast.specconstant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 234 "smtlib2_parse.mly"
            ( SpecConstString(loc (), _1) )
# 731 "smtlib2_parse.ml"
               : Smtlib2_ast.specconstant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 235 "smtlib2_parse.mly"
              ( SpecConstsHex(loc (), _1) )
# 738 "smtlib2_parse.ml"
               : Smtlib2_ast.specconstant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 236 "smtlib2_parse.mly"
         ( SpecConstsBinary(loc (), _1) )
# 745 "smtlib2_parse.ml"
               : Smtlib2_ast.specconstant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 240 "smtlib2_parse.mly"
         ( Symbol(loc (), _1) )
# 752 "smtlib2_parse.ml"
               : Smtlib2_ast.symbol))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 241 "smtlib2_parse.mly"
           ( SymbolWithOr(loc (), _1) )
# 759 "smtlib2_parse.ml"
               : Smtlib2_ast.symbol))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.term) in
    Obj.repr(
# 247 "smtlib2_parse.mly"
       ( (loc_term _1, (_1)::[]) )
# 766 "smtlib2_parse.ml"
               : 'term_list1))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.term) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'term_list1) in
    Obj.repr(
# 248 "smtlib2_parse.mly"
                  ( let (_, l1) = _2 in (loc_term _1, (_1)::(l1)) )
# 774 "smtlib2_parse.ml"
               : 'term_list1))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.varbinding) in
    Obj.repr(
# 252 "smtlib2_parse.mly"
             ( (loc_varbinding _1, (_1)::[]) )
# 781 "smtlib2_parse.ml"
               : 'varbinding_list1))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.varbinding) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'varbinding_list1) in
    Obj.repr(
# 254 "smtlib2_parse.mly"
    ( let (_, l1) = _2 in (loc_varbinding _1, (_1)::(l1)) )
# 789 "smtlib2_parse.ml"
               : 'varbinding_list1))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.sortedvar) in
    Obj.repr(
# 260 "smtlib2_parse.mly"
            ( (loc_sortedvar _1, (_1)::[]) )
# 796 "smtlib2_parse.ml"
               : 'sortedvar_list1))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.sortedvar) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'sortedvar_list1) in
    Obj.repr(
# 262 "smtlib2_parse.mly"
    ( let (_, l1) = _2 in (loc_sortedvar _1, (_1)::(l1)) )
# 804 "smtlib2_parse.ml"
               : 'sortedvar_list1))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.attribute) in
    Obj.repr(
# 266 "smtlib2_parse.mly"
            ( (loc_attribute _1, (_1)::[]) )
# 811 "smtlib2_parse.ml"
               : 'attribute_list1))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.attribute) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute_list1) in
    Obj.repr(
# 268 "smtlib2_parse.mly"
    ( let (_, l1) = _2 in (loc_attribute _1, (_1)::(l1)) )
# 819 "smtlib2_parse.ml"
               : 'attribute_list1))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.specconstant) in
    Obj.repr(
# 273 "smtlib2_parse.mly"
    ( TermSpecConst(loc_specconstant _1, _1) )
# 826 "smtlib2_parse.ml"
               : Smtlib2_ast.term))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : Smtlib2_ast.qualidentifier) in
    Obj.repr(
# 275 "smtlib2_parse.mly"
    ( TermQualIdentifier(loc_qualidentifier _1, _1) )
# 833 "smtlib2_parse.ml"
               : Smtlib2_ast.term))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : Smtlib2_ast.qualidentifier) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'term_list1) in
    Obj.repr(
# 277 "smtlib2_parse.mly"
    ( TermQualIdTerm(loc (), _2, _3) )
# 841 "smtlib2_parse.ml"
               : Smtlib2_ast.term))
; (fun __caml_parser_env ->
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'varbinding_list1) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.term) in
    Obj.repr(
# 279 "smtlib2_parse.mly"
    ( TermLetTerm(loc (), _4, _6) )
# 849 "smtlib2_parse.ml"
               : Smtlib2_ast.term))
; (fun __caml_parser_env ->
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'sortedvar_list1) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.term) in
    Obj.repr(
# 281 "smtlib2_parse.mly"
    ( TermForAllTerm(loc (), _4, _6) )
# 857 "smtlib2_parse.ml"
               : Smtlib2_ast.term))
; (fun __caml_parser_env ->
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'sortedvar_list1) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.term) in
    Obj.repr(
# 283 "smtlib2_parse.mly"
    ( TermExistsTerm(loc (), _4, _6) )
# 865 "smtlib2_parse.ml"
               : Smtlib2_ast.term))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : Smtlib2_ast.term) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'attribute_list1) in
    Obj.repr(
# 285 "smtlib2_parse.mly"
    ( TermExclimationPt(loc (), _3, _4) )
# 873 "smtlib2_parse.ml"
               : Smtlib2_ast.term))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : Smtlib2_ast.symbol) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : Smtlib2_ast.term) in
    Obj.repr(
# 289 "smtlib2_parse.mly"
                            ( VarBindingSymTerm(loc (), _2, _3) )
# 881 "smtlib2_parse.ml"
               : Smtlib2_ast.varbinding))
(* Entry main *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
|]
let yytables =
  { Parsing.actions=yyact;
    Parsing.transl_const=yytransl_const;
    Parsing.transl_block=yytransl_block;
    Parsing.lhs=yylhs;
    Parsing.len=yylen;
    Parsing.defred=yydefred;
    Parsing.dgoto=yydgoto;
    Parsing.sindex=yysindex;
    Parsing.rindex=yyrindex;
    Parsing.gindex=yygindex;
    Parsing.tablesize=yytablesize;
    Parsing.table=yytable;
    Parsing.check=yycheck;
    Parsing.error_function=parse_error;
    Parsing.names_const=yynames_const;
    Parsing.names_block=yynames_block }
let main (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 1 lexfun lexbuf : Smtlib2_ast.commands option)
end
include (IMPLEMENTATION : INTERFACE)
end
and Smtlib2_lex: sig
#0 "smtlib2_lex.mli"
val newline : Lexing.lexbuf -> unit
val __ocaml_lex_tables : Lexing.lex_tables
val token : Lexing.lexbuf -> Smtlib2_parse.token
val __ocaml_lex_token_rec : Lexing.lexbuf -> int -> Smtlib2_parse.token
end = struct
let _ = Printf.fprintf stderr "Executing smtlib2_lex.ml\n%!"module type INTERFACE = sig
#0 "smtlib2_lex.mli"
val newline : Lexing.lexbuf -> unit
val __ocaml_lex_tables : Lexing.lex_tables
val token : Lexing.lexbuf -> Smtlib2_parse.token
val __ocaml_lex_token_rec : Lexing.lexbuf -> int -> Smtlib2_parse.token
end
module IMPLEMENTATION = struct
#0 "smtlib2_lex.ml"
# 1 "smtlib2_lex.mll"
  
open Lexing
open Smtlib2_parse


let newline lexbuf =
    let pos = lexbuf.lex_curr_p in
    lexbuf.lex_curr_p <- 
      { pos with pos_lnum = pos.pos_lnum + 1; pos_bol = pos.pos_cnum; 
        pos_cnum=0 }


# 15 "smtlib2_lex.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\216\255\217\255\079\000\045\000\128\000\222\000\057\001\
    \171\001\025\000\009\002\100\002\191\002\026\003\117\003\208\003\
    \043\004\134\004\225\004\060\005\250\255\251\255\151\005\001\000\
    \005\000\007\000\242\005\077\006\168\006\003\007\094\007\185\007\
    \020\008\111\008\202\008\037\009\128\009\219\009\054\010\145\010\
    \236\010\071\011\162\011\253\011\088\012\179\012\014\013\105\013\
    \196\013\031\014\122\014\213\014\048\015\139\015\230\015\065\016\
    \156\016\247\016\082\017\173\017\008\018\099\018\190\018\025\019\
    \116\019\207\019\042\020\133\020\224\020\059\021\150\021\241\021\
    \076\022\167\022\002\023\093\023\184\023\019\024\110\024\201\024\
    \036\025\127\025\218\025\053\026\144\026\235\026\070\027\161\027\
    \252\027\087\028\178\028\013\029\104\029\195\029\030\030\121\030\
    \212\030\047\031\138\031\229\031\064\032\155\032\246\032\081\033\
    \172\033\007\034\098\034\189\034\024\035\115\035\206\035\041\036\
    \132\036\223\036\058\037\149\037\240\037\075\038\166\038\001\039\
    \092\039\183\039\018\040\109\040\200\040\035\041\126\041\217\041\
    \052\042\143\042\234\042\069\043\160\043\251\043\086\044\177\044\
    \012\045\103\045\194\045\029\046\120\046\211\046\046\047\137\047\
    \228\047\063\048\154\048\245\048\080\049\171\049\006\050\044\000\
    \085\050\108\050\091\000\223\255\179\050\017\051\220\255\131\051\
    \249\051\098\000\137\001";
  Lexing.lex_backtrk = 
   "\255\255\255\255\255\255\036\000\036\000\039\000\034\000\039\000\
    \039\000\039\000\034\000\034\000\034\000\034\000\034\000\010\000\
    \034\000\034\000\034\000\034\000\255\255\255\255\003\000\002\000\
    \001\000\000\000\006\000\034\000\034\000\034\000\020\000\034\000\
    \007\000\034\000\034\000\034\000\034\000\008\000\034\000\034\000\
    \029\000\034\000\034\000\009\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\011\000\034\000\034\000\
    \034\000\034\000\012\000\034\000\034\000\013\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\014\000\034\000\016\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\015\000\034\000\017\000\
    \034\000\034\000\034\000\018\000\019\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\021\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\022\000\
    \034\000\034\000\034\000\034\000\034\000\026\000\034\000\034\000\
    \034\000\023\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\024\000\034\000\034\000\034\000\025\000\034\000\
    \034\000\034\000\034\000\027\000\034\000\034\000\028\000\255\255\
    \255\255\030\000\031\000\255\255\255\255\033\000\255\255\255\255\
    \255\255\255\255\037\000";
  Lexing.lex_default = 
   "\001\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\000\000\000\000\255\255\255\255\
    \024\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\000\000\255\255\255\255\000\000\255\255\
    \255\255\255\255\255\255";
  Lexing.lex_trans = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\025\000\023\000\023\000\000\000\000\000\000\000\255\255\
    \025\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \025\000\015\000\005\000\009\000\006\000\006\000\006\000\025\000\
    \021\000\020\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \004\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\007\000\024\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\161\000\154\000\154\000\006\000\022\000\
    \000\000\019\000\006\000\011\000\013\000\016\000\017\000\010\000\
    \006\000\006\000\006\000\006\000\018\000\006\000\006\000\006\000\
    \012\000\006\000\006\000\014\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\151\000\008\000\161\000\006\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\160\000\160\000\154\000\154\000\160\000\000\000\000\000\
    \000\000\152\000\162\000\162\000\162\000\162\000\162\000\162\000\
    \162\000\162\000\162\000\162\000\000\000\000\000\000\000\000\000\
    \160\000\160\000\158\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\159\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\006\000\
    \002\000\000\000\006\000\006\000\006\000\255\255\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\157\000\000\000\006\000\157\000\157\000\157\000\
    \000\000\000\000\000\000\157\000\157\000\000\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\000\000\000\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\000\000\000\000\000\000\157\000\
    \157\000\000\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\156\000\156\000\000\000\157\000\
    \156\000\162\000\162\000\162\000\162\000\162\000\162\000\162\000\
    \162\000\162\000\162\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\000\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\155\000\
    \156\000\156\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\101\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\093\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\088\000\006\000\
    \006\000\006\000\006\000\006\000\089\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\062\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\044\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\038\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\033\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\031\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\026\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\027\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\028\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\029\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\030\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\032\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\034\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\035\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\036\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\037\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\039\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\041\000\040\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\042\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\043\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\045\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \046\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\047\000\
    \006\000\006\000\049\000\006\000\006\000\048\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\059\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\054\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\050\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\051\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\052\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\053\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\055\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\056\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\057\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\058\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\060\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\061\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\064\000\006\000\006\000\063\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\077\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \065\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \066\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\067\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\068\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\069\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\070\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\071\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\075\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \072\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\073\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\074\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\076\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\078\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\079\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\080\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\081\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\082\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\086\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\083\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\084\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\085\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\087\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\092\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\090\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\091\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \094\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\095\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\096\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\097\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\098\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\099\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\100\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\102\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\103\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\109\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\104\000\006\000\006\000\006\000\006\000\006\000\
    \105\000\108\000\006\000\006\000\006\000\006\000\107\000\106\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\148\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\143\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\139\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\130\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\126\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\110\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\111\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\113\000\006\000\
    \006\000\006\000\112\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\120\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\114\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\115\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\116\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\117\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\118\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\119\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\121\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\122\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\123\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\124\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\125\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\127\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \128\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\129\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\131\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\132\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\133\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \134\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\135\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \136\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\137\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\138\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\140\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\141\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \142\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\144\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\145\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\146\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \147\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\006\000\000\000\006\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\149\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\006\000\000\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\150\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\153\000\153\000\153\000\
    \153\000\153\000\153\000\153\000\153\000\153\000\153\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\153\000\153\000\
    \153\000\153\000\153\000\153\000\153\000\153\000\153\000\153\000\
    \153\000\153\000\153\000\153\000\153\000\153\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\153\000\153\000\153\000\
    \153\000\153\000\153\000\000\000\000\000\000\000\153\000\153\000\
    \153\000\153\000\153\000\153\000\156\000\156\000\000\000\000\000\
    \156\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\153\000\153\000\153\000\
    \153\000\153\000\153\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\000\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\155\000\
    \156\000\156\000\157\000\000\000\000\000\157\000\157\000\157\000\
    \000\000\000\000\000\000\157\000\157\000\000\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\000\000\000\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\000\000\000\000\000\000\157\000\
    \157\000\000\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\160\000\160\000\000\000\157\000\
    \160\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\000\000\000\000\160\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\160\000\160\000\158\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\159\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000";
  Lexing.lex_check = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\023\000\255\255\255\255\255\255\024\000\
    \025\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\025\000\
    \000\000\000\000\000\000\000\000\255\255\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\004\000\151\000\151\000\000\000\000\000\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\009\000\000\000\003\000\000\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\005\000\005\000\154\000\154\000\005\000\255\255\255\255\
    \255\255\009\000\161\000\161\000\161\000\161\000\161\000\161\000\
    \161\000\161\000\161\000\161\000\255\255\255\255\255\255\255\255\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\006\000\
    \000\000\255\255\006\000\006\000\006\000\024\000\255\255\255\255\
    \006\000\006\000\255\255\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \255\255\255\255\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\255\255\255\255\255\255\006\000\006\000\255\255\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\255\255\007\000\255\255\006\000\007\000\007\000\007\000\
    \255\255\255\255\255\255\007\000\007\000\255\255\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\255\255\255\255\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\255\255\255\255\255\255\007\000\
    \007\000\255\255\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\008\000\008\000\255\255\007\000\
    \008\000\162\000\162\000\162\000\162\000\162\000\162\000\162\000\
    \162\000\162\000\162\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\255\255\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\010\000\255\255\255\255\010\000\010\000\010\000\
    \255\255\255\255\255\255\010\000\010\000\255\255\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\255\255\255\255\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\255\255\255\255\255\255\010\000\
    \010\000\255\255\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\255\255\011\000\255\255\010\000\
    \011\000\011\000\011\000\255\255\255\255\255\255\011\000\011\000\
    \255\255\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\255\255\255\255\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\255\255\
    \255\255\255\255\011\000\011\000\255\255\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\255\255\
    \012\000\255\255\011\000\012\000\012\000\012\000\255\255\255\255\
    \255\255\012\000\012\000\255\255\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\255\255\255\255\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\255\255\255\255\255\255\012\000\012\000\255\255\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\255\255\013\000\255\255\012\000\013\000\013\000\
    \013\000\255\255\255\255\255\255\013\000\013\000\255\255\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\255\255\255\255\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\255\255\255\255\255\255\
    \013\000\013\000\255\255\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\255\255\014\000\255\255\
    \013\000\014\000\014\000\014\000\255\255\255\255\255\255\014\000\
    \014\000\255\255\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\255\255\
    \255\255\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \255\255\255\255\255\255\014\000\014\000\255\255\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \255\255\015\000\255\255\014\000\015\000\015\000\015\000\255\255\
    \255\255\255\255\015\000\015\000\255\255\015\000\015\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\255\255\255\255\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\255\255\255\255\255\255\015\000\015\000\
    \255\255\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\255\255\016\000\255\255\015\000\016\000\
    \016\000\016\000\255\255\255\255\255\255\016\000\016\000\255\255\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\255\255\255\255\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\255\255\255\255\
    \255\255\016\000\016\000\255\255\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\255\255\017\000\
    \255\255\016\000\017\000\017\000\017\000\255\255\255\255\255\255\
    \017\000\017\000\255\255\017\000\017\000\017\000\017\000\017\000\
    \017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\
    \255\255\255\255\017\000\017\000\017\000\017\000\017\000\017\000\
    \017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\
    \017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\
    \017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\
    \017\000\255\255\255\255\255\255\017\000\017\000\255\255\017\000\
    \017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\
    \017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\
    \017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\
    \017\000\255\255\018\000\255\255\017\000\018\000\018\000\018\000\
    \255\255\255\255\255\255\018\000\018\000\255\255\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\255\255\255\255\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\255\255\255\255\255\255\018\000\
    \018\000\255\255\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\255\255\019\000\255\255\018\000\
    \019\000\019\000\019\000\255\255\255\255\255\255\019\000\019\000\
    \255\255\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\255\255\255\255\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\255\255\
    \255\255\255\255\019\000\019\000\255\255\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\255\255\
    \022\000\255\255\019\000\022\000\022\000\022\000\255\255\255\255\
    \255\255\022\000\022\000\255\255\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\255\255\255\255\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\255\255\255\255\255\255\022\000\022\000\255\255\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\255\255\026\000\255\255\022\000\026\000\026\000\
    \026\000\255\255\255\255\255\255\026\000\026\000\255\255\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\255\255\255\255\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\255\255\255\255\255\255\
    \026\000\026\000\255\255\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\255\255\027\000\255\255\
    \026\000\027\000\027\000\027\000\255\255\255\255\255\255\027\000\
    \027\000\255\255\027\000\027\000\027\000\027\000\027\000\027\000\
    \027\000\027\000\027\000\027\000\027\000\027\000\027\000\255\255\
    \255\255\027\000\027\000\027\000\027\000\027\000\027\000\027\000\
    \027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\
    \027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\
    \027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\
    \255\255\255\255\255\255\027\000\027\000\255\255\027\000\027\000\
    \027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\
    \027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\
    \027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\
    \255\255\028\000\255\255\027\000\028\000\028\000\028\000\255\255\
    \255\255\255\255\028\000\028\000\255\255\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\255\255\255\255\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\255\255\255\255\255\255\028\000\028\000\
    \255\255\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\255\255\029\000\255\255\028\000\029\000\
    \029\000\029\000\255\255\255\255\255\255\029\000\029\000\255\255\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\255\255\255\255\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\255\255\255\255\
    \255\255\029\000\029\000\255\255\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\255\255\030\000\
    \255\255\029\000\030\000\030\000\030\000\255\255\255\255\255\255\
    \030\000\030\000\255\255\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \255\255\255\255\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\255\255\255\255\255\255\030\000\030\000\255\255\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\255\255\031\000\255\255\030\000\031\000\031\000\031\000\
    \255\255\255\255\255\255\031\000\031\000\255\255\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\255\255\255\255\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\255\255\255\255\255\255\031\000\
    \031\000\255\255\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\255\255\032\000\255\255\031\000\
    \032\000\032\000\032\000\255\255\255\255\255\255\032\000\032\000\
    \255\255\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\255\255\255\255\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\255\255\
    \255\255\255\255\032\000\032\000\255\255\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\255\255\
    \033\000\255\255\032\000\033\000\033\000\033\000\255\255\255\255\
    \255\255\033\000\033\000\255\255\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\255\255\255\255\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\255\255\255\255\255\255\033\000\033\000\255\255\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\255\255\034\000\255\255\033\000\034\000\034\000\
    \034\000\255\255\255\255\255\255\034\000\034\000\255\255\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\255\255\255\255\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\255\255\255\255\255\255\
    \034\000\034\000\255\255\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\255\255\035\000\255\255\
    \034\000\035\000\035\000\035\000\255\255\255\255\255\255\035\000\
    \035\000\255\255\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\255\255\
    \255\255\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \255\255\255\255\255\255\035\000\035\000\255\255\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \255\255\036\000\255\255\035\000\036\000\036\000\036\000\255\255\
    \255\255\255\255\036\000\036\000\255\255\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\255\255\255\255\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\255\255\255\255\255\255\036\000\036\000\
    \255\255\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\255\255\037\000\255\255\036\000\037\000\
    \037\000\037\000\255\255\255\255\255\255\037\000\037\000\255\255\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\255\255\255\255\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\255\255\255\255\
    \255\255\037\000\037\000\255\255\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\255\255\038\000\
    \255\255\037\000\038\000\038\000\038\000\255\255\255\255\255\255\
    \038\000\038\000\255\255\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \255\255\255\255\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\255\255\255\255\255\255\038\000\038\000\255\255\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\255\255\039\000\255\255\038\000\039\000\039\000\039\000\
    \255\255\255\255\255\255\039\000\039\000\255\255\039\000\039\000\
    \039\000\039\000\039\000\039\000\039\000\039\000\039\000\039\000\
    \039\000\039\000\039\000\255\255\255\255\039\000\039\000\039\000\
    \039\000\039\000\039\000\039\000\039\000\039\000\039\000\039\000\
    \039\000\039\000\039\000\039\000\039\000\039\000\039\000\039\000\
    \039\000\039\000\039\000\039\000\039\000\039\000\039\000\039\000\
    \039\000\039\000\039\000\039\000\255\255\255\255\255\255\039\000\
    \039\000\255\255\039\000\039\000\039\000\039\000\039\000\039\000\
    \039\000\039\000\039\000\039\000\039\000\039\000\039\000\039\000\
    \039\000\039\000\039\000\039\000\039\000\039\000\039\000\039\000\
    \039\000\039\000\039\000\039\000\255\255\040\000\255\255\039\000\
    \040\000\040\000\040\000\255\255\255\255\255\255\040\000\040\000\
    \255\255\040\000\040\000\040\000\040\000\040\000\040\000\040\000\
    \040\000\040\000\040\000\040\000\040\000\040\000\255\255\255\255\
    \040\000\040\000\040\000\040\000\040\000\040\000\040\000\040\000\
    \040\000\040\000\040\000\040\000\040\000\040\000\040\000\040\000\
    \040\000\040\000\040\000\040\000\040\000\040\000\040\000\040\000\
    \040\000\040\000\040\000\040\000\040\000\040\000\040\000\255\255\
    \255\255\255\255\040\000\040\000\255\255\040\000\040\000\040\000\
    \040\000\040\000\040\000\040\000\040\000\040\000\040\000\040\000\
    \040\000\040\000\040\000\040\000\040\000\040\000\040\000\040\000\
    \040\000\040\000\040\000\040\000\040\000\040\000\040\000\255\255\
    \041\000\255\255\040\000\041\000\041\000\041\000\255\255\255\255\
    \255\255\041\000\041\000\255\255\041\000\041\000\041\000\041\000\
    \041\000\041\000\041\000\041\000\041\000\041\000\041\000\041\000\
    \041\000\255\255\255\255\041\000\041\000\041\000\041\000\041\000\
    \041\000\041\000\041\000\041\000\041\000\041\000\041\000\041\000\
    \041\000\041\000\041\000\041\000\041\000\041\000\041\000\041\000\
    \041\000\041\000\041\000\041\000\041\000\041\000\041\000\041\000\
    \041\000\041\000\255\255\255\255\255\255\041\000\041\000\255\255\
    \041\000\041\000\041\000\041\000\041\000\041\000\041\000\041\000\
    \041\000\041\000\041\000\041\000\041\000\041\000\041\000\041\000\
    \041\000\041\000\041\000\041\000\041\000\041\000\041\000\041\000\
    \041\000\041\000\255\255\042\000\255\255\041\000\042\000\042\000\
    \042\000\255\255\255\255\255\255\042\000\042\000\255\255\042\000\
    \042\000\042\000\042\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\042\000\042\000\042\000\255\255\255\255\042\000\042\000\
    \042\000\042\000\042\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\042\000\042\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\042\000\042\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\042\000\042\000\042\000\042\000\255\255\255\255\255\255\
    \042\000\042\000\255\255\042\000\042\000\042\000\042\000\042\000\
    \042\000\042\000\042\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\042\000\042\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\042\000\042\000\042\000\042\000\255\255\043\000\255\255\
    \042\000\043\000\043\000\043\000\255\255\255\255\255\255\043\000\
    \043\000\255\255\043\000\043\000\043\000\043\000\043\000\043\000\
    \043\000\043\000\043\000\043\000\043\000\043\000\043\000\255\255\
    \255\255\043\000\043\000\043\000\043\000\043\000\043\000\043\000\
    \043\000\043\000\043\000\043\000\043\000\043\000\043\000\043\000\
    \043\000\043\000\043\000\043\000\043\000\043\000\043\000\043\000\
    \043\000\043\000\043\000\043\000\043\000\043\000\043\000\043\000\
    \255\255\255\255\255\255\043\000\043\000\255\255\043\000\043\000\
    \043\000\043\000\043\000\043\000\043\000\043\000\043\000\043\000\
    \043\000\043\000\043\000\043\000\043\000\043\000\043\000\043\000\
    \043\000\043\000\043\000\043\000\043\000\043\000\043\000\043\000\
    \255\255\044\000\255\255\043\000\044\000\044\000\044\000\255\255\
    \255\255\255\255\044\000\044\000\255\255\044\000\044\000\044\000\
    \044\000\044\000\044\000\044\000\044\000\044\000\044\000\044\000\
    \044\000\044\000\255\255\255\255\044\000\044\000\044\000\044\000\
    \044\000\044\000\044\000\044\000\044\000\044\000\044\000\044\000\
    \044\000\044\000\044\000\044\000\044\000\044\000\044\000\044\000\
    \044\000\044\000\044\000\044\000\044\000\044\000\044\000\044\000\
    \044\000\044\000\044\000\255\255\255\255\255\255\044\000\044\000\
    \255\255\044\000\044\000\044\000\044\000\044\000\044\000\044\000\
    \044\000\044\000\044\000\044\000\044\000\044\000\044\000\044\000\
    \044\000\044\000\044\000\044\000\044\000\044\000\044\000\044\000\
    \044\000\044\000\044\000\255\255\045\000\255\255\044\000\045\000\
    \045\000\045\000\255\255\255\255\255\255\045\000\045\000\255\255\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\255\255\255\255\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\255\255\255\255\
    \255\255\045\000\045\000\255\255\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\255\255\046\000\
    \255\255\045\000\046\000\046\000\046\000\255\255\255\255\255\255\
    \046\000\046\000\255\255\046\000\046\000\046\000\046\000\046\000\
    \046\000\046\000\046\000\046\000\046\000\046\000\046\000\046\000\
    \255\255\255\255\046\000\046\000\046\000\046\000\046\000\046\000\
    \046\000\046\000\046\000\046\000\046\000\046\000\046\000\046\000\
    \046\000\046\000\046\000\046\000\046\000\046\000\046\000\046\000\
    \046\000\046\000\046\000\046\000\046\000\046\000\046\000\046\000\
    \046\000\255\255\255\255\255\255\046\000\046\000\255\255\046\000\
    \046\000\046\000\046\000\046\000\046\000\046\000\046\000\046\000\
    \046\000\046\000\046\000\046\000\046\000\046\000\046\000\046\000\
    \046\000\046\000\046\000\046\000\046\000\046\000\046\000\046\000\
    \046\000\255\255\047\000\255\255\046\000\047\000\047\000\047\000\
    \255\255\255\255\255\255\047\000\047\000\255\255\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\255\255\255\255\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\255\255\255\255\255\255\047\000\
    \047\000\255\255\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\255\255\048\000\255\255\047\000\
    \048\000\048\000\048\000\255\255\255\255\255\255\048\000\048\000\
    \255\255\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\255\255\255\255\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\255\255\
    \255\255\255\255\048\000\048\000\255\255\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\255\255\
    \049\000\255\255\048\000\049\000\049\000\049\000\255\255\255\255\
    \255\255\049\000\049\000\255\255\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\255\255\255\255\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\255\255\255\255\255\255\049\000\049\000\255\255\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\255\255\050\000\255\255\049\000\050\000\050\000\
    \050\000\255\255\255\255\255\255\050\000\050\000\255\255\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\255\255\255\255\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\255\255\255\255\255\255\
    \050\000\050\000\255\255\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\255\255\051\000\255\255\
    \050\000\051\000\051\000\051\000\255\255\255\255\255\255\051\000\
    \051\000\255\255\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\255\255\
    \255\255\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \255\255\255\255\255\255\051\000\051\000\255\255\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \255\255\052\000\255\255\051\000\052\000\052\000\052\000\255\255\
    \255\255\255\255\052\000\052\000\255\255\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\255\255\255\255\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\255\255\255\255\255\255\052\000\052\000\
    \255\255\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\255\255\053\000\255\255\052\000\053\000\
    \053\000\053\000\255\255\255\255\255\255\053\000\053\000\255\255\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\255\255\255\255\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\255\255\255\255\
    \255\255\053\000\053\000\255\255\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\255\255\054\000\
    \255\255\053\000\054\000\054\000\054\000\255\255\255\255\255\255\
    \054\000\054\000\255\255\054\000\054\000\054\000\054\000\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \255\255\255\255\054\000\054\000\054\000\054\000\054\000\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \054\000\255\255\255\255\255\255\054\000\054\000\255\255\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \054\000\255\255\055\000\255\255\054\000\055\000\055\000\055\000\
    \255\255\255\255\255\255\055\000\055\000\255\255\055\000\055\000\
    \055\000\055\000\055\000\055\000\055\000\055\000\055\000\055\000\
    \055\000\055\000\055\000\255\255\255\255\055\000\055\000\055\000\
    \055\000\055\000\055\000\055\000\055\000\055\000\055\000\055\000\
    \055\000\055\000\055\000\055\000\055\000\055\000\055\000\055\000\
    \055\000\055\000\055\000\055\000\055\000\055\000\055\000\055\000\
    \055\000\055\000\055\000\055\000\255\255\255\255\255\255\055\000\
    \055\000\255\255\055\000\055\000\055\000\055\000\055\000\055\000\
    \055\000\055\000\055\000\055\000\055\000\055\000\055\000\055\000\
    \055\000\055\000\055\000\055\000\055\000\055\000\055\000\055\000\
    \055\000\055\000\055\000\055\000\255\255\056\000\255\255\055\000\
    \056\000\056\000\056\000\255\255\255\255\255\255\056\000\056\000\
    \255\255\056\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\255\255\255\255\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\255\255\
    \255\255\255\255\056\000\056\000\255\255\056\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\255\255\
    \057\000\255\255\056\000\057\000\057\000\057\000\255\255\255\255\
    \255\255\057\000\057\000\255\255\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\255\255\255\255\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\255\255\255\255\255\255\057\000\057\000\255\255\
    \057\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\255\255\058\000\255\255\057\000\058\000\058\000\
    \058\000\255\255\255\255\255\255\058\000\058\000\255\255\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\255\255\255\255\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\255\255\255\255\255\255\
    \058\000\058\000\255\255\058\000\058\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\255\255\059\000\255\255\
    \058\000\059\000\059\000\059\000\255\255\255\255\255\255\059\000\
    \059\000\255\255\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\255\255\
    \255\255\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \255\255\255\255\255\255\059\000\059\000\255\255\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \255\255\060\000\255\255\059\000\060\000\060\000\060\000\255\255\
    \255\255\255\255\060\000\060\000\255\255\060\000\060\000\060\000\
    \060\000\060\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \060\000\060\000\255\255\255\255\060\000\060\000\060\000\060\000\
    \060\000\060\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \060\000\060\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \060\000\060\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \060\000\060\000\060\000\255\255\255\255\255\255\060\000\060\000\
    \255\255\060\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \060\000\060\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \060\000\060\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \060\000\060\000\060\000\255\255\061\000\255\255\060\000\061\000\
    \061\000\061\000\255\255\255\255\255\255\061\000\061\000\255\255\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\255\255\255\255\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\255\255\255\255\
    \255\255\061\000\061\000\255\255\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\255\255\062\000\
    \255\255\061\000\062\000\062\000\062\000\255\255\255\255\255\255\
    \062\000\062\000\255\255\062\000\062\000\062\000\062\000\062\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\062\000\062\000\
    \255\255\255\255\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\255\255\255\255\255\255\062\000\062\000\255\255\062\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\255\255\063\000\255\255\062\000\063\000\063\000\063\000\
    \255\255\255\255\255\255\063\000\063\000\255\255\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\063\000\063\000\255\255\255\255\063\000\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\063\000\063\000\063\000\255\255\255\255\255\255\063\000\
    \063\000\255\255\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\063\000\063\000\063\000\255\255\064\000\255\255\063\000\
    \064\000\064\000\064\000\255\255\255\255\255\255\064\000\064\000\
    \255\255\064\000\064\000\064\000\064\000\064\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\255\255\255\255\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\255\255\
    \255\255\255\255\064\000\064\000\255\255\064\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\255\255\
    \065\000\255\255\064\000\065\000\065\000\065\000\255\255\255\255\
    \255\255\065\000\065\000\255\255\065\000\065\000\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\065\000\
    \065\000\255\255\255\255\065\000\065\000\065\000\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\065\000\
    \065\000\065\000\255\255\255\255\255\255\065\000\065\000\255\255\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\065\000\
    \065\000\065\000\255\255\066\000\255\255\065\000\066\000\066\000\
    \066\000\255\255\255\255\255\255\066\000\066\000\255\255\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\255\255\255\255\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\255\255\255\255\255\255\
    \066\000\066\000\255\255\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\255\255\067\000\255\255\
    \066\000\067\000\067\000\067\000\255\255\255\255\255\255\067\000\
    \067\000\255\255\067\000\067\000\067\000\067\000\067\000\067\000\
    \067\000\067\000\067\000\067\000\067\000\067\000\067\000\255\255\
    \255\255\067\000\067\000\067\000\067\000\067\000\067\000\067\000\
    \067\000\067\000\067\000\067\000\067\000\067\000\067\000\067\000\
    \067\000\067\000\067\000\067\000\067\000\067\000\067\000\067\000\
    \067\000\067\000\067\000\067\000\067\000\067\000\067\000\067\000\
    \255\255\255\255\255\255\067\000\067\000\255\255\067\000\067\000\
    \067\000\067\000\067\000\067\000\067\000\067\000\067\000\067\000\
    \067\000\067\000\067\000\067\000\067\000\067\000\067\000\067\000\
    \067\000\067\000\067\000\067\000\067\000\067\000\067\000\067\000\
    \255\255\068\000\255\255\067\000\068\000\068\000\068\000\255\255\
    \255\255\255\255\068\000\068\000\255\255\068\000\068\000\068\000\
    \068\000\068\000\068\000\068\000\068\000\068\000\068\000\068\000\
    \068\000\068\000\255\255\255\255\068\000\068\000\068\000\068\000\
    \068\000\068\000\068\000\068\000\068\000\068\000\068\000\068\000\
    \068\000\068\000\068\000\068\000\068\000\068\000\068\000\068\000\
    \068\000\068\000\068\000\068\000\068\000\068\000\068\000\068\000\
    \068\000\068\000\068\000\255\255\255\255\255\255\068\000\068\000\
    \255\255\068\000\068\000\068\000\068\000\068\000\068\000\068\000\
    \068\000\068\000\068\000\068\000\068\000\068\000\068\000\068\000\
    \068\000\068\000\068\000\068\000\068\000\068\000\068\000\068\000\
    \068\000\068\000\068\000\255\255\069\000\255\255\068\000\069\000\
    \069\000\069\000\255\255\255\255\255\255\069\000\069\000\255\255\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\069\000\069\000\069\000\255\255\255\255\069\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\255\255\255\255\
    \255\255\069\000\069\000\255\255\069\000\069\000\069\000\069\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\255\255\070\000\
    \255\255\069\000\070\000\070\000\070\000\255\255\255\255\255\255\
    \070\000\070\000\255\255\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \255\255\255\255\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\255\255\255\255\255\255\070\000\070\000\255\255\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\255\255\071\000\255\255\070\000\071\000\071\000\071\000\
    \255\255\255\255\255\255\071\000\071\000\255\255\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\255\255\255\255\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\255\255\255\255\255\255\071\000\
    \071\000\255\255\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\255\255\072\000\255\255\071\000\
    \072\000\072\000\072\000\255\255\255\255\255\255\072\000\072\000\
    \255\255\072\000\072\000\072\000\072\000\072\000\072\000\072\000\
    \072\000\072\000\072\000\072\000\072\000\072\000\255\255\255\255\
    \072\000\072\000\072\000\072\000\072\000\072\000\072\000\072\000\
    \072\000\072\000\072\000\072\000\072\000\072\000\072\000\072\000\
    \072\000\072\000\072\000\072\000\072\000\072\000\072\000\072\000\
    \072\000\072\000\072\000\072\000\072\000\072\000\072\000\255\255\
    \255\255\255\255\072\000\072\000\255\255\072\000\072\000\072\000\
    \072\000\072\000\072\000\072\000\072\000\072\000\072\000\072\000\
    \072\000\072\000\072\000\072\000\072\000\072\000\072\000\072\000\
    \072\000\072\000\072\000\072\000\072\000\072\000\072\000\255\255\
    \073\000\255\255\072\000\073\000\073\000\073\000\255\255\255\255\
    \255\255\073\000\073\000\255\255\073\000\073\000\073\000\073\000\
    \073\000\073\000\073\000\073\000\073\000\073\000\073\000\073\000\
    \073\000\255\255\255\255\073\000\073\000\073\000\073\000\073\000\
    \073\000\073\000\073\000\073\000\073\000\073\000\073\000\073\000\
    \073\000\073\000\073\000\073\000\073\000\073\000\073\000\073\000\
    \073\000\073\000\073\000\073\000\073\000\073\000\073\000\073\000\
    \073\000\073\000\255\255\255\255\255\255\073\000\073\000\255\255\
    \073\000\073\000\073\000\073\000\073\000\073\000\073\000\073\000\
    \073\000\073\000\073\000\073\000\073\000\073\000\073\000\073\000\
    \073\000\073\000\073\000\073\000\073\000\073\000\073\000\073\000\
    \073\000\073\000\255\255\074\000\255\255\073\000\074\000\074\000\
    \074\000\255\255\255\255\255\255\074\000\074\000\255\255\074\000\
    \074\000\074\000\074\000\074\000\074\000\074\000\074\000\074\000\
    \074\000\074\000\074\000\074\000\255\255\255\255\074\000\074\000\
    \074\000\074\000\074\000\074\000\074\000\074\000\074\000\074\000\
    \074\000\074\000\074\000\074\000\074\000\074\000\074\000\074\000\
    \074\000\074\000\074\000\074\000\074\000\074\000\074\000\074\000\
    \074\000\074\000\074\000\074\000\074\000\255\255\255\255\255\255\
    \074\000\074\000\255\255\074\000\074\000\074\000\074\000\074\000\
    \074\000\074\000\074\000\074\000\074\000\074\000\074\000\074\000\
    \074\000\074\000\074\000\074\000\074\000\074\000\074\000\074\000\
    \074\000\074\000\074\000\074\000\074\000\255\255\075\000\255\255\
    \074\000\075\000\075\000\075\000\255\255\255\255\255\255\075\000\
    \075\000\255\255\075\000\075\000\075\000\075\000\075\000\075\000\
    \075\000\075\000\075\000\075\000\075\000\075\000\075\000\255\255\
    \255\255\075\000\075\000\075\000\075\000\075\000\075\000\075\000\
    \075\000\075\000\075\000\075\000\075\000\075\000\075\000\075\000\
    \075\000\075\000\075\000\075\000\075\000\075\000\075\000\075\000\
    \075\000\075\000\075\000\075\000\075\000\075\000\075\000\075\000\
    \255\255\255\255\255\255\075\000\075\000\255\255\075\000\075\000\
    \075\000\075\000\075\000\075\000\075\000\075\000\075\000\075\000\
    \075\000\075\000\075\000\075\000\075\000\075\000\075\000\075\000\
    \075\000\075\000\075\000\075\000\075\000\075\000\075\000\075\000\
    \255\255\076\000\255\255\075\000\076\000\076\000\076\000\255\255\
    \255\255\255\255\076\000\076\000\255\255\076\000\076\000\076\000\
    \076\000\076\000\076\000\076\000\076\000\076\000\076\000\076\000\
    \076\000\076\000\255\255\255\255\076\000\076\000\076\000\076\000\
    \076\000\076\000\076\000\076\000\076\000\076\000\076\000\076\000\
    \076\000\076\000\076\000\076\000\076\000\076\000\076\000\076\000\
    \076\000\076\000\076\000\076\000\076\000\076\000\076\000\076\000\
    \076\000\076\000\076\000\255\255\255\255\255\255\076\000\076\000\
    \255\255\076\000\076\000\076\000\076\000\076\000\076\000\076\000\
    \076\000\076\000\076\000\076\000\076\000\076\000\076\000\076\000\
    \076\000\076\000\076\000\076\000\076\000\076\000\076\000\076\000\
    \076\000\076\000\076\000\255\255\077\000\255\255\076\000\077\000\
    \077\000\077\000\255\255\255\255\255\255\077\000\077\000\255\255\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\255\255\255\255\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\255\255\255\255\
    \255\255\077\000\077\000\255\255\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\255\255\078\000\
    \255\255\077\000\078\000\078\000\078\000\255\255\255\255\255\255\
    \078\000\078\000\255\255\078\000\078\000\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\078\000\078\000\078\000\078\000\
    \255\255\255\255\078\000\078\000\078\000\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\078\000\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\078\000\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\078\000\078\000\078\000\078\000\
    \078\000\255\255\255\255\255\255\078\000\078\000\255\255\078\000\
    \078\000\078\000\078\000\078\000\078\000\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\078\000\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\078\000\078\000\078\000\078\000\
    \078\000\255\255\079\000\255\255\078\000\079\000\079\000\079\000\
    \255\255\255\255\255\255\079\000\079\000\255\255\079\000\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\079\000\255\255\255\255\079\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\255\255\255\255\255\255\079\000\
    \079\000\255\255\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\255\255\080\000\255\255\079\000\
    \080\000\080\000\080\000\255\255\255\255\255\255\080\000\080\000\
    \255\255\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\255\255\255\255\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\255\255\
    \255\255\255\255\080\000\080\000\255\255\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\255\255\
    \081\000\255\255\080\000\081\000\081\000\081\000\255\255\255\255\
    \255\255\081\000\081\000\255\255\081\000\081\000\081\000\081\000\
    \081\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\255\255\255\255\081\000\081\000\081\000\081\000\081\000\
    \081\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\081\000\255\255\255\255\255\255\081\000\081\000\255\255\
    \081\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\081\000\255\255\082\000\255\255\081\000\082\000\082\000\
    \082\000\255\255\255\255\255\255\082\000\082\000\255\255\082\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\255\255\255\255\082\000\082\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\082\000\255\255\255\255\255\255\
    \082\000\082\000\255\255\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\082\000\255\255\083\000\255\255\
    \082\000\083\000\083\000\083\000\255\255\255\255\255\255\083\000\
    \083\000\255\255\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\255\255\
    \255\255\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \255\255\255\255\255\255\083\000\083\000\255\255\083\000\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \255\255\084\000\255\255\083\000\084\000\084\000\084\000\255\255\
    \255\255\255\255\084\000\084\000\255\255\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\255\255\255\255\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\255\255\255\255\255\255\084\000\084\000\
    \255\255\084\000\084\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\255\255\085\000\255\255\084\000\085\000\
    \085\000\085\000\255\255\255\255\255\255\085\000\085\000\255\255\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\255\255\255\255\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\255\255\255\255\
    \255\255\085\000\085\000\255\255\085\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\255\255\086\000\
    \255\255\085\000\086\000\086\000\086\000\255\255\255\255\255\255\
    \086\000\086\000\255\255\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \255\255\255\255\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\255\255\255\255\255\255\086\000\086\000\255\255\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\255\255\087\000\255\255\086\000\087\000\087\000\087\000\
    \255\255\255\255\255\255\087\000\087\000\255\255\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\087\000\087\000\255\255\255\255\087\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\255\255\255\255\255\255\087\000\
    \087\000\255\255\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\255\255\088\000\255\255\087\000\
    \088\000\088\000\088\000\255\255\255\255\255\255\088\000\088\000\
    \255\255\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\255\255\255\255\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\255\255\
    \255\255\255\255\088\000\088\000\255\255\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\255\255\
    \089\000\255\255\088\000\089\000\089\000\089\000\255\255\255\255\
    \255\255\089\000\089\000\255\255\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\255\255\255\255\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\255\255\255\255\255\255\089\000\089\000\255\255\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\255\255\090\000\255\255\089\000\090\000\090\000\
    \090\000\255\255\255\255\255\255\090\000\090\000\255\255\090\000\
    \090\000\090\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \090\000\090\000\090\000\090\000\255\255\255\255\090\000\090\000\
    \090\000\090\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \090\000\090\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \090\000\090\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \090\000\090\000\090\000\090\000\090\000\255\255\255\255\255\255\
    \090\000\090\000\255\255\090\000\090\000\090\000\090\000\090\000\
    \090\000\090\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \090\000\090\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \090\000\090\000\090\000\090\000\090\000\255\255\091\000\255\255\
    \090\000\091\000\091\000\091\000\255\255\255\255\255\255\091\000\
    \091\000\255\255\091\000\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\091\000\091\000\091\000\091\000\091\000\255\255\
    \255\255\091\000\091\000\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\091\000\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\091\000\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\091\000\091\000\091\000\091\000\091\000\091\000\
    \255\255\255\255\255\255\091\000\091\000\255\255\091\000\091\000\
    \091\000\091\000\091\000\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\091\000\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\091\000\091\000\091\000\091\000\091\000\091\000\
    \255\255\092\000\255\255\091\000\092\000\092\000\092\000\255\255\
    \255\255\255\255\092\000\092\000\255\255\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\255\255\255\255\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\255\255\255\255\255\255\092\000\092\000\
    \255\255\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\255\255\093\000\255\255\092\000\093\000\
    \093\000\093\000\255\255\255\255\255\255\093\000\093\000\255\255\
    \093\000\093\000\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\093\000\255\255\255\255\093\000\
    \093\000\093\000\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\093\000\093\000\255\255\255\255\
    \255\255\093\000\093\000\255\255\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\093\000\093\000\255\255\094\000\
    \255\255\093\000\094\000\094\000\094\000\255\255\255\255\255\255\
    \094\000\094\000\255\255\094\000\094\000\094\000\094\000\094\000\
    \094\000\094\000\094\000\094\000\094\000\094\000\094\000\094\000\
    \255\255\255\255\094\000\094\000\094\000\094\000\094\000\094\000\
    \094\000\094\000\094\000\094\000\094\000\094\000\094\000\094\000\
    \094\000\094\000\094\000\094\000\094\000\094\000\094\000\094\000\
    \094\000\094\000\094\000\094\000\094\000\094\000\094\000\094\000\
    \094\000\255\255\255\255\255\255\094\000\094\000\255\255\094\000\
    \094\000\094\000\094\000\094\000\094\000\094\000\094\000\094\000\
    \094\000\094\000\094\000\094\000\094\000\094\000\094\000\094\000\
    \094\000\094\000\094\000\094\000\094\000\094\000\094\000\094\000\
    \094\000\255\255\095\000\255\255\094\000\095\000\095\000\095\000\
    \255\255\255\255\255\255\095\000\095\000\255\255\095\000\095\000\
    \095\000\095\000\095\000\095\000\095\000\095\000\095\000\095\000\
    \095\000\095\000\095\000\255\255\255\255\095\000\095\000\095\000\
    \095\000\095\000\095\000\095\000\095\000\095\000\095\000\095\000\
    \095\000\095\000\095\000\095\000\095\000\095\000\095\000\095\000\
    \095\000\095\000\095\000\095\000\095\000\095\000\095\000\095\000\
    \095\000\095\000\095\000\095\000\255\255\255\255\255\255\095\000\
    \095\000\255\255\095\000\095\000\095\000\095\000\095\000\095\000\
    \095\000\095\000\095\000\095\000\095\000\095\000\095\000\095\000\
    \095\000\095\000\095\000\095\000\095\000\095\000\095\000\095\000\
    \095\000\095\000\095\000\095\000\255\255\096\000\255\255\095\000\
    \096\000\096\000\096\000\255\255\255\255\255\255\096\000\096\000\
    \255\255\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\255\255\255\255\
    \096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\096\000\255\255\
    \255\255\255\255\096\000\096\000\255\255\096\000\096\000\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\096\000\255\255\
    \097\000\255\255\096\000\097\000\097\000\097\000\255\255\255\255\
    \255\255\097\000\097\000\255\255\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\255\255\255\255\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\255\255\255\255\255\255\097\000\097\000\255\255\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\255\255\098\000\255\255\097\000\098\000\098\000\
    \098\000\255\255\255\255\255\255\098\000\098\000\255\255\098\000\
    \098\000\098\000\098\000\098\000\098\000\098\000\098\000\098\000\
    \098\000\098\000\098\000\098\000\255\255\255\255\098\000\098\000\
    \098\000\098\000\098\000\098\000\098\000\098\000\098\000\098\000\
    \098\000\098\000\098\000\098\000\098\000\098\000\098\000\098\000\
    \098\000\098\000\098\000\098\000\098\000\098\000\098\000\098\000\
    \098\000\098\000\098\000\098\000\098\000\255\255\255\255\255\255\
    \098\000\098\000\255\255\098\000\098\000\098\000\098\000\098\000\
    \098\000\098\000\098\000\098\000\098\000\098\000\098\000\098\000\
    \098\000\098\000\098\000\098\000\098\000\098\000\098\000\098\000\
    \098\000\098\000\098\000\098\000\098\000\255\255\099\000\255\255\
    \098\000\099\000\099\000\099\000\255\255\255\255\255\255\099\000\
    \099\000\255\255\099\000\099\000\099\000\099\000\099\000\099\000\
    \099\000\099\000\099\000\099\000\099\000\099\000\099\000\255\255\
    \255\255\099\000\099\000\099\000\099\000\099\000\099\000\099\000\
    \099\000\099\000\099\000\099\000\099\000\099\000\099\000\099\000\
    \099\000\099\000\099\000\099\000\099\000\099\000\099\000\099\000\
    \099\000\099\000\099\000\099\000\099\000\099\000\099\000\099\000\
    \255\255\255\255\255\255\099\000\099\000\255\255\099\000\099\000\
    \099\000\099\000\099\000\099\000\099\000\099\000\099\000\099\000\
    \099\000\099\000\099\000\099\000\099\000\099\000\099\000\099\000\
    \099\000\099\000\099\000\099\000\099\000\099\000\099\000\099\000\
    \255\255\100\000\255\255\099\000\100\000\100\000\100\000\255\255\
    \255\255\255\255\100\000\100\000\255\255\100\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\255\255\255\255\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\255\255\255\255\255\255\100\000\100\000\
    \255\255\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\255\255\101\000\255\255\100\000\101\000\
    \101\000\101\000\255\255\255\255\255\255\101\000\101\000\255\255\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\255\255\255\255\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\255\255\255\255\
    \255\255\101\000\101\000\255\255\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\255\255\102\000\
    \255\255\101\000\102\000\102\000\102\000\255\255\255\255\255\255\
    \102\000\102\000\255\255\102\000\102\000\102\000\102\000\102\000\
    \102\000\102\000\102\000\102\000\102\000\102\000\102\000\102\000\
    \255\255\255\255\102\000\102\000\102\000\102\000\102\000\102\000\
    \102\000\102\000\102\000\102\000\102\000\102\000\102\000\102\000\
    \102\000\102\000\102\000\102\000\102\000\102\000\102\000\102\000\
    \102\000\102\000\102\000\102\000\102\000\102\000\102\000\102\000\
    \102\000\255\255\255\255\255\255\102\000\102\000\255\255\102\000\
    \102\000\102\000\102\000\102\000\102\000\102\000\102\000\102\000\
    \102\000\102\000\102\000\102\000\102\000\102\000\102\000\102\000\
    \102\000\102\000\102\000\102\000\102\000\102\000\102\000\102\000\
    \102\000\255\255\103\000\255\255\102\000\103\000\103\000\103\000\
    \255\255\255\255\255\255\103\000\103\000\255\255\103\000\103\000\
    \103\000\103\000\103\000\103\000\103\000\103\000\103\000\103\000\
    \103\000\103\000\103\000\255\255\255\255\103\000\103\000\103\000\
    \103\000\103\000\103\000\103\000\103\000\103\000\103\000\103\000\
    \103\000\103\000\103\000\103\000\103\000\103\000\103\000\103\000\
    \103\000\103\000\103\000\103\000\103\000\103\000\103\000\103\000\
    \103\000\103\000\103\000\103\000\255\255\255\255\255\255\103\000\
    \103\000\255\255\103\000\103\000\103\000\103\000\103\000\103\000\
    \103\000\103\000\103\000\103\000\103\000\103\000\103\000\103\000\
    \103\000\103\000\103\000\103\000\103\000\103\000\103\000\103\000\
    \103\000\103\000\103\000\103\000\255\255\104\000\255\255\103\000\
    \104\000\104\000\104\000\255\255\255\255\255\255\104\000\104\000\
    \255\255\104\000\104\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\255\255\255\255\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\255\255\
    \255\255\255\255\104\000\104\000\255\255\104\000\104\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\255\255\
    \105\000\255\255\104\000\105\000\105\000\105\000\255\255\255\255\
    \255\255\105\000\105\000\255\255\105\000\105\000\105\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\255\255\255\255\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\255\255\255\255\255\255\105\000\105\000\255\255\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\255\255\106\000\255\255\105\000\106\000\106\000\
    \106\000\255\255\255\255\255\255\106\000\106\000\255\255\106\000\
    \106\000\106\000\106\000\106\000\106\000\106\000\106\000\106\000\
    \106\000\106\000\106\000\106\000\255\255\255\255\106\000\106\000\
    \106\000\106\000\106\000\106\000\106\000\106\000\106\000\106\000\
    \106\000\106\000\106\000\106\000\106\000\106\000\106\000\106\000\
    \106\000\106\000\106\000\106\000\106\000\106\000\106\000\106\000\
    \106\000\106\000\106\000\106\000\106\000\255\255\255\255\255\255\
    \106\000\106\000\255\255\106\000\106\000\106\000\106\000\106\000\
    \106\000\106\000\106\000\106\000\106\000\106\000\106\000\106\000\
    \106\000\106\000\106\000\106\000\106\000\106\000\106\000\106\000\
    \106\000\106\000\106\000\106\000\106\000\255\255\107\000\255\255\
    \106\000\107\000\107\000\107\000\255\255\255\255\255\255\107\000\
    \107\000\255\255\107\000\107\000\107\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\107\000\107\000\107\000\107\000\255\255\
    \255\255\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \255\255\255\255\255\255\107\000\107\000\255\255\107\000\107\000\
    \107\000\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \255\255\108\000\255\255\107\000\108\000\108\000\108\000\255\255\
    \255\255\255\255\108\000\108\000\255\255\108\000\108\000\108\000\
    \108\000\108\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \108\000\108\000\255\255\255\255\108\000\108\000\108\000\108\000\
    \108\000\108\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \108\000\108\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \108\000\108\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \108\000\108\000\108\000\255\255\255\255\255\255\108\000\108\000\
    \255\255\108\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \108\000\108\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \108\000\108\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \108\000\108\000\108\000\255\255\109\000\255\255\108\000\109\000\
    \109\000\109\000\255\255\255\255\255\255\109\000\109\000\255\255\
    \109\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\109\000\109\000\255\255\255\255\109\000\
    \109\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\109\000\109\000\109\000\255\255\255\255\
    \255\255\109\000\109\000\255\255\109\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\109\000\109\000\109\000\255\255\110\000\
    \255\255\109\000\110\000\110\000\110\000\255\255\255\255\255\255\
    \110\000\110\000\255\255\110\000\110\000\110\000\110\000\110\000\
    \110\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \255\255\255\255\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\255\255\255\255\255\255\110\000\110\000\255\255\110\000\
    \110\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\255\255\111\000\255\255\110\000\111\000\111\000\111\000\
    \255\255\255\255\255\255\111\000\111\000\255\255\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\255\255\255\255\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\255\255\255\255\255\255\111\000\
    \111\000\255\255\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\255\255\112\000\255\255\111\000\
    \112\000\112\000\112\000\255\255\255\255\255\255\112\000\112\000\
    \255\255\112\000\112\000\112\000\112\000\112\000\112\000\112\000\
    \112\000\112\000\112\000\112\000\112\000\112\000\255\255\255\255\
    \112\000\112\000\112\000\112\000\112\000\112\000\112\000\112\000\
    \112\000\112\000\112\000\112\000\112\000\112\000\112\000\112\000\
    \112\000\112\000\112\000\112\000\112\000\112\000\112\000\112\000\
    \112\000\112\000\112\000\112\000\112\000\112\000\112\000\255\255\
    \255\255\255\255\112\000\112\000\255\255\112\000\112\000\112\000\
    \112\000\112\000\112\000\112\000\112\000\112\000\112\000\112\000\
    \112\000\112\000\112\000\112\000\112\000\112\000\112\000\112\000\
    \112\000\112\000\112\000\112\000\112\000\112\000\112\000\255\255\
    \113\000\255\255\112\000\113\000\113\000\113\000\255\255\255\255\
    \255\255\113\000\113\000\255\255\113\000\113\000\113\000\113\000\
    \113\000\113\000\113\000\113\000\113\000\113\000\113\000\113\000\
    \113\000\255\255\255\255\113\000\113\000\113\000\113\000\113\000\
    \113\000\113\000\113\000\113\000\113\000\113\000\113\000\113\000\
    \113\000\113\000\113\000\113\000\113\000\113\000\113\000\113\000\
    \113\000\113\000\113\000\113\000\113\000\113\000\113\000\113\000\
    \113\000\113\000\255\255\255\255\255\255\113\000\113\000\255\255\
    \113\000\113\000\113\000\113\000\113\000\113\000\113\000\113\000\
    \113\000\113\000\113\000\113\000\113\000\113\000\113\000\113\000\
    \113\000\113\000\113\000\113\000\113\000\113\000\113\000\113\000\
    \113\000\113\000\255\255\114\000\255\255\113\000\114\000\114\000\
    \114\000\255\255\255\255\255\255\114\000\114\000\255\255\114\000\
    \114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\255\255\255\255\114\000\114\000\
    \114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\114\000\255\255\255\255\255\255\
    \114\000\114\000\255\255\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\114\000\255\255\115\000\255\255\
    \114\000\115\000\115\000\115\000\255\255\255\255\255\255\115\000\
    \115\000\255\255\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\255\255\
    \255\255\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \255\255\255\255\255\255\115\000\115\000\255\255\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \255\255\116\000\255\255\115\000\116\000\116\000\116\000\255\255\
    \255\255\255\255\116\000\116\000\255\255\116\000\116\000\116\000\
    \116\000\116\000\116\000\116\000\116\000\116\000\116\000\116\000\
    \116\000\116\000\255\255\255\255\116\000\116\000\116\000\116\000\
    \116\000\116\000\116\000\116\000\116\000\116\000\116\000\116\000\
    \116\000\116\000\116\000\116\000\116\000\116\000\116\000\116\000\
    \116\000\116\000\116\000\116\000\116\000\116\000\116\000\116\000\
    \116\000\116\000\116\000\255\255\255\255\255\255\116\000\116\000\
    \255\255\116\000\116\000\116\000\116\000\116\000\116\000\116\000\
    \116\000\116\000\116\000\116\000\116\000\116\000\116\000\116\000\
    \116\000\116\000\116\000\116\000\116\000\116\000\116\000\116\000\
    \116\000\116\000\116\000\255\255\117\000\255\255\116\000\117\000\
    \117\000\117\000\255\255\255\255\255\255\117\000\117\000\255\255\
    \117\000\117\000\117\000\117\000\117\000\117\000\117\000\117\000\
    \117\000\117\000\117\000\117\000\117\000\255\255\255\255\117\000\
    \117\000\117\000\117\000\117\000\117\000\117\000\117\000\117\000\
    \117\000\117\000\117\000\117\000\117\000\117\000\117\000\117\000\
    \117\000\117\000\117\000\117\000\117\000\117\000\117\000\117\000\
    \117\000\117\000\117\000\117\000\117\000\117\000\255\255\255\255\
    \255\255\117\000\117\000\255\255\117\000\117\000\117\000\117\000\
    \117\000\117\000\117\000\117\000\117\000\117\000\117\000\117\000\
    \117\000\117\000\117\000\117\000\117\000\117\000\117\000\117\000\
    \117\000\117\000\117\000\117\000\117\000\117\000\255\255\118\000\
    \255\255\117\000\118\000\118\000\118\000\255\255\255\255\255\255\
    \118\000\118\000\255\255\118\000\118\000\118\000\118\000\118\000\
    \118\000\118\000\118\000\118\000\118\000\118\000\118\000\118\000\
    \255\255\255\255\118\000\118\000\118\000\118\000\118\000\118\000\
    \118\000\118\000\118\000\118\000\118\000\118\000\118\000\118\000\
    \118\000\118\000\118\000\118\000\118\000\118\000\118\000\118\000\
    \118\000\118\000\118\000\118\000\118\000\118\000\118\000\118\000\
    \118\000\255\255\255\255\255\255\118\000\118\000\255\255\118\000\
    \118\000\118\000\118\000\118\000\118\000\118\000\118\000\118\000\
    \118\000\118\000\118\000\118\000\118\000\118\000\118\000\118\000\
    \118\000\118\000\118\000\118\000\118\000\118\000\118\000\118\000\
    \118\000\255\255\119\000\255\255\118\000\119\000\119\000\119\000\
    \255\255\255\255\255\255\119\000\119\000\255\255\119\000\119\000\
    \119\000\119\000\119\000\119\000\119\000\119\000\119\000\119\000\
    \119\000\119\000\119\000\255\255\255\255\119\000\119\000\119\000\
    \119\000\119\000\119\000\119\000\119\000\119\000\119\000\119\000\
    \119\000\119\000\119\000\119\000\119\000\119\000\119\000\119\000\
    \119\000\119\000\119\000\119\000\119\000\119\000\119\000\119\000\
    \119\000\119\000\119\000\119\000\255\255\255\255\255\255\119\000\
    \119\000\255\255\119\000\119\000\119\000\119\000\119\000\119\000\
    \119\000\119\000\119\000\119\000\119\000\119\000\119\000\119\000\
    \119\000\119\000\119\000\119\000\119\000\119\000\119\000\119\000\
    \119\000\119\000\119\000\119\000\255\255\120\000\255\255\119\000\
    \120\000\120\000\120\000\255\255\255\255\255\255\120\000\120\000\
    \255\255\120\000\120\000\120\000\120\000\120\000\120\000\120\000\
    \120\000\120\000\120\000\120\000\120\000\120\000\255\255\255\255\
    \120\000\120\000\120\000\120\000\120\000\120\000\120\000\120\000\
    \120\000\120\000\120\000\120\000\120\000\120\000\120\000\120\000\
    \120\000\120\000\120\000\120\000\120\000\120\000\120\000\120\000\
    \120\000\120\000\120\000\120\000\120\000\120\000\120\000\255\255\
    \255\255\255\255\120\000\120\000\255\255\120\000\120\000\120\000\
    \120\000\120\000\120\000\120\000\120\000\120\000\120\000\120\000\
    \120\000\120\000\120\000\120\000\120\000\120\000\120\000\120\000\
    \120\000\120\000\120\000\120\000\120\000\120\000\120\000\255\255\
    \121\000\255\255\120\000\121\000\121\000\121\000\255\255\255\255\
    \255\255\121\000\121\000\255\255\121\000\121\000\121\000\121\000\
    \121\000\121\000\121\000\121\000\121\000\121\000\121\000\121\000\
    \121\000\255\255\255\255\121\000\121\000\121\000\121\000\121\000\
    \121\000\121\000\121\000\121\000\121\000\121\000\121\000\121\000\
    \121\000\121\000\121\000\121\000\121\000\121\000\121\000\121\000\
    \121\000\121\000\121\000\121\000\121\000\121\000\121\000\121\000\
    \121\000\121\000\255\255\255\255\255\255\121\000\121\000\255\255\
    \121\000\121\000\121\000\121\000\121\000\121\000\121\000\121\000\
    \121\000\121\000\121\000\121\000\121\000\121\000\121\000\121\000\
    \121\000\121\000\121\000\121\000\121\000\121\000\121\000\121\000\
    \121\000\121\000\255\255\122\000\255\255\121\000\122\000\122\000\
    \122\000\255\255\255\255\255\255\122\000\122\000\255\255\122\000\
    \122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\122\000\255\255\255\255\122\000\122\000\
    \122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\122\000\122\000\255\255\255\255\255\255\
    \122\000\122\000\255\255\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\122\000\122\000\255\255\123\000\255\255\
    \122\000\123\000\123\000\123\000\255\255\255\255\255\255\123\000\
    \123\000\255\255\123\000\123\000\123\000\123\000\123\000\123\000\
    \123\000\123\000\123\000\123\000\123\000\123\000\123\000\255\255\
    \255\255\123\000\123\000\123\000\123\000\123\000\123\000\123\000\
    \123\000\123\000\123\000\123\000\123\000\123\000\123\000\123\000\
    \123\000\123\000\123\000\123\000\123\000\123\000\123\000\123\000\
    \123\000\123\000\123\000\123\000\123\000\123\000\123\000\123\000\
    \255\255\255\255\255\255\123\000\123\000\255\255\123\000\123\000\
    \123\000\123\000\123\000\123\000\123\000\123\000\123\000\123\000\
    \123\000\123\000\123\000\123\000\123\000\123\000\123\000\123\000\
    \123\000\123\000\123\000\123\000\123\000\123\000\123\000\123\000\
    \255\255\124\000\255\255\123\000\124\000\124\000\124\000\255\255\
    \255\255\255\255\124\000\124\000\255\255\124\000\124\000\124\000\
    \124\000\124\000\124\000\124\000\124\000\124\000\124\000\124\000\
    \124\000\124\000\255\255\255\255\124\000\124\000\124\000\124\000\
    \124\000\124\000\124\000\124\000\124\000\124\000\124\000\124\000\
    \124\000\124\000\124\000\124\000\124\000\124\000\124\000\124\000\
    \124\000\124\000\124\000\124\000\124\000\124\000\124\000\124\000\
    \124\000\124\000\124\000\255\255\255\255\255\255\124\000\124\000\
    \255\255\124\000\124\000\124\000\124\000\124\000\124\000\124\000\
    \124\000\124\000\124\000\124\000\124\000\124\000\124\000\124\000\
    \124\000\124\000\124\000\124\000\124\000\124\000\124\000\124\000\
    \124\000\124\000\124\000\255\255\125\000\255\255\124\000\125\000\
    \125\000\125\000\255\255\255\255\255\255\125\000\125\000\255\255\
    \125\000\125\000\125\000\125\000\125\000\125\000\125\000\125\000\
    \125\000\125\000\125\000\125\000\125\000\255\255\255\255\125\000\
    \125\000\125\000\125\000\125\000\125\000\125\000\125\000\125\000\
    \125\000\125\000\125\000\125\000\125\000\125\000\125\000\125\000\
    \125\000\125\000\125\000\125\000\125\000\125\000\125\000\125\000\
    \125\000\125\000\125\000\125\000\125\000\125\000\255\255\255\255\
    \255\255\125\000\125\000\255\255\125\000\125\000\125\000\125\000\
    \125\000\125\000\125\000\125\000\125\000\125\000\125\000\125\000\
    \125\000\125\000\125\000\125\000\125\000\125\000\125\000\125\000\
    \125\000\125\000\125\000\125\000\125\000\125\000\255\255\126\000\
    \255\255\125\000\126\000\126\000\126\000\255\255\255\255\255\255\
    \126\000\126\000\255\255\126\000\126\000\126\000\126\000\126\000\
    \126\000\126\000\126\000\126\000\126\000\126\000\126\000\126\000\
    \255\255\255\255\126\000\126\000\126\000\126\000\126\000\126\000\
    \126\000\126\000\126\000\126\000\126\000\126\000\126\000\126\000\
    \126\000\126\000\126\000\126\000\126\000\126\000\126\000\126\000\
    \126\000\126\000\126\000\126\000\126\000\126\000\126\000\126\000\
    \126\000\255\255\255\255\255\255\126\000\126\000\255\255\126\000\
    \126\000\126\000\126\000\126\000\126\000\126\000\126\000\126\000\
    \126\000\126\000\126\000\126\000\126\000\126\000\126\000\126\000\
    \126\000\126\000\126\000\126\000\126\000\126\000\126\000\126\000\
    \126\000\255\255\127\000\255\255\126\000\127\000\127\000\127\000\
    \255\255\255\255\255\255\127\000\127\000\255\255\127\000\127\000\
    \127\000\127\000\127\000\127\000\127\000\127\000\127\000\127\000\
    \127\000\127\000\127\000\255\255\255\255\127\000\127\000\127\000\
    \127\000\127\000\127\000\127\000\127\000\127\000\127\000\127\000\
    \127\000\127\000\127\000\127\000\127\000\127\000\127\000\127\000\
    \127\000\127\000\127\000\127\000\127\000\127\000\127\000\127\000\
    \127\000\127\000\127\000\127\000\255\255\255\255\255\255\127\000\
    \127\000\255\255\127\000\127\000\127\000\127\000\127\000\127\000\
    \127\000\127\000\127\000\127\000\127\000\127\000\127\000\127\000\
    \127\000\127\000\127\000\127\000\127\000\127\000\127\000\127\000\
    \127\000\127\000\127\000\127\000\255\255\128\000\255\255\127\000\
    \128\000\128\000\128\000\255\255\255\255\255\255\128\000\128\000\
    \255\255\128\000\128\000\128\000\128\000\128\000\128\000\128\000\
    \128\000\128\000\128\000\128\000\128\000\128\000\255\255\255\255\
    \128\000\128\000\128\000\128\000\128\000\128\000\128\000\128\000\
    \128\000\128\000\128\000\128\000\128\000\128\000\128\000\128\000\
    \128\000\128\000\128\000\128\000\128\000\128\000\128\000\128\000\
    \128\000\128\000\128\000\128\000\128\000\128\000\128\000\255\255\
    \255\255\255\255\128\000\128\000\255\255\128\000\128\000\128\000\
    \128\000\128\000\128\000\128\000\128\000\128\000\128\000\128\000\
    \128\000\128\000\128\000\128\000\128\000\128\000\128\000\128\000\
    \128\000\128\000\128\000\128\000\128\000\128\000\128\000\255\255\
    \129\000\255\255\128\000\129\000\129\000\129\000\255\255\255\255\
    \255\255\129\000\129\000\255\255\129\000\129\000\129\000\129\000\
    \129\000\129\000\129\000\129\000\129\000\129\000\129\000\129\000\
    \129\000\255\255\255\255\129\000\129\000\129\000\129\000\129\000\
    \129\000\129\000\129\000\129\000\129\000\129\000\129\000\129\000\
    \129\000\129\000\129\000\129\000\129\000\129\000\129\000\129\000\
    \129\000\129\000\129\000\129\000\129\000\129\000\129\000\129\000\
    \129\000\129\000\255\255\255\255\255\255\129\000\129\000\255\255\
    \129\000\129\000\129\000\129\000\129\000\129\000\129\000\129\000\
    \129\000\129\000\129\000\129\000\129\000\129\000\129\000\129\000\
    \129\000\129\000\129\000\129\000\129\000\129\000\129\000\129\000\
    \129\000\129\000\255\255\130\000\255\255\129\000\130\000\130\000\
    \130\000\255\255\255\255\255\255\130\000\130\000\255\255\130\000\
    \130\000\130\000\130\000\130\000\130\000\130\000\130\000\130\000\
    \130\000\130\000\130\000\130\000\255\255\255\255\130\000\130\000\
    \130\000\130\000\130\000\130\000\130\000\130\000\130\000\130\000\
    \130\000\130\000\130\000\130\000\130\000\130\000\130\000\130\000\
    \130\000\130\000\130\000\130\000\130\000\130\000\130\000\130\000\
    \130\000\130\000\130\000\130\000\130\000\255\255\255\255\255\255\
    \130\000\130\000\255\255\130\000\130\000\130\000\130\000\130\000\
    \130\000\130\000\130\000\130\000\130\000\130\000\130\000\130\000\
    \130\000\130\000\130\000\130\000\130\000\130\000\130\000\130\000\
    \130\000\130\000\130\000\130\000\130\000\255\255\131\000\255\255\
    \130\000\131\000\131\000\131\000\255\255\255\255\255\255\131\000\
    \131\000\255\255\131\000\131\000\131\000\131\000\131\000\131\000\
    \131\000\131\000\131\000\131\000\131\000\131\000\131\000\255\255\
    \255\255\131\000\131\000\131\000\131\000\131\000\131\000\131\000\
    \131\000\131\000\131\000\131\000\131\000\131\000\131\000\131\000\
    \131\000\131\000\131\000\131\000\131\000\131\000\131\000\131\000\
    \131\000\131\000\131\000\131\000\131\000\131\000\131\000\131\000\
    \255\255\255\255\255\255\131\000\131\000\255\255\131\000\131\000\
    \131\000\131\000\131\000\131\000\131\000\131\000\131\000\131\000\
    \131\000\131\000\131\000\131\000\131\000\131\000\131\000\131\000\
    \131\000\131\000\131\000\131\000\131\000\131\000\131\000\131\000\
    \255\255\132\000\255\255\131\000\132\000\132\000\132\000\255\255\
    \255\255\255\255\132\000\132\000\255\255\132\000\132\000\132\000\
    \132\000\132\000\132\000\132\000\132\000\132\000\132\000\132\000\
    \132\000\132\000\255\255\255\255\132\000\132\000\132\000\132\000\
    \132\000\132\000\132\000\132\000\132\000\132\000\132\000\132\000\
    \132\000\132\000\132\000\132\000\132\000\132\000\132\000\132\000\
    \132\000\132\000\132\000\132\000\132\000\132\000\132\000\132\000\
    \132\000\132\000\132\000\255\255\255\255\255\255\132\000\132\000\
    \255\255\132\000\132\000\132\000\132\000\132\000\132\000\132\000\
    \132\000\132\000\132\000\132\000\132\000\132\000\132\000\132\000\
    \132\000\132\000\132\000\132\000\132\000\132\000\132\000\132\000\
    \132\000\132\000\132\000\255\255\133\000\255\255\132\000\133\000\
    \133\000\133\000\255\255\255\255\255\255\133\000\133\000\255\255\
    \133\000\133\000\133\000\133\000\133\000\133\000\133\000\133\000\
    \133\000\133\000\133\000\133\000\133\000\255\255\255\255\133\000\
    \133\000\133\000\133\000\133\000\133\000\133\000\133\000\133\000\
    \133\000\133\000\133\000\133\000\133\000\133\000\133\000\133\000\
    \133\000\133\000\133\000\133\000\133\000\133\000\133\000\133\000\
    \133\000\133\000\133\000\133\000\133\000\133\000\255\255\255\255\
    \255\255\133\000\133\000\255\255\133\000\133\000\133\000\133\000\
    \133\000\133\000\133\000\133\000\133\000\133\000\133\000\133\000\
    \133\000\133\000\133\000\133\000\133\000\133\000\133\000\133\000\
    \133\000\133\000\133\000\133\000\133\000\133\000\255\255\134\000\
    \255\255\133\000\134\000\134\000\134\000\255\255\255\255\255\255\
    \134\000\134\000\255\255\134\000\134\000\134\000\134\000\134\000\
    \134\000\134\000\134\000\134\000\134\000\134\000\134\000\134\000\
    \255\255\255\255\134\000\134\000\134\000\134\000\134\000\134\000\
    \134\000\134\000\134\000\134\000\134\000\134\000\134\000\134\000\
    \134\000\134\000\134\000\134\000\134\000\134\000\134\000\134\000\
    \134\000\134\000\134\000\134\000\134\000\134\000\134\000\134\000\
    \134\000\255\255\255\255\255\255\134\000\134\000\255\255\134\000\
    \134\000\134\000\134\000\134\000\134\000\134\000\134\000\134\000\
    \134\000\134\000\134\000\134\000\134\000\134\000\134\000\134\000\
    \134\000\134\000\134\000\134\000\134\000\134\000\134\000\134\000\
    \134\000\255\255\135\000\255\255\134\000\135\000\135\000\135\000\
    \255\255\255\255\255\255\135\000\135\000\255\255\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\255\255\255\255\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\255\255\255\255\255\255\135\000\
    \135\000\255\255\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\255\255\136\000\255\255\135\000\
    \136\000\136\000\136\000\255\255\255\255\255\255\136\000\136\000\
    \255\255\136\000\136\000\136\000\136\000\136\000\136\000\136\000\
    \136\000\136\000\136\000\136\000\136\000\136\000\255\255\255\255\
    \136\000\136\000\136\000\136\000\136\000\136\000\136\000\136\000\
    \136\000\136\000\136\000\136\000\136\000\136\000\136\000\136\000\
    \136\000\136\000\136\000\136\000\136\000\136\000\136\000\136\000\
    \136\000\136\000\136\000\136\000\136\000\136\000\136\000\255\255\
    \255\255\255\255\136\000\136\000\255\255\136\000\136\000\136\000\
    \136\000\136\000\136\000\136\000\136\000\136\000\136\000\136\000\
    \136\000\136\000\136\000\136\000\136\000\136\000\136\000\136\000\
    \136\000\136\000\136\000\136\000\136\000\136\000\136\000\255\255\
    \137\000\255\255\136\000\137\000\137\000\137\000\255\255\255\255\
    \255\255\137\000\137\000\255\255\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\255\255\255\255\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\255\255\255\255\255\255\137\000\137\000\255\255\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\255\255\138\000\255\255\137\000\138\000\138\000\
    \138\000\255\255\255\255\255\255\138\000\138\000\255\255\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\255\255\255\255\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\255\255\255\255\255\255\
    \138\000\138\000\255\255\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\255\255\139\000\255\255\
    \138\000\139\000\139\000\139\000\255\255\255\255\255\255\139\000\
    \139\000\255\255\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\255\255\
    \255\255\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \255\255\255\255\255\255\139\000\139\000\255\255\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \255\255\140\000\255\255\139\000\140\000\140\000\140\000\255\255\
    \255\255\255\255\140\000\140\000\255\255\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\255\255\255\255\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\255\255\255\255\255\255\140\000\140\000\
    \255\255\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\255\255\141\000\255\255\140\000\141\000\
    \141\000\141\000\255\255\255\255\255\255\141\000\141\000\255\255\
    \141\000\141\000\141\000\141\000\141\000\141\000\141\000\141\000\
    \141\000\141\000\141\000\141\000\141\000\255\255\255\255\141\000\
    \141\000\141\000\141\000\141\000\141\000\141\000\141\000\141\000\
    \141\000\141\000\141\000\141\000\141\000\141\000\141\000\141\000\
    \141\000\141\000\141\000\141\000\141\000\141\000\141\000\141\000\
    \141\000\141\000\141\000\141\000\141\000\141\000\255\255\255\255\
    \255\255\141\000\141\000\255\255\141\000\141\000\141\000\141\000\
    \141\000\141\000\141\000\141\000\141\000\141\000\141\000\141\000\
    \141\000\141\000\141\000\141\000\141\000\141\000\141\000\141\000\
    \141\000\141\000\141\000\141\000\141\000\141\000\255\255\142\000\
    \255\255\141\000\142\000\142\000\142\000\255\255\255\255\255\255\
    \142\000\142\000\255\255\142\000\142\000\142\000\142\000\142\000\
    \142\000\142\000\142\000\142\000\142\000\142\000\142\000\142\000\
    \255\255\255\255\142\000\142\000\142\000\142\000\142\000\142\000\
    \142\000\142\000\142\000\142\000\142\000\142\000\142\000\142\000\
    \142\000\142\000\142\000\142\000\142\000\142\000\142\000\142\000\
    \142\000\142\000\142\000\142\000\142\000\142\000\142\000\142\000\
    \142\000\255\255\255\255\255\255\142\000\142\000\255\255\142\000\
    \142\000\142\000\142\000\142\000\142\000\142\000\142\000\142\000\
    \142\000\142\000\142\000\142\000\142\000\142\000\142\000\142\000\
    \142\000\142\000\142\000\142\000\142\000\142\000\142\000\142\000\
    \142\000\255\255\143\000\255\255\142\000\143\000\143\000\143\000\
    \255\255\255\255\255\255\143\000\143\000\255\255\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\255\255\255\255\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\255\255\255\255\255\255\143\000\
    \143\000\255\255\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\255\255\144\000\255\255\143\000\
    \144\000\144\000\144\000\255\255\255\255\255\255\144\000\144\000\
    \255\255\144\000\144\000\144\000\144\000\144\000\144\000\144\000\
    \144\000\144\000\144\000\144\000\144\000\144\000\255\255\255\255\
    \144\000\144\000\144\000\144\000\144\000\144\000\144\000\144\000\
    \144\000\144\000\144\000\144\000\144\000\144\000\144\000\144\000\
    \144\000\144\000\144\000\144\000\144\000\144\000\144\000\144\000\
    \144\000\144\000\144\000\144\000\144\000\144\000\144\000\255\255\
    \255\255\255\255\144\000\144\000\255\255\144\000\144\000\144\000\
    \144\000\144\000\144\000\144\000\144\000\144\000\144\000\144\000\
    \144\000\144\000\144\000\144\000\144\000\144\000\144\000\144\000\
    \144\000\144\000\144\000\144\000\144\000\144\000\144\000\255\255\
    \145\000\255\255\144\000\145\000\145\000\145\000\255\255\255\255\
    \255\255\145\000\145\000\255\255\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\255\255\255\255\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\255\255\255\255\255\255\145\000\145\000\255\255\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\255\255\146\000\255\255\145\000\146\000\146\000\
    \146\000\255\255\255\255\255\255\146\000\146\000\255\255\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\255\255\255\255\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\255\255\255\255\255\255\
    \146\000\146\000\255\255\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\255\255\147\000\255\255\
    \146\000\147\000\147\000\147\000\255\255\255\255\255\255\147\000\
    \147\000\255\255\147\000\147\000\147\000\147\000\147\000\147\000\
    \147\000\147\000\147\000\147\000\147\000\147\000\147\000\255\255\
    \255\255\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
    \147\000\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
    \147\000\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
    \147\000\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
    \255\255\255\255\255\255\147\000\147\000\255\255\147\000\147\000\
    \147\000\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
    \147\000\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
    \147\000\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
    \255\255\148\000\255\255\147\000\148\000\148\000\148\000\255\255\
    \255\255\255\255\148\000\148\000\255\255\148\000\148\000\148\000\
    \148\000\148\000\148\000\148\000\148\000\148\000\148\000\148\000\
    \148\000\148\000\255\255\255\255\148\000\148\000\148\000\148\000\
    \148\000\148\000\148\000\148\000\148\000\148\000\148\000\148\000\
    \148\000\148\000\148\000\148\000\148\000\148\000\148\000\148\000\
    \148\000\148\000\148\000\148\000\148\000\148\000\148\000\148\000\
    \148\000\148\000\148\000\255\255\255\255\255\255\148\000\148\000\
    \255\255\148\000\148\000\148\000\148\000\148\000\148\000\148\000\
    \148\000\148\000\148\000\148\000\148\000\148\000\148\000\148\000\
    \148\000\148\000\148\000\148\000\148\000\148\000\148\000\148\000\
    \148\000\148\000\148\000\255\255\149\000\255\255\148\000\149\000\
    \149\000\149\000\255\255\255\255\255\255\149\000\149\000\255\255\
    \149\000\149\000\149\000\149\000\149\000\149\000\149\000\149\000\
    \149\000\149\000\149\000\149\000\149\000\255\255\255\255\149\000\
    \149\000\149\000\149\000\149\000\149\000\149\000\149\000\149\000\
    \149\000\149\000\149\000\149\000\149\000\149\000\149\000\149\000\
    \149\000\149\000\149\000\149\000\149\000\149\000\149\000\149\000\
    \149\000\149\000\149\000\149\000\149\000\149\000\255\255\255\255\
    \255\255\149\000\149\000\255\255\149\000\149\000\149\000\149\000\
    \149\000\149\000\149\000\149\000\149\000\149\000\149\000\149\000\
    \149\000\149\000\149\000\149\000\149\000\149\000\149\000\149\000\
    \149\000\149\000\149\000\149\000\149\000\149\000\255\255\150\000\
    \255\255\149\000\150\000\150\000\150\000\255\255\255\255\255\255\
    \150\000\150\000\255\255\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \255\255\255\255\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\255\255\255\255\255\255\150\000\150\000\255\255\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\255\255\255\255\255\255\150\000\152\000\152\000\152\000\
    \152\000\152\000\152\000\152\000\152\000\152\000\152\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\152\000\152\000\
    \152\000\152\000\152\000\152\000\153\000\153\000\153\000\153\000\
    \153\000\153\000\153\000\153\000\153\000\153\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\153\000\153\000\153\000\
    \153\000\153\000\153\000\255\255\255\255\255\255\152\000\152\000\
    \152\000\152\000\152\000\152\000\156\000\156\000\255\255\255\255\
    \156\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\153\000\153\000\153\000\
    \153\000\153\000\153\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\255\255\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\156\000\156\000\156\000\156\000\156\000\156\000\
    \156\000\156\000\157\000\255\255\255\255\157\000\157\000\157\000\
    \255\255\255\255\255\255\157\000\157\000\255\255\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\255\255\255\255\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\255\255\255\255\255\255\157\000\
    \157\000\255\255\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\159\000\159\000\255\255\157\000\
    \159\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\159\000\159\000\159\000\159\000\159\000\
    \159\000\159\000\159\000\159\000\159\000\159\000\159\000\159\000\
    \159\000\159\000\159\000\159\000\159\000\159\000\159\000\159\000\
    \159\000\159\000\159\000\159\000\159\000\159\000\159\000\159\000\
    \159\000\159\000\159\000\159\000\159\000\159\000\159\000\159\000\
    \159\000\159\000\159\000\159\000\159\000\159\000\159\000\159\000\
    \159\000\159\000\159\000\159\000\159\000\159\000\159\000\159\000\
    \159\000\159\000\159\000\159\000\159\000\159\000\159\000\159\000\
    \159\000\159\000\159\000\159\000\159\000\159\000\159\000\159\000\
    \159\000\159\000\159\000\159\000\159\000\159\000\159\000\159\000\
    \159\000\159\000\159\000\159\000\159\000\159\000\159\000\159\000\
    \159\000\159\000\159\000\159\000\159\000\159\000\159\000\159\000\
    \159\000\159\000\160\000\160\000\255\255\255\255\160\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255";
  Lexing.lex_base_code = 
   "";
  Lexing.lex_backtrk_code = 
   "";
  Lexing.lex_default_code = 
   "";
  Lexing.lex_trans_code = 
   "";
  Lexing.lex_check_code = 
   "";
  Lexing.lex_code = 
   "";
}

let rec token lexbuf =
  __ocaml_lex_token_rec lexbuf 0
and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 16 "smtlib2_lex.mll"
    ( token lexbuf )
# 3498 "smtlib2_lex.ml"

  | 1 ->
# 18 "smtlib2_lex.mll"
     ( token lexbuf )
# 3503 "smtlib2_lex.ml"

  | 2 ->
let
# 19 "smtlib2_lex.mll"
             str
# 3509 "smtlib2_lex.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 20 "smtlib2_lex.mll"
     ( newline lexbuf; 
       Smtlib2_util.line := (!Smtlib2_util.line + (String.length str));
       token lexbuf )
# 3515 "smtlib2_lex.ml"

  | 3 ->
# 23 "smtlib2_lex.mll"
                   ( UNDERSCORE )
# 3520 "smtlib2_lex.ml"

  | 4 ->
# 24 "smtlib2_lex.mll"
                   ( LPAREN )
# 3525 "smtlib2_lex.ml"

  | 5 ->
# 25 "smtlib2_lex.mll"
                   ( RPAREN )
# 3530 "smtlib2_lex.ml"

  | 6 ->
# 26 "smtlib2_lex.mll"
                   ( AS )
# 3535 "smtlib2_lex.ml"

  | 7 ->
# 27 "smtlib2_lex.mll"
                   ( LET )
# 3540 "smtlib2_lex.ml"

  | 8 ->
# 28 "smtlib2_lex.mll"
                   ( FORALL )
# 3545 "smtlib2_lex.ml"

  | 9 ->
# 29 "smtlib2_lex.mll"
                   ( EXISTS )
# 3550 "smtlib2_lex.ml"

  | 10 ->
# 30 "smtlib2_lex.mll"
                   ( EXCLIMATIONPT )
# 3555 "smtlib2_lex.ml"

  | 11 ->
# 31 "smtlib2_lex.mll"
                   ( SETLOGIC )
# 3560 "smtlib2_lex.ml"

  | 12 ->
# 32 "smtlib2_lex.mll"
                   ( SETOPTION )
# 3565 "smtlib2_lex.ml"

  | 13 ->
# 33 "smtlib2_lex.mll"
                   ( SETINFO )
# 3570 "smtlib2_lex.ml"

  | 14 ->
# 34 "smtlib2_lex.mll"
                   ( DECLARESORT )
# 3575 "smtlib2_lex.ml"

  | 15 ->
# 35 "smtlib2_lex.mll"
                   ( DEFINESORT )
# 3580 "smtlib2_lex.ml"

  | 16 ->
# 36 "smtlib2_lex.mll"
                   ( DECLAREFUN )
# 3585 "smtlib2_lex.ml"

  | 17 ->
# 37 "smtlib2_lex.mll"
                   ( DEFINEFUN )
# 3590 "smtlib2_lex.ml"

  | 18 ->
# 38 "smtlib2_lex.mll"
                   ( PUSH )
# 3595 "smtlib2_lex.ml"

  | 19 ->
# 39 "smtlib2_lex.mll"
                   ( POP )
# 3600 "smtlib2_lex.ml"

  | 20 ->
# 40 "smtlib2_lex.mll"
                   ( ASSERT )
# 3605 "smtlib2_lex.ml"

  | 21 ->
# 41 "smtlib2_lex.mll"
                   ( CHECKSAT )
# 3610 "smtlib2_lex.ml"

  | 22 ->
# 42 "smtlib2_lex.mll"
                   ( GETASSERT )
# 3615 "smtlib2_lex.ml"

  | 23 ->
# 43 "smtlib2_lex.mll"
                   ( GETPROOF )
# 3620 "smtlib2_lex.ml"

  | 24 ->
# 44 "smtlib2_lex.mll"
                   ( GETUNSATCORE )
# 3625 "smtlib2_lex.ml"

  | 25 ->
# 45 "smtlib2_lex.mll"
                   ( GETVALUE )
# 3630 "smtlib2_lex.ml"

  | 26 ->
# 46 "smtlib2_lex.mll"
                   ( GETASSIGN )
# 3635 "smtlib2_lex.ml"

  | 27 ->
# 47 "smtlib2_lex.mll"
                   ( GETOPTION )
# 3640 "smtlib2_lex.ml"

  | 28 ->
# 48 "smtlib2_lex.mll"
                   ( GETINFO )
# 3645 "smtlib2_lex.ml"

  | 29 ->
# 49 "smtlib2_lex.mll"
                   ( EXIT )
# 3650 "smtlib2_lex.ml"

  | 30 ->
let
# 50 "smtlib2_lex.mll"
                                          str
# 3656 "smtlib2_lex.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 51 "smtlib2_lex.mll"
    ( HEXADECIMAL(str) )
# 3660 "smtlib2_lex.ml"

  | 31 ->
let
# 52 "smtlib2_lex.mll"
                          str
# 3666 "smtlib2_lex.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 53 "smtlib2_lex.mll"
    ( BINARY(str) )
# 3670 "smtlib2_lex.ml"

  | 32 ->
let
# 54 "smtlib2_lex.mll"
                                                             str
# 3676 "smtlib2_lex.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 55 "smtlib2_lex.mll"
    ( ASCIIWOR(str) )
# 3680 "smtlib2_lex.ml"

  | 33 ->
let
# 56 "smtlib2_lex.mll"
                                                                                                          str
# 3686 "smtlib2_lex.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 57 "smtlib2_lex.mll"
    ( KEYWORD(str) )
# 3690 "smtlib2_lex.ml"

  | 34 ->
let
# 58 "smtlib2_lex.mll"
                                                                                                                                                                                          str
# 3696 "smtlib2_lex.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 59 "smtlib2_lex.mll"
    ( SYMBOL(str) )
# 3700 "smtlib2_lex.ml"

  | 35 ->
let
# 60 "smtlib2_lex.mll"
                                                                                                      str
# 3706 "smtlib2_lex.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 61 "smtlib2_lex.mll"
    ( STRINGLIT(str) )
# 3710 "smtlib2_lex.ml"

  | 36 ->
let
# 62 "smtlib2_lex.mll"
                                      str
# 3716 "smtlib2_lex.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 63 "smtlib2_lex.mll"
    ( NUMERAL(str) )
# 3720 "smtlib2_lex.ml"

  | 37 ->
let
# 64 "smtlib2_lex.mll"
                                                    str
# 3726 "smtlib2_lex.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 65 "smtlib2_lex.mll"
    ( DECIMAL(str) )
# 3730 "smtlib2_lex.ml"

  | 38 ->
# 67 "smtlib2_lex.mll"
    ( EOF )
# 3735 "smtlib2_lex.ml"

  | 39 ->
# 69 "smtlib2_lex.mll"
    (failwith(
      (Lexing.lexeme lexbuf) ^
	": lexing error on line "^(string_of_int !Smtlib2_util.line)))
# 3742 "smtlib2_lex.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_token_rec lexbuf __ocaml_lex_state

;;

end
include (IMPLEMENTATION : INTERFACE)
end
and Smtlib2_to_why: sig
#0 "smtlib2_to_why.mli"
exception Not_Implemented
val num0 : Num.num
val num10 : Num.num
val decnumber : string -> Num.num
module M :
  sig
    type key = String.t
    type 'a t = 'a Map.Make(String).t
    val empty : 'a t
    val is_empty : 'a t -> bool
    val mem : key -> 'a t -> bool
    val add : key -> 'a -> 'a t -> 'a t
    val singleton : key -> 'a -> 'a t
    val remove : key -> 'a t -> 'a t
    val merge :
      (key -> 'a option -> 'b option -> 'c option) -> 'a t -> 'b t -> 'c t
    val compare : ('a -> 'a -> int) -> 'a t -> 'a t -> int
    val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
    val iter : (key -> 'a -> unit) -> 'a t -> unit
    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
    val for_all : (key -> 'a -> bool) -> 'a t -> bool
    val exists : (key -> 'a -> bool) -> 'a t -> bool
    val filter : (key -> 'a -> bool) -> 'a t -> 'a t
    val partition : (key -> 'a -> bool) -> 'a t -> 'a t * 'a t
    val cardinal : 'a t -> int
    val bindings : 'a t -> (key * 'a) list
    val min_binding : 'a t -> key * 'a
    val max_binding : 'a t -> key * 'a
    val choose : 'a t -> key * 'a
    val split : key -> 'a t -> 'a t * 'a option * 'a t
    val find : key -> 'a t -> 'a
    val map : ('a -> 'b) -> 'a t -> 'b t
    val mapi : (key -> 'a -> 'b) -> 'a t -> 'b t
  end
module MString :
  sig
    type key = string
    type +'a t
    val empty : 'a t
    val is_empty : 'a t -> bool
    val mem : key -> 'a t -> bool
    val add : key -> 'a -> 'a t -> 'a t
    val singleton : key -> 'a -> 'a t
    val remove : key -> 'a t -> 'a t
    val merge :
      (key -> 'a option -> 'b option -> 'c option) -> 'a t -> 'b t -> 'c t
    val compare : ('a -> 'a -> int) -> 'a t -> 'a t -> int
    val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
    val iter : (key -> 'a -> unit) -> 'a t -> unit
    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
    val for_all : (key -> 'a -> bool) -> 'a t -> bool
    val exists : (key -> 'a -> bool) -> 'a t -> bool
    val filter : (key -> 'a -> bool) -> 'a t -> 'a t
    val partition : (key -> 'a -> bool) -> 'a t -> 'a t * 'a t
    val cardinal : 'a t -> int
    val bindings : 'a t -> (key * 'a) list
    val min_binding : 'a t -> key * 'a
    val max_binding : 'a t -> key * 'a
    val choose : 'a t -> key * 'a
    val split : key -> 'a t -> 'a t * 'a option * 'a t
    val find : key -> 'a t -> 'a
    val map : ('a -> 'b) -> 'a t -> 'b t
    val mapi : (key -> 'a -> 'b) -> 'a t -> 'b t
  end
module S :
  sig
    type elt = String.t
    type t = Set.Make(String).t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val singleton : elt -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : (elt -> unit) -> t -> unit
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val for_all : (elt -> bool) -> t -> bool
    val exists : (elt -> bool) -> t -> bool
    val filter : (elt -> bool) -> t -> t
    val partition : (elt -> bool) -> t -> t * t
    val cardinal : t -> int
    val elements : t -> elt list
    val min_elt : t -> elt
    val max_elt : t -> elt
    val choose : t -> elt
    val split : elt -> t -> t * bool * t
  end
val predicates : S.t
val const_of_specconstant : Smtlib2_ast.specconstant -> Why_ptree.constant
val string_of_symbol : Smtlib2_ast.symbol -> string
val stringi_of_identifier : Smtlib2_ast.identifier -> string * int option
val ppure_type_of_sort : Smtlib2_ast.sort -> Why_ptree.ppure_type
val stringi_of_qualidentifier :
  Smtlib2_ast.qualidentifier -> string * int option
val stringppt_of_sortedvar :
  Smtlib2_ast.sortedvar -> string * Why_ptree.ppure_type
val infix_of_string : string -> Why_ptree.pp_infix option
val prefix_of_string : string -> Why_ptree.pp_prefix option
val inline_lexpr :
  string ->
  Why_ptree.lexpr -> string list -> Why_ptree.lexpr -> Why_ptree.lexpr
val inline_ppdesc :
  string ->
  Why_ptree.lexpr -> string list -> Why_ptree.pp_desc -> Why_ptree.pp_desc
val is_prop : S.t -> S.elt list -> Why_ptree.lexpr -> bool
val stringlexpr_of_varbinding :
  S.t -> Smtlib2_ast.varbinding -> S.elt * Why_ptree.lexpr
val ppdesc_of_sexpr : Smtlib2_ast.sexpr -> Why_ptree.pp_desc
val lexpr_of_sexpr : Smtlib2_ast.sexpr -> Why_ptree.lexpr
val triggers_of_attributelist :
  Smtlib2_ast.attribute list -> Why_ptree.lexpr list list
val ppinfix_alist :
  S.t ->
  Why_ptree.loc ->
  Why_ptree.pp_infix ->
  Smtlib2_ast.term list ->
  (Smtlib2_ast.term -> Why_ptree.lexpr) -> Why_ptree.pp_desc
val ppinfix_termlist :
  S.t ->
  Why_ptree.loc ->
  Why_ptree.pp_infix -> Smtlib2_ast.term list -> Why_ptree.pp_desc
val ppinfix_blist :
  S.t ->
  Why_ptree.loc ->
  Why_ptree.pp_infix ->
  Smtlib2_ast.sexpr list ->
  (Smtlib2_ast.sexpr -> Why_ptree.lexpr) -> Why_ptree.pp_desc
val ppinfix_sexprlist :
  Smtlib2_ast.loc ->
  Why_ptree.pp_infix -> Smtlib2_ast.sexpr list -> Why_ptree.pp_desc
val let_of_varbindinglist :
  S.t ->
  Why_ptree.loc ->
  Smtlib2_ast.term -> Smtlib2_ast.varbinding list -> Why_ptree.pp_desc
val forall_of_sortedvarlist :
  Why_ptree.loc ->
  Smtlib2_ast.term ->
  Why_ptree.lexpr list list ->
  Smtlib2_ast.sortedvar list -> Why_ptree.pp_desc
val exists_of_sortedvarlist :
  Why_ptree.loc ->
  Smtlib2_ast.term -> Smtlib2_ast.sortedvar list -> Why_ptree.pp_desc
val ppapp_of_string :
  Why_ptree.loc ->
  string -> Smtlib2_ast.term list -> S.t -> Why_ptree.pp_desc
val ppconstvar_of_string : string -> Why_ptree.pp_desc
val ppdesc_of_term : S.t -> Smtlib2_ast.term -> Why_ptree.pp_desc
val lexpr_of_term : S.t -> Smtlib2_ast.term -> Why_ptree.lexpr
val last_axiom_to_goal :
  Why_ptree.loc ->
  Why_ptree.decl list -> Why_ptree.decl list -> Why_ptree.decl list
val decls_of_command :
  Why_ptree.decl list * S.t ->
  Smtlib2_ast.command -> Why_ptree.decl list * S.t
val smt2_to_why : Smtlib2_ast.commands option -> Why_ptree.decl list
end = struct
let _ = Printf.fprintf stderr "Executing smtlib2_to_why.ml\n%!"module type INTERFACE = sig
#0 "smtlib2_to_why.mli"
exception Not_Implemented
val num0 : Num.num
val num10 : Num.num
val decnumber : string -> Num.num
module M :
  sig
    type key = String.t
    type 'a t = 'a Map.Make(String).t
    val empty : 'a t
    val is_empty : 'a t -> bool
    val mem : key -> 'a t -> bool
    val add : key -> 'a -> 'a t -> 'a t
    val singleton : key -> 'a -> 'a t
    val remove : key -> 'a t -> 'a t
    val merge :
      (key -> 'a option -> 'b option -> 'c option) -> 'a t -> 'b t -> 'c t
    val compare : ('a -> 'a -> int) -> 'a t -> 'a t -> int
    val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
    val iter : (key -> 'a -> unit) -> 'a t -> unit
    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
    val for_all : (key -> 'a -> bool) -> 'a t -> bool
    val exists : (key -> 'a -> bool) -> 'a t -> bool
    val filter : (key -> 'a -> bool) -> 'a t -> 'a t
    val partition : (key -> 'a -> bool) -> 'a t -> 'a t * 'a t
    val cardinal : 'a t -> int
    val bindings : 'a t -> (key * 'a) list
    val min_binding : 'a t -> key * 'a
    val max_binding : 'a t -> key * 'a
    val choose : 'a t -> key * 'a
    val split : key -> 'a t -> 'a t * 'a option * 'a t
    val find : key -> 'a t -> 'a
    val map : ('a -> 'b) -> 'a t -> 'b t
    val mapi : (key -> 'a -> 'b) -> 'a t -> 'b t
  end
module MString :
  sig
    type key = string
    type +'a t
    val empty : 'a t
    val is_empty : 'a t -> bool
    val mem : key -> 'a t -> bool
    val add : key -> 'a -> 'a t -> 'a t
    val singleton : key -> 'a -> 'a t
    val remove : key -> 'a t -> 'a t
    val merge :
      (key -> 'a option -> 'b option -> 'c option) -> 'a t -> 'b t -> 'c t
    val compare : ('a -> 'a -> int) -> 'a t -> 'a t -> int
    val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
    val iter : (key -> 'a -> unit) -> 'a t -> unit
    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
    val for_all : (key -> 'a -> bool) -> 'a t -> bool
    val exists : (key -> 'a -> bool) -> 'a t -> bool
    val filter : (key -> 'a -> bool) -> 'a t -> 'a t
    val partition : (key -> 'a -> bool) -> 'a t -> 'a t * 'a t
    val cardinal : 'a t -> int
    val bindings : 'a t -> (key * 'a) list
    val min_binding : 'a t -> key * 'a
    val max_binding : 'a t -> key * 'a
    val choose : 'a t -> key * 'a
    val split : key -> 'a t -> 'a t * 'a option * 'a t
    val find : key -> 'a t -> 'a
    val map : ('a -> 'b) -> 'a t -> 'b t
    val mapi : (key -> 'a -> 'b) -> 'a t -> 'b t
  end
module S :
  sig
    type elt = String.t
    type t = Set.Make(String).t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val singleton : elt -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : (elt -> unit) -> t -> unit
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val for_all : (elt -> bool) -> t -> bool
    val exists : (elt -> bool) -> t -> bool
    val filter : (elt -> bool) -> t -> t
    val partition : (elt -> bool) -> t -> t * t
    val cardinal : t -> int
    val elements : t -> elt list
    val min_elt : t -> elt
    val max_elt : t -> elt
    val choose : t -> elt
    val split : elt -> t -> t * bool * t
  end
val predicates : S.t
val const_of_specconstant : Smtlib2_ast.specconstant -> Why_ptree.constant
val string_of_symbol : Smtlib2_ast.symbol -> string
val stringi_of_identifier : Smtlib2_ast.identifier -> string * int option
val ppure_type_of_sort : Smtlib2_ast.sort -> Why_ptree.ppure_type
val stringi_of_qualidentifier :
  Smtlib2_ast.qualidentifier -> string * int option
val stringppt_of_sortedvar :
  Smtlib2_ast.sortedvar -> string * Why_ptree.ppure_type
val infix_of_string : string -> Why_ptree.pp_infix option
val prefix_of_string : string -> Why_ptree.pp_prefix option
val inline_lexpr :
  string ->
  Why_ptree.lexpr -> string list -> Why_ptree.lexpr -> Why_ptree.lexpr
val inline_ppdesc :
  string ->
  Why_ptree.lexpr -> string list -> Why_ptree.pp_desc -> Why_ptree.pp_desc
val is_prop : S.t -> S.elt list -> Why_ptree.lexpr -> bool
val stringlexpr_of_varbinding :
  S.t -> Smtlib2_ast.varbinding -> S.elt * Why_ptree.lexpr
val ppdesc_of_sexpr : Smtlib2_ast.sexpr -> Why_ptree.pp_desc
val lexpr_of_sexpr : Smtlib2_ast.sexpr -> Why_ptree.lexpr
val triggers_of_attributelist :
  Smtlib2_ast.attribute list -> Why_ptree.lexpr list list
val ppinfix_alist :
  S.t ->
  Why_ptree.loc ->
  Why_ptree.pp_infix ->
  Smtlib2_ast.term list ->
  (Smtlib2_ast.term -> Why_ptree.lexpr) -> Why_ptree.pp_desc
val ppinfix_termlist :
  S.t ->
  Why_ptree.loc ->
  Why_ptree.pp_infix -> Smtlib2_ast.term list -> Why_ptree.pp_desc
val ppinfix_blist :
  S.t ->
  Why_ptree.loc ->
  Why_ptree.pp_infix ->
  Smtlib2_ast.sexpr list ->
  (Smtlib2_ast.sexpr -> Why_ptree.lexpr) -> Why_ptree.pp_desc
val ppinfix_sexprlist :
  Smtlib2_ast.loc ->
  Why_ptree.pp_infix -> Smtlib2_ast.sexpr list -> Why_ptree.pp_desc
val let_of_varbindinglist :
  S.t ->
  Why_ptree.loc ->
  Smtlib2_ast.term -> Smtlib2_ast.varbinding list -> Why_ptree.pp_desc
val forall_of_sortedvarlist :
  Why_ptree.loc ->
  Smtlib2_ast.term ->
  Why_ptree.lexpr list list ->
  Smtlib2_ast.sortedvar list -> Why_ptree.pp_desc
val exists_of_sortedvarlist :
  Why_ptree.loc ->
  Smtlib2_ast.term -> Smtlib2_ast.sortedvar list -> Why_ptree.pp_desc
val ppapp_of_string :
  Why_ptree.loc ->
  string -> Smtlib2_ast.term list -> S.t -> Why_ptree.pp_desc
val ppconstvar_of_string : string -> Why_ptree.pp_desc
val ppdesc_of_term : S.t -> Smtlib2_ast.term -> Why_ptree.pp_desc
val lexpr_of_term : S.t -> Smtlib2_ast.term -> Why_ptree.lexpr
val last_axiom_to_goal :
  Why_ptree.loc ->
  Why_ptree.decl list -> Why_ptree.decl list -> Why_ptree.decl list
val decls_of_command :
  Why_ptree.decl list * S.t ->
  Smtlib2_ast.command -> Why_ptree.decl list * S.t
val smt2_to_why : Smtlib2_ast.commands option -> Why_ptree.decl list
end
module IMPLEMENTATION = struct
#0 "smtlib2_to_why.ml"
open Why_ptree
open Smtlib2_ast
open Format
open Options


exception Not_Implemented

let num0 = Num.Int 0
let num10 = Num.Int 10
(* let num16 = Num.Int 16 *)

let decnumber s =
  let r = ref num0 in
  for i=0 to String.length s - 1 do
    r := Num.add_num (Num.mult_num num10 !r) 
      (Num.num_of_int (Char.code s.[i] - Char.code '0'))
  done;
  !r

(* let hexnumber s = *)
(*   let r = ref num0 in *)
(*   for i=0 to String.length s - 1 do *)
(*     let c = s.[i] in *)
(*     let v =  *)
(*       match c with *)
(* 	| '0'..'9' -> Char.code c - Char.code '0' *)
(* 	| 'a'..'f' -> Char.code c - Char.code 'a' + 10 *)
(* 	| 'A'..'F' -> Char.code c - Char.code 'A' + 10 *)
(* 	| _ -> assert false *)
(*     in *)
(*     r := Num.add_num (Num.mult_num num16 !r) (Num.num_of_int v) *)
(*   done; *)
(*     !r *)

module M = Map.Make(String)

module MString = 
  Map.Make(struct type t = string let compare = Pervasives.compare end)

module S = Set.Make(String)

let predicates = S.empty

let const_of_specconstant = function 
  | SpecConstString (_, s) -> assert false
  (* | SpecConstString (_, "true") -> ConstTrue *)
  (* | SpecConstString (_, "false") -> ConstFalse *)
  | SpecConstsDec (_, s) -> ConstReal (decnumber s)
  | SpecConstNum (_, s) -> ConstInt s
  | SpecConstsHex (_, s) 
  | SpecConstsBinary (_, s) -> 
    ConstInt (Scanf.sscanf s "%i" (Printf.sprintf "%d"))

let string_of_symbol = function
  | Symbol (pos, s) 
  | SymbolWithOr (pos, s) -> s

let stringi_of_identifier = function
  | IdSymbol (_, sy) -> string_of_symbol sy, None
  | IdUnderscoreSymNum (_, sy, (_, sl)) -> 
    if List.length sl <> 1 then raise Not_Implemented
    else Scanf.sscanf (List.hd sl) "%d" 
      (fun n -> string_of_symbol sy, Some n)

let rec ppure_type_of_sort = function
  | SortIdentifier (pos, id) ->
    begin 
      match stringi_of_identifier id with 
	| "Int", _ -> PPTint
	| "Bool", _ -> PPTbool
	| "Real", _ -> PPTreal
	| "Bitv", Some n -> PPTbitv n
	| s, _ -> PPTexternal ([], s, pos)
    end
  | SortIdSortMulti (pos, id, (_, sortlist)) ->
    begin 
      match stringi_of_identifier id with 
	| "Array", _ ->
	  if List.length sortlist <> 2 then raise Not_Implemented
	  else 
	    let pptl = List.map ppure_type_of_sort sortlist in
	    (match pptl with 
	      | [] | [_] -> raise Not_Implemented
	      | [p1; p2] ->
		(* if p1 = PPTint then PPTfarray p2 *)
		(* else *) PPTexternal (pptl, "farray", pos)
	      | _ -> raise Not_Implemented)
	| s, _ -> 
	  let pptl = List.map ppure_type_of_sort sortlist in
	  PPTexternal (pptl, s, pos)
    end
    
let stringi_of_qualidentifier = function
  | QualIdentifierId (_, id)
  | QualIdentifierAs (_, id, _) -> stringi_of_identifier id

let stringppt_of_sortedvar = function 
  | SortedVarSymSort (_, sy, so) -> 
    string_of_symbol sy, ppure_type_of_sort so

let infix_of_string = function
  | "=" -> Some PPeq
  | "<=>" -> Some PPiff
  | "<" -> Some PPlt
  | "<=" -> Some PPle
  | ">" -> Some PPgt
  | ">=" -> Some PPge
  | "+" -> Some PPadd
  | "-" -> Some PPsub
  | "*" -> Some PPmul
  | "/" | "div" -> Some PPdiv
  | "%" | "mod" -> Some PPmod
  | "and" -> Some PPand
  | "or" -> Some PPor
  | "=>" -> Some PPimplies
  | _ -> None


let prefix_of_string = function
  | "not" -> Some PPnot
  | _ -> None


let rec inline_lexpr s leb excl { pp_loc = pos; pp_desc = descv } =
  { pp_loc = pos; pp_desc = inline_ppdesc s leb excl descv }

and inline_ppdesc s ({ pp_desc = descb } as leb) excl = function
  | PPvar s' when not (List.mem s excl) && s' = s -> descb
  | PPapp (s', ll) ->
    PPapp (s', List.map (inline_lexpr s leb excl) ll)
  | PPconst c -> PPconst c
  | PPinfix (le1, i, le2) ->
    PPinfix (inline_lexpr s leb excl le1, i, inline_lexpr s leb excl le2)
  | PPprefix (pre, le) ->
    PPprefix (pre, inline_lexpr s leb excl le)
  | PPget (le1, le2) ->
    PPget (inline_lexpr s leb excl le1, inline_lexpr s leb excl le2)
  | PPset (le1, le2, le3) ->
    PPset (inline_lexpr s leb excl le1, 
	   inline_lexpr s leb excl le2, 
	   inline_lexpr s leb excl le3)
  | PPextract (le1, le2, le3) ->
    PPextract (inline_lexpr s leb excl le1, 
	       inline_lexpr s leb excl le2, 
	       inline_lexpr s leb excl le3)
  | PPconcat(le1, le2) ->
    PPconcat (inline_lexpr s leb excl le1, inline_lexpr s leb excl le2)
  | PPif(le1, le2, le3) ->
    PPif (inline_lexpr s leb excl le1, 
	  inline_lexpr s leb excl le2, 
	  inline_lexpr s leb excl le3)
  | PPforall (sl, pt, lll, le) ->
    let excl = sl@excl in
    PPforall (sl, pt, List.map (List.map (inline_lexpr s leb excl)) lll,
	      inline_lexpr s leb excl le)
  | PPexists (sl, pt, le) ->
    let excl = sl@excl in
    PPexists (sl, pt, inline_lexpr s leb excl le)
  | PPnamed (n, le) ->
    PPnamed (n, inline_lexpr s leb excl le)
  | PPlet (n, le1, le2) ->
    PPlet (n, inline_lexpr s leb excl le1, inline_lexpr s leb excl le2)
  | desc -> desc
 

let rec is_prop predicates excl { pp_desc = descv } =
  match descv with
    | PPvar s -> not (List.mem s excl) && S.mem s predicates
    | PPapp (s, _) -> not (List.mem s excl) && S.mem s predicates
    | PPconst _ -> false
    | PPinfix (_, (PPeq | PPle | PPlt | PPge | PPgt | PPneq 
		      | PPand | PPor | PPimplies | PPiff), _) -> true
    | PPprefix (PPnot, _) -> true
    | PPget _ | PPset _ | PPextract _ | PPconcat _ -> false
    | PPif (_, l, _) -> is_prop predicates excl l
    | PPforall _ | PPexists _ -> true
    | PPnamed (_, l) -> is_prop predicates excl l
    | PPlet (s, _, l) -> is_prop predicates (s::excl) l
    | _ -> false


let rec stringlexpr_of_varbinding predicates = function
  | VarBindingSymTerm (_, sy, t) -> 
    string_of_symbol sy, lexpr_of_term predicates t

and ppdesc_of_sexpr = function
  | SexprSpecConst (pos, sc) -> PPconst (const_of_specconstant sc) 
  | SexprSymbol (pos, sy) -> ppconstvar_of_string (string_of_symbol sy) 
  | SexprInParen (pos, (_, (SexprSymbol (_, sy))::sel)) ->
    let s = string_of_symbol sy in
    (match prefix_of_string s with
      | Some x -> 
	if List.length sel <> 1 then raise Not_Implemented
	else PPprefix (x, lexpr_of_sexpr (List.hd sel))
      | None ->
	(match infix_of_string s with
	  | Some x -> ppinfix_sexprlist pos x sel
	  | None -> 
	    (match s with
	      | "select" -> 
		PPget ((lexpr_of_sexpr (List.nth sel 0)),
		       (lexpr_of_sexpr (List.nth sel 1)))
	      | "store" -> 
		PPset ((lexpr_of_sexpr (List.nth sel 0)),
		       (lexpr_of_sexpr (List.nth sel 1)),
		       (lexpr_of_sexpr (List.nth sel 2)))
	      | "ite" -> 
		PPif ((lexpr_of_sexpr (List.nth sel 0)),
		      (lexpr_of_sexpr (List.nth sel 1)),
		      (lexpr_of_sexpr (List.nth sel 2)))
	      | "distinct" ->
		PPdistinct (List.map lexpr_of_sexpr sel)
	      | _ ->
		PPapp (s, List.map lexpr_of_sexpr sel)
	    )
	)
    )
  | _ -> assert false

and lexpr_of_sexpr se = match se with 
  | SexprSpecConst (pos, _) 
  | SexprSymbol (pos, _) 
  | SexprInParen (pos, (_, _)) -> 
    { pp_loc = pos; pp_desc = ppdesc_of_sexpr se }
  | _ -> assert false

and triggers_of_attributelist = function
  | [] -> []
  | (AttributeKeywordValue (_, ":pattern", 
			    (AttributeValSexpr (pos, (_, sel)))))::atl ->
    (List.map lexpr_of_sexpr sel)::(triggers_of_attributelist atl)
  | _::atl -> triggers_of_attributelist atl


and ppinfix_alist predicates pos ppi tl tfunc =
  (* let tl = if ppi = PPneq && List.length tl >= 3 then tl@[List.hd tl] else tl in *)
  let rec aux predicates pos ppi = function
    | [] -> Loc.report pos; raise Not_Implemented
    | [a] -> 
      if ppi = PPsub then PPprefix (PPneg, (tfunc a))
      else raise Not_Implemented
    | [a;b] -> 
      let la = tfunc a in
      let lb = tfunc b in
      let are_prop = is_prop predicates [] la || is_prop predicates [] lb in
      let ppi, negate = 
	(match ppi with 
	  | PPeq when are_prop -> PPiff, false
	  | PPneq when are_prop -> PPiff, true
	  | _ -> ppi, false) in
      if negate then 
	PPprefix (PPnot, { pp_loc = pos; pp_desc = PPinfix (la, ppi, lb) })
      else PPinfix (la, ppi, lb)
    | a::(b::_ as l) -> 
      let la = tfunc a in
      let are_prop = is_prop predicates [] la in
      let ppi = 
	(match ppi with 
	  | PPeq when are_prop -> PPiff
	  | _ -> ppi) in 
      let le = { pp_loc = pos; pp_desc = aux predicates pos ppi l }
      in
      if ppi = PPneq then
	let lb = tfunc b in
	let n1 = { pp_loc = pos; pp_desc = PPinfix (la, ppi, lb) } in
	PPinfix (n1, PPand, le)
      else 
	PPinfix (la, ppi, le)
  in aux predicates pos ppi tl

and ppinfix_termlist pre pos ppi tl = 
  ppinfix_alist pre pos ppi tl (lexpr_of_term pre)


and ppinfix_blist predicates pos ppi tl tfunc = 
  (* FIXME = ppinfix_alist predicates pos ppi tl tfunc *)
  (* let tl = if ppi = PPneq && List.length tl >= 3 then tl@[List.hd tl] else tl in *)
  let rec aux predicates pos ppi = function
    | [] -> Loc.report pos; raise Not_Implemented
    | [a] -> 
      if ppi = PPsub then PPprefix (PPneg, (tfunc a))
      else raise Not_Implemented
    | [a;b] -> 
      let la = tfunc a in
      let lb = tfunc b in
      let are_prop = is_prop predicates [] la || is_prop predicates [] lb in
      let ppi, negate = 
	(match ppi with 
	  | PPeq when are_prop -> PPiff, false
	  | PPneq when are_prop -> PPiff, true
	  | _ -> ppi, false) in
      if negate then 
	PPprefix (PPnot, { pp_loc = pos; pp_desc = PPinfix (la, ppi, lb) })
      else PPinfix (la, ppi, lb)
    | a::(b::_ as l) -> 
      let la = tfunc a in
      let are_prop = is_prop predicates [] la in
      let ppi = 
	(match ppi with 
	  | PPeq when are_prop -> PPiff
	  | _ -> ppi) in 
      let le = { pp_loc = pos; pp_desc = aux predicates pos ppi l }
      in
      if ppi = PPneq then
	let lb = tfunc b in
	let n1 = { pp_loc = pos; pp_desc = PPinfix (la, ppi, lb) } in
	PPinfix (n1, PPand, le)
      else 
	PPinfix (la, ppi, le)
  in aux predicates pos ppi tl

and ppinfix_sexprlist pos ppi sel = 
  ppinfix_blist S.empty pos ppi sel lexpr_of_sexpr


and let_of_varbindinglist predicates pos t = function
  | [] -> raise Not_Implemented
  | [vb] -> 
    let (s, le) = stringlexpr_of_varbinding predicates vb in
    let are_prop = is_prop predicates [] le in
    let predicates = if are_prop then (S.add s predicates) else predicates in
    if (* true ||  *)are_prop then 
      let { pp_desc = ppd } = 
	inline_lexpr s le [] (lexpr_of_term predicates t) in
      ppd
    else PPlet (s, le, lexpr_of_term predicates t)
  | vb::l -> 
    let (s, le) = stringlexpr_of_varbinding predicates vb in
    let are_prop = is_prop predicates [] le in
    let predicates = if are_prop then (S.add s predicates) else predicates in
    let le2 = 
      { pp_loc = pos; pp_desc = let_of_varbindinglist predicates pos t l } in
    if (* true ||  *)are_prop then
      let { pp_desc = ppd } = inline_lexpr s le [] le2 in
      ppd
    else PPlet (s, le, le2)

and forall_of_sortedvarlist pos t triggers = function
  | [] -> raise Not_Implemented
  | [sv] -> 
    let (s, ppt) = stringppt_of_sortedvar sv in
    PPforall ([s], ppt, triggers, lexpr_of_term predicates t)
  | sv::l -> 
    let (s, ppt) = stringppt_of_sortedvar sv in
    let le2 = { pp_loc = pos; 
		pp_desc = forall_of_sortedvarlist pos t triggers l } 
    in
    PPforall ([s], ppt, [], le2)

and exists_of_sortedvarlist pos t = function
  | [] -> raise Not_Implemented
  | [sv] -> 
    let (s, ppt) = stringppt_of_sortedvar sv in
    PPexists ([s], ppt, lexpr_of_term predicates t)
  | sv::l -> 
    let (s, ppt) = stringppt_of_sortedvar sv in
    let le2 = { pp_loc = pos; pp_desc = exists_of_sortedvarlist pos t l } in
    PPexists ([s], ppt, le2)

and ppapp_of_string pos s tl predicates =
  match prefix_of_string s with
    | Some x -> 
      if List.length tl <> 1 then raise Not_Implemented
      else PPprefix (x, lexpr_of_term predicates (List.hd tl))
    | None -> 
      (match infix_of_string s with
	| Some x -> 
	  ppinfix_termlist predicates pos x tl
	| None ->
	  (match s with
	    | "select" -> 
	      PPget ((lexpr_of_term predicates (List.nth tl 0)),
		     (lexpr_of_term predicates (List.nth tl 1)))
	    | "store" -> 
	      PPset ((lexpr_of_term predicates (List.nth tl 0)),
		     (lexpr_of_term predicates (List.nth tl 1)),
		     (lexpr_of_term predicates (List.nth tl 2)))
	    | "ite" -> 
	      PPif ((lexpr_of_term predicates (List.nth tl 0)),
		    (lexpr_of_term predicates (List.nth tl 1)),
		    (lexpr_of_term predicates (List.nth tl 2)))
	    | "distinct" ->
	      PPdistinct (List.map (lexpr_of_term predicates) tl)
	    | _ ->
	      PPapp (s, List.map (lexpr_of_term predicates) tl)
	  )
      )

and ppconstvar_of_string = function
  | "true" -> PPconst ConstTrue
  | "false" -> PPconst ConstFalse
  | s -> PPvar s

and ppdesc_of_term predicates = function
  | TermSpecConst (_,sc) -> PPconst (const_of_specconstant sc)
  | TermQualIdentifier (_, qi) -> 
    let s = fst (stringi_of_qualidentifier qi) in
    ppconstvar_of_string s
  | TermQualIdTerm (pos, qi, (_, tl)) -> 
    let s = fst (stringi_of_qualidentifier qi) in
    ppapp_of_string pos s tl predicates
    (*match prefix_of_string s with
      | Some x -> 
	if List.length tl <> 1 then raise Not_Implemented
	else PPprefix (x, lexpr_of_term predicates (List.hd tl))
      | None -> 
	(match infix_of_string s with
	  | Some x -> ppinfix_termlist predicates pos x tl
	  | None ->
	    (match s with
	      | "select" -> 
		PPget ((lexpr_of_term predicates (List.nth tl 0)),
		       (lexpr_of_term predicates (List.nth tl 1)))
	      | "store" -> 
		PPset ((lexpr_of_term predicates (List.nth tl 0)),
		       (lexpr_of_term predicates (List.nth tl 1)),
		       (lexpr_of_term predicates (List.nth tl 2)))
	      | _ ->
		PPapp (s, List.map (lexpr_of_term predicates) tl)
	    )
	)
    *)
  | TermLetTerm (pos, (_, vbl), t) -> 
    let_of_varbindinglist predicates pos t vbl
  
(* FIXME : out of scope bounded variables inside triggers ! 
  | TermForAllTerm (pos, (_, svl),  TermExclimationPt (_, t, (_, atl))) ->
    forall_of_sortedvarlist pos t (triggers_of_attributelist atl) svl
*)
  | TermForAllTerm (pos, (_, svl), t) ->
    forall_of_sortedvarlist pos t [] svl
  | TermExistsTerm (pos, (_, svl), t) ->
    exists_of_sortedvarlist pos t svl
  | TermExclimationPt (_, t, _) -> ppdesc_of_term predicates t

and lexpr_of_term predicates t = match t with
  | TermSpecConst (pos, _)
  | TermQualIdentifier (pos, _) 
  | TermQualIdTerm (pos, _, _)
  | TermLetTerm (pos, _, _) 
  | TermForAllTerm (pos, _, _)
  | TermExistsTerm (pos, _, _)
  | TermExclimationPt (pos, _, _) ->
    { pp_loc = pos;
      pp_desc = ppdesc_of_term predicates t }

let rec last_axiom_to_goal pos acc = function
  | [] -> 
    let true_lexpr = { pp_loc = pos; pp_desc = PPconst ConstTrue } in
    (Goal (pos, "", true_lexpr))::(List.rev acc)
  | (Axiom (pos', n, a))::r ->
    (Axiom (pos', n, a))::(Goal (pos, n, a))::(List.rev_append acc r)
  | d::r -> last_axiom_to_goal pos (d::acc) r

let decls_of_command (acc, predicates) = function
  | CSetLogic _
  | CSetOption _
  | CSetInfo _ -> acc, predicates
  | CDeclareSort (pos, sy, n) ->
    let n = Scanf.sscanf n "%d" (fun x -> x) in
    let rec make_vt = function
      | nb when nb = n -> []
      | nb -> (Printf.sprintf "\'a%d" nb)::(make_vt (nb + 1)) in
    (TypeDecl (pos, make_vt n, string_of_symbol sy, []))::acc, predicates
  | CDefineSort (pos, sy, (_, syl), so) -> assert false
  | CDeclareFun (pos, sy, (_, sol), so) ->
    let ppt = ppure_type_of_sort so in
    let logic_type = 
      let pptl = List.map ppure_type_of_sort sol in
      if ppt = PPTbool then PPredicate pptl
      else PFunction (pptl, ppt)
    in
    let s = string_of_symbol sy in
    let predicates = if ppt = PPTbool then S.add s predicates else predicates in
    (Logic (pos, Symbols.Other, [s], logic_type))::acc, predicates
  | CDefineFun (pos, sy, (pos2, svl), so, t) ->
    let spl = List.map (fun sv -> 
      let s, ppt = stringppt_of_sortedvar sv in
      pos2, s, ppt) svl in
    let s = string_of_symbol sy in
    let ppt = ppure_type_of_sort so in
    let le = lexpr_of_term predicates t in
    if ppt = PPTbool then 
      (Predicate_def (pos, s, spl, le))::acc, S.add s predicates
    else (Function_def (pos, s, spl, ppt, le))::acc, predicates
  | CAssert (pos, t) ->
    (Axiom (pos, "", lexpr_of_term predicates t))::acc, predicates
  | CCheckSat pos -> 
    (*let true_lexpr = { pp_loc = pos; pp_desc = PPconst ConstTrue } in
    (Goal (pos, "check-sat", true_lexpr))::*)
    last_axiom_to_goal pos [] acc, predicates
  | CPush _
  | CPop _
  | CGetAssert _
  | CGetProof _
  | CGetUnsatCore _
  | CGetValue _
  | CGetAssign _
  | CGetOption _
  | CGetInfo _
  | CExit _ -> acc, predicates


let smt2_to_why = function
  | Some (Commands (_, (pos, cl))) ->
    List.rev (fst (List.fold_left decls_of_command ([], predicates) cl))
  | None -> []
end
include (IMPLEMENTATION : INTERFACE)
end
and Polynome: sig
#0 "polynome.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Num

exception Not_a_num
exception Maybe_zero

module type S = sig
  type r 
  val compare : r -> r-> int
  val term_embed : Term.t -> r
  val mult : r -> r -> r
  val print : Format.formatter -> r -> unit
end

module type T = sig

  type r 
  type t
  
  val compare : t -> t -> int
  val hash : t -> int

  val create : (num * r) list -> num -> Ty.t-> t
  val add : t -> t -> t
  val sub : t -> t -> t
  val mult : t -> t -> t
  val mult_const : num -> t -> t
  val div : t -> t -> t * bool
  val modulo : t -> t -> t

  val is_empty : t -> bool
  val find : r -> t -> num
  val choose : t -> num * r
  val subst : r -> t -> t -> t
  val remove : r -> t -> t
  val to_list : t -> (num * r) list * num
    
  val print : Format.formatter -> t -> unit
  val type_info : t -> Ty.t
  val is_monomial : t -> (num * r * num) option

  (* PPMC des denominateurs des coefficients excepte la constante *)
  val ppmc_denominators : t -> num
  (* PGCD des numerateurs des coefficients excepte la constante *)
  val pgcd_numerators : t -> num
  (* retourne un polynome sans constante et sa constante 
     et la constante multiplicative:
     normal_form p = (p',c,d) <=> p = (p' + c) * d *)
  val normal_form : t -> t * num * num
  (* comme normal_form mais le signe est aussi normalise *)
  val normal_form_pos : t -> t * num * num
end

module Make (X : S) : T with type r = X.r
	
end = struct
let _ = Printf.fprintf stderr "Executing polynome.ml\n%!"module type INTERFACE = sig
#0 "polynome.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Num

exception Not_a_num
exception Maybe_zero

module type S = sig
  type r 
  val compare : r -> r-> int
  val term_embed : Term.t -> r
  val mult : r -> r -> r
  val print : Format.formatter -> r -> unit
end

module type T = sig

  type r 
  type t
  
  val compare : t -> t -> int
  val hash : t -> int

  val create : (num * r) list -> num -> Ty.t-> t
  val add : t -> t -> t
  val sub : t -> t -> t
  val mult : t -> t -> t
  val mult_const : num -> t -> t
  val div : t -> t -> t * bool
  val modulo : t -> t -> t

  val is_empty : t -> bool
  val find : r -> t -> num
  val choose : t -> num * r
  val subst : r -> t -> t -> t
  val remove : r -> t -> t
  val to_list : t -> (num * r) list * num
    
  val print : Format.formatter -> t -> unit
  val type_info : t -> Ty.t
  val is_monomial : t -> (num * r * num) option

  (* PPMC des denominateurs des coefficients excepte la constante *)
  val ppmc_denominators : t -> num
  (* PGCD des numerateurs des coefficients excepte la constante *)
  val pgcd_numerators : t -> num
  (* retourne un polynome sans constante et sa constante 
     et la constante multiplicative:
     normal_form p = (p',c,d) <=> p = (p' + c) * d *)
  val normal_form : t -> t * num * num
  (* comme normal_form mais le signe est aussi normalise *)
  val normal_form_pos : t -> t * num * num
end

module Make (X : S) : T with type r = X.r
	
end
module IMPLEMENTATION = struct
#0 "polynome.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Format
open Num

exception Not_a_num
exception Maybe_zero

module type S = sig
  type r
  val compare : r -> r -> int
  val term_embed : Term.t -> r
  val mult : r -> r -> r
  val print : Format.formatter -> r -> unit
end

module type T = sig

  type r
  type t

  val compare : t -> t -> int
  val hash : t -> int
  val create : (num * r) list -> num -> Ty.t-> t
  val add : t -> t -> t
  val sub : t -> t -> t
  val mult : t -> t -> t
  val mult_const : num -> t -> t
  val div : t -> t -> t * bool
  val modulo : t -> t -> t

  val is_empty : t -> bool
  val find : r -> t -> num
  val choose : t -> num * r
  val subst : r -> t -> t -> t
  val remove : r -> t -> t
  val to_list : t -> (num * r) list * num
    
  val print : Format.formatter -> t -> unit
  val type_info : t -> Ty.t
  val is_monomial : t -> (num * r * num) option

  val ppmc_denominators : t -> num
  val pgcd_numerators : t -> num
  val normal_form : t -> t * num * num
  val normal_form_pos : t -> t * num * num
end

module Make (X : S) = struct

  type r = X.r
      
  module M : Map.S with type key = r = 
    Map.Make(struct type t = r let compare x y = X.compare y x end)
      
  type t = { m : num M.t; c : num; ty : Ty.t }

  let compare p1 p2 = 
    let c = Ty.compare p1.ty p2.ty in
    if c <> 0 then c
    else
      let c = compare_num p1.c p2.c in
      if c = 0 then M.compare compare_num p1.m p2.m else c

  let hash p = 
    abs (Hashtbl.hash p.m + 19*Hashtbl.hash p.c + 17 * Ty.hash p.ty)
 
  let pprint fmt p =
    M.iter
      (fun x n ->
         let s, n, op = match n with
           | Int 1  -> "+", "", ""
           | Int -1 -> "-", "", ""
           | n ->   
               if n >/ Int 0 then "+", string_of_num n, "*" 
               else "-", string_of_num (minus_num n), "*" 
         in
         fprintf fmt "%s%s%s%a" s n op X.print x
      )p.m;
    let s, n = if p.c >=/ Int 0 then "+", string_of_num p.c 
    else "-", string_of_num (minus_num p.c) in
    fprintf fmt "%s%s" s n


  let print fmt p =
    if Options.term_like_pp then pprint fmt p 
    else begin
      M.iter 
        (fun t n -> fprintf fmt "%s*%a " (string_of_num n) X.print t) p.m;
      fprintf fmt "%s" (string_of_num p.c);
      fprintf fmt " [%a]" Ty.print p.ty
    end



  let is_num p = M.is_empty p.m

  let find x m = try M.find x m with Not_found -> Int 0

  let create l c ty = 
    let m = 
      List.fold_left 
	(fun m (n, x) -> 
	   let n' = n +/ (find x m) in
	   if n' =/ (Int 0) then M.remove x m else M.add x n' m) M.empty l
    in
    { m = m; c = c; ty = ty }
      
  let add p1 p2 = 
    let m = 
      M.fold 
	(fun x a m -> 
	   let a' = (find x m) +/ a in
	   if a' =/ (Int 0) then M.remove x m  else M.add x a' m)
	p2.m p1.m
    in 
    { m = m; c = p1.c +/ p2.c; ty = p1.ty }

  let mult_const n p = 
    if n =/ (Int 0) then { m = M.empty; c = Int 0; ty = p.ty }
    else { p with m = M.map (mult_num n) p.m; c =  n */ p.c }

  let mult_monome a x p  = 
    let ax = { m = M.add x a M.empty; c = (Int 0); ty = p.ty} in
    let acx = mult_const p.c ax in
    let m = 
      M.fold
	(fun xi ai m -> M.add (X.mult x xi) (a */ ai) m) p.m acx.m 
    in 
    { acx with m = m}
      
  let mult p1 p2 =
    let p = mult_const p1.c p2 in
    M.fold (fun x a p -> add (mult_monome a x p2) p) p1.m p

  let sub p1 p2 = 
    add p1 (mult (create [] (Int (-1)) p1.ty) p2)

  let div p1 p2 = 
    if M.is_empty p2.m then
      if p2.c =/ Int 0 then raise Division_by_zero
      else 
        let p = mult_const ((Int 1) // p2.c) p1 in
        match M.is_empty p.m, p.ty with
          | true, Ty.Tint  -> {p with c = floor_num p.c}, false 
          | true, Ty.Treal  ->  p, false
          | false, Ty.Tint ->  p, true
          | false, Ty.Treal ->  p, false
          | _ -> assert false
    else raise Maybe_zero


  let modulo p1 p2 = 
    if M.is_empty p2.m then
      if p2.c =/ Int 0 then raise Division_by_zero
      else 
        if M.is_empty p1.m then { p1 with c = mod_num p1.c p2.c }
        else raise Not_a_num
    else raise Maybe_zero
      
  let find x p = M.find x p.m

  let is_empty p = M.is_empty p.m

  let choose p =
    let tn= ref None in
    (*version I : prend le premier element de la table*)
    (try M.iter
       (fun x a -> tn := Some (a, x); raise Exit) p.m with Exit -> ());
    (*version II : prend le dernier element de la table i.e. le plus grand 
    M.iter (fun x a -> tn := Some (a, x)) p.m;*)
    match !tn with Some p -> p | _ -> raise Not_found

  let subst x p1 p2 =
    try
      let a = M.find x p2.m in
      add (mult_const a p1) { p2 with m = M.remove x p2.m}
    with Not_found -> p2
      
  let remove x p = { p with m = M.remove x p.m }
      
  let to_list p = 
    let l = M.fold (fun x a aliens -> (a, x)::aliens ) p.m [] in
    List.rev l, p.c

  let type_info p = p.ty

  let is_monomial p  = 
    try 
      M.fold
	(fun x a r -> 
	   match r with
	     | None -> Some (a, x, p.c)
	     | _ -> raise Exit)
	p.m None
    with Exit -> None

  let denominator = function
    | Num.Int _ | Num.Big_int _ -> Big_int.unit_big_int
    | Num.Ratio rat -> Ratio.denominator_ratio rat

  let numerator = function
    | Num.Int i -> Big_int.big_int_of_int i 
    | Num.Big_int b -> b
    | Num.Ratio rat -> Ratio.numerator_ratio rat

  let pgcd_bi a b = Big_int.gcd_big_int a b
      
  let ppmc_bi a b = Big_int.div_big_int (Big_int.mult_big_int a b) (pgcd_bi a b)
     
  let abs_big_int_to_num b =
    let b = 
      try Int (Big_int.int_of_big_int b) 
      with Failure "int_of_big_int" -> Big_int b
    in
    abs_num b
    
  let ppmc_denominators {m=m} = 
    let res =   
      M.fold
        (fun k c acc -> ppmc_bi (denominator c) acc)
        m Big_int.unit_big_int in
    abs_num (num_of_big_int res)

  let pgcd_numerators {m=m} = 
    let res =   
      M.fold
        (fun k c acc -> pgcd_bi (numerator c) acc)
        m Big_int.zero_big_int in
    abs_num (num_of_big_int res)

  let normal_form ({ m = m; c = c } as p) =
    if M.is_empty m then 
      { p with c = Int 0 }, p.c, (Int 1)
    else
      let ppcm = ppmc_denominators p in
      let pgcd = pgcd_numerators p in
      let p = mult_const (ppcm // pgcd) p in
      { p with c = Int 0 }, p.c, (pgcd // ppcm)

  let normal_form_pos p =
    let p, c, d = normal_form p in
    try
      let a,x = choose p in
      if a >/ (Int 0) then p, c, d
      else mult_const (Int (-1)) p, minus_num c, minus_num d
    with Not_found -> p, c, d

end

end
include (IMPLEMENTATION : INTERFACE)
end
and Sig : sig
#0 "sig.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type answer = Yes of Explanation.t | No

type 'a ac = {h: Symbols.t ; t: Ty.t ; l: ('a * int) list}

type 'a sem_atom =  'a Literal.view * Literal.LT.t option

type 'a sem_atom_ex =  'a Literal.view * Literal.LT.t option * Explanation.t

module type RELATION = sig
  type t
  type r

  val empty : unit -> t
  
  val assume : 
    t -> r sem_atom_ex list -> Explanation.t -> t * r sem_atom_ex list

  val instantiate :
    t -> 
    (Term.t -> Term.t -> answer) -> 
    (Term.t -> Term.t -> answer) -> 
    (Term.t -> Term.t list)      ->
    r sem_atom_ex list ->
    t * (Literal.LT.t * Explanation.t) list

  val query : r sem_atom -> t -> Explanation.t -> answer

  val case_split : t -> (r sem_atom * Num.num) list
    (** case_split env returns a list of equalities *)
    
  val add : t -> r -> t
    (** add a representant to take into account *)

end

module type THEORY = sig

  (**Type of terms of the theory*)
  type t
  (**Type of representants of terms of the theory*)
  type r
  (** Name of the theory*)
  val name : string
  (** return true if the atom is owned by the theory*)
  val is_mine_a : Literal.LT.t -> bool
  (** return true if the symbol is owned by the theory*)
  val is_mine_symb : Symbols.t -> bool
  (** return true if the type is owned by the theory*)
  val is_mine_type : t -> bool

  (** return true when the argument is an unsolvable function of the theory *)
  val unsolvable : t -> bool

  (** Give a representant of a term of the theory*)
  val make : Term.t -> r * Literal.LT.t list

  val color : (r ac) -> r
  
  val type_info : t -> Ty.t
    
  val embed : r -> t

  (** Give the leaves of a term of the theory *)
  val leaves : t -> r list
  val subst : r -> r -> t -> r

  val compare : t -> t -> int

  val hash : t -> int
  (** solve r1 r2, solve the equality r1=r2 and return the substitution *)

  val solve : r -> r ->  (r * r) list

  val print : Format.formatter -> t -> unit

  val fully_interpreted : Symbols.t -> bool

  module Rel : RELATION with type r = r
end

module type COMBINATOR = sig
  type r
  type th

  val extract : r -> th
  val make : Term.t -> r * Literal.LT.t list
  val type_info : r -> Ty.t
  val compare : r -> r -> int
  val leaves : r -> r list
  val subst : r -> r -> r -> r
  val solve : r -> r ->  (r * r) list
  val empty_embedding : Term.t -> r
  val normal_form : Literal.LT.t -> Literal.LT.t
  val print : Format.formatter -> r -> unit
  module Rel : RELATION with type r = r

end

module type X = sig
  type r

  val make : Term.t -> r * Literal.LT.t list
  
  val type_info : r -> Ty.t
  
  val compare : r -> r -> int
  
  val equal : r -> r -> bool

  val hash : r -> int
  
  val leaves : r -> r list
  
  val subst : r -> r -> r -> r
  
  val solve : r -> r ->  (r * r) list
  
  val term_embed : Term.t -> r

  val term_extract : r -> Term.t option 
  
  val ac_embed : r ac -> r
  
  val ac_extract : r -> (r ac) option
  
  val color : (r ac) -> r

  val unsolvable   : r -> bool

  val fully_interpreted : Symbols.t -> bool
  
  val print : Format.formatter -> r -> unit
  
  module Rel : RELATION with type r = r

end

module type C = sig
  type t
  type r
  val extract : r -> t option
  val embed : t -> r
end

module type EXPLANATION = sig
  type t = Formula.Set.t option

  val union : t -> t-> t
end
end = struct
#0 "sig.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type answer = Yes of Explanation.t | No

type 'a ac = {h: Symbols.t ; t: Ty.t ; l: ('a * int) list}

type 'a sem_atom =  'a Literal.view * Literal.LT.t option

type 'a sem_atom_ex =  'a Literal.view * Literal.LT.t option * Explanation.t

module type RELATION = sig
  type t
  type r

  val empty : unit -> t
  
  val assume : 
    t -> r sem_atom_ex list -> Explanation.t -> t * r sem_atom_ex list

  val instantiate :
    t -> 
    (Term.t -> Term.t -> answer) -> 
    (Term.t -> Term.t -> answer) -> 
    (Term.t -> Term.t list)      ->
    r sem_atom_ex list ->
    t * (Literal.LT.t * Explanation.t) list

  val query : r sem_atom -> t -> Explanation.t -> answer

  val case_split : t -> (r sem_atom * Num.num) list
    (** case_split env returns a list of equalities *)
    
  val add : t -> r -> t
    (** add a representant to take into account *)

end

module type THEORY = sig

  (**Type of terms of the theory*)
  type t
  (**Type of representants of terms of the theory*)
  type r
  (** Name of the theory*)
  val name : string
  (** return true if the atom is owned by the theory*)
  val is_mine_a : Literal.LT.t -> bool
  (** return true if the symbol is owned by the theory*)
  val is_mine_symb : Symbols.t -> bool
  (** return true if the type is owned by the theory*)
  val is_mine_type : t -> bool

  (** return true when the argument is an unsolvable function of the theory *)
  val unsolvable : t -> bool

  (** Give a representant of a term of the theory*)
  val make : Term.t -> r * Literal.LT.t list

  val color : (r ac) -> r
  
  val type_info : t -> Ty.t
    
  val embed : r -> t

  (** Give the leaves of a term of the theory *)
  val leaves : t -> r list
  val subst : r -> r -> t -> r

  val compare : t -> t -> int

  val hash : t -> int
  (** solve r1 r2, solve the equality r1=r2 and return the substitution *)

  val solve : r -> r ->  (r * r) list

  val print : Format.formatter -> t -> unit

  val fully_interpreted : Symbols.t -> bool

  module Rel : RELATION with type r = r
end

module type COMBINATOR = sig
  type r
  type th

  val extract : r -> th
  val make : Term.t -> r * Literal.LT.t list
  val type_info : r -> Ty.t
  val compare : r -> r -> int
  val leaves : r -> r list
  val subst : r -> r -> r -> r
  val solve : r -> r ->  (r * r) list
  val empty_embedding : Term.t -> r
  val normal_form : Literal.LT.t -> Literal.LT.t
  val print : Format.formatter -> r -> unit
  module Rel : RELATION with type r = r

end

module type X = sig
  type r

  val make : Term.t -> r * Literal.LT.t list
  
  val type_info : r -> Ty.t
  
  val compare : r -> r -> int
  
  val equal : r -> r -> bool

  val hash : r -> int
  
  val leaves : r -> r list
  
  val subst : r -> r -> r -> r
  
  val solve : r -> r ->  (r * r) list
  
  val term_embed : Term.t -> r

  val term_extract : r -> Term.t option 
  
  val ac_embed : r ac -> r
  
  val ac_extract : r -> (r ac) option
  
  val color : (r ac) -> r

  val unsolvable   : r -> bool

  val fully_interpreted : Symbols.t -> bool
  
  val print : Format.formatter -> r -> unit
  
  module Rel : RELATION with type r = r

end

module type C = sig
  type t
  type r
  val extract : r -> t option
  val embed : t -> r
end

module type EXPLANATION = sig
  type t = Formula.Set.t option

  val union : t -> t-> t
end
end
and Ac: sig
#0 "ac.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)


module type S = sig

  (* the type of amalgamated AC semantic values *)
  type r 

  (* the type of AC semantic values used by the theory *)
  type t = r Sig.ac
      
  (* builds an embeded semantic value from an AC term *)
  val make : Term.t -> r * Literal.LT.t list

  (* tells whether the given term is AC*)
  val is_mine_symb : Symbols.t -> bool

  (* compares two AC semantic values *)
  val compare : t -> t -> int

  (* hash function for ac values *)
  val hash : t -> int

  (* returns the type infos of the given term *)
  val type_info : t -> Ty.t

  (* prints the AC semantic value *)
  val print : Format.formatter -> t -> unit
    
  (* returns the leaves of the given AC semantic value *)
  val leaves : t -> r list

  (* replaces the first argument by the second one in the given AC value *)
  val subst : r -> r -> t -> r

  (* add flatten the 2nd arg w.r.t HS.t, add it to the given list 
     and compact the result *)
  val add : Symbols.t -> r * int -> (r * int) list -> (r * int) list

  val fully_interpreted : Symbols.t -> bool

end

module Make (X : Sig.X) : S with type r = X.r
end = struct
let _ = Printf.fprintf stderr "Executing ac.ml\n%!"module type INTERFACE = sig
#0 "ac.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)


module type S = sig

  (* the type of amalgamated AC semantic values *)
  type r 

  (* the type of AC semantic values used by the theory *)
  type t = r Sig.ac
      
  (* builds an embeded semantic value from an AC term *)
  val make : Term.t -> r * Literal.LT.t list

  (* tells whether the given term is AC*)
  val is_mine_symb : Symbols.t -> bool

  (* compares two AC semantic values *)
  val compare : t -> t -> int

  (* hash function for ac values *)
  val hash : t -> int

  (* returns the type infos of the given term *)
  val type_info : t -> Ty.t

  (* prints the AC semantic value *)
  val print : Format.formatter -> t -> unit
    
  (* returns the leaves of the given AC semantic value *)
  val leaves : t -> r list

  (* replaces the first argument by the second one in the given AC value *)
  val subst : r -> r -> t -> r

  (* add flatten the 2nd arg w.r.t HS.t, add it to the given list 
     and compact the result *)
  val add : Symbols.t -> r * int -> (r * int) list -> (r * int) list

  val fully_interpreted : Symbols.t -> bool

end

module Make (X : Sig.X) : S with type r = X.r
end
module IMPLEMENTATION = struct
#0 "ac.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Options
module L = List
module HS = Hstring
module F = Format
module Sy = Symbols

module type S = sig

  (* embeded AC semantic values *)
  type r 

  (* extracted AC semantic values *)
  type t = r Sig.ac
      
  (* builds an embeded semantic value from an AC term *)
  val make : Term.t -> r * Literal.LT.t list
    
  (* tells whether the given term is AC*)
  val is_mine_symb : Sy.t -> bool

  (* compares two AC semantic values *)
  val compare : t -> t -> int

  (* hash function for ac values *)
  val hash : t -> int

  (* returns the type infos of the given term *)
  val type_info : t -> Ty.t

  (* prints the AC semantic value *)
  val print : F.formatter -> t -> unit
    
  (* returns the leaves of the given AC semantic value *)
  val leaves : t -> r list

  (* replaces the first argument by the second one in the given AC value *)
  val subst : r -> r -> t -> r

  (* add flatten the 2nd arg w.r.t HS.t, add it to the given list 
     and compact the result *)
  val add : Symbols.t -> r * int -> (r * int) list -> (r * int) list

  val fully_interpreted : Symbols.t -> bool

end

module Make (X : Sig.X) = struct

  open Sig 

  type r = X.r

  type t = X.r Sig.ac

  let flatten h (r,m) acc = 
    match X.ac_extract r with
      | Some ac when Sy.equal ac.h h -> 
	  L.fold_left (fun z (e,n) -> (e,m * n) :: z) acc ac.l
      | _ -> (r,m) :: acc
	  
  let sort = L.fast_sort (fun (x,n) (y,m) -> X.compare x y)
    
  let rev_sort l = L.rev (sort l)
    
  let compact xs =
    let rec f acc = function 
	[] -> acc
      | [(x,n)] -> (x,n) :: acc
      | (x,n) :: (y,m) :: r ->
	  if X.equal x y then f acc ((x,n+m) :: r)
	  else f ((x,n)::acc) ((y,m) :: r) 
    in
      f [] (sort xs) (* increasing order - f's result in a decreasing order*)

  let fold_flatten sy f = 
    L.fold_left (fun z (rt,n) -> flatten sy ((f rt),n) z) []

  let expand = 
    L.fold_left 
      (fun l (x,n) -> let l= ref l in for i=1 to n do l:=x::!l done; !l) []


  let make t = 
    match Term.view t with
      | {Term.f= sy; xs=xs; ty=ty} when Sy.is_ac sy ->
	  let xs = L.map (fun x -> (x,1)) xs in 
	  let ctx = ref [] in
	  let xmake t = let r, l = X.make t in ctx := l@(!ctx); r in
	  X.ac_embed {h=sy; l=compact (fold_flatten sy xmake xs); t=ty}, !ctx
      | _ -> assert false  

  let is_mine_symb = Sy.is_ac

  let type_info {t=ty} = ty

  let leaves { l=l } = L.fold_left (fun z (a,_) -> (X.leaves a) @ z)[] l
      
  let rec mset_cmp = function
    |  []   ,  []   ->  0
    |  []   , _::_  -> -1
    | _::_  ,  []   ->  1
    | (a,m)::r  , (b,n)::s  -> 
	let c = X.compare a b in 
	if c <> 0 then c 
	else 
	  let c = m - n in 
	  if c <> 0 then c 
	  else mset_cmp(r,s)
	
  let size = 
    L.fold_left (fun z (rx,n) -> z + n * (L.length (X.leaves rx))) 0
      
  (* x et y are sorted in a decreasing order *)
  let compare {h=f ; l=x} {h=g ; l=y} = 
    let c = Sy.compare f g in
    if c <> 0 then c 
    else
      let c = size x - size y in
      if c <> 0 then c
      else (*mset_cmp (rev_sort x , rev_sort y)*)
        mset_cmp (x , y)

  let hash {h = f ; l = l; t = t} = 
    let acc = Sy.hash f + 19 * Ty.hash t in
    abs (List.fold_left (fun acc (x, y) -> acc + 19 * (X.hash x + y)) acc l)

  let rec pr_elt sep fmt (e,n) = 
    assert (n >=0);
    if n = 0 then ()
    else F.fprintf fmt "%s%a%a" sep X.print e (pr_elt sep) (e,n-1)

  let pr_xs sep fmt = function
    | [] -> assert false
    | (p,n)::l  -> 
	F.fprintf fmt "%a" X.print p; 
	L.iter (F.fprintf fmt "%a" (pr_elt sep))((p,n-1)::l)
	  
  let print fmt {h=h ; l=l} = 
    if Sy.equal h (Sy.Op Sy.Mult) && Options.term_like_pp then
      F.fprintf fmt "%a" (pr_xs "'*'") l
    else
      F.fprintf fmt "%a(%a)" Sy.print h (pr_xs ",") l



  let subst p v ({h=h;l=l;t=t} as tm)  =
    if debug_ac then
      F.fprintf fmt "[ac] subst %a by %a in %a@." 
	X.print p X.print v X.print (X.ac_embed tm);
    X.color {tm with l=compact (fold_flatten h (X.subst p v) l)}

      
  let add h arg arg_l = compact (flatten h arg arg_l)

  let fully_interpreted sb = true 

end

end
include (IMPLEMENTATION : INTERFACE)
end
and Uf: sig
#0 "uf.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

module type S = sig
  type t

  module R : Sig.X

  val empty :  t
  val add : t -> Term.t -> t * Literal.LT.t list

  val mem : t -> Term.t -> bool

  val find : t -> Term.t -> R.r * Explanation.t

  val find_r : t -> R.r -> R.r * Explanation.t

  val union : 
    t -> R.r -> R.r -> Explanation.t -> 
    t * (R.r * (R.r * R.r * Explanation.t) list * R.r) list

  val distinct : t -> R.r list -> Explanation.t -> t

  val are_equal : t -> Term.t -> Term.t -> Sig.answer
  val are_distinct : t -> Term.t -> Term.t -> Sig.answer

  val class_of : t -> Term.t -> Term.t list

  val print : Format.formatter -> t -> unit

end

module Make ( X : Sig.X ) : S with module R = X
end = struct
let _ = Printf.fprintf stderr "Executing uf.ml\n%!"module type INTERFACE = sig
#0 "uf.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

module type S = sig
  type t

  module R : Sig.X

  val empty :  t
  val add : t -> Term.t -> t * Literal.LT.t list

  val mem : t -> Term.t -> bool

  val find : t -> Term.t -> R.r * Explanation.t

  val find_r : t -> R.r -> R.r * Explanation.t

  val union : 
    t -> R.r -> R.r -> Explanation.t -> 
    t * (R.r * (R.r * R.r * Explanation.t) list * R.r) list

  val distinct : t -> R.r list -> Explanation.t -> t

  val are_equal : t -> Term.t -> Term.t -> Sig.answer
  val are_distinct : t -> Term.t -> Term.t -> Sig.answer

  val class_of : t -> Term.t -> Term.t list

  val print : Format.formatter -> t -> unit

end

module Make ( X : Sig.X ) : S with module R = X
end
module IMPLEMENTATION = struct
#0 "uf.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Format
open Options
open Exception
open Sig

module type S = sig
  type t

  module R : Sig.X

  val empty :  t
  val add : t -> Term.t -> t * Literal.LT.t list

  val mem : t -> Term.t -> bool

  val find : t -> Term.t -> R.r * Explanation.t
  val find_r : t -> R.r -> R.r * Explanation.t
    
  val union : 
    t -> R.r -> R.r -> Explanation.t -> 
    t * (R.r * (R.r * R.r * Explanation.t) list * R.r) list

  val distinct : t -> R.r list -> Explanation.t -> t

  val are_equal : t -> Term.t -> Term.t -> Sig.answer
  val are_distinct : t -> Term.t -> Term.t -> Sig.answer

  val class_of : t -> Term.t -> Term.t list

  val print : Format.formatter -> t -> unit
 
end
  
module Make ( R : Sig.X ) = struct

  module Ac = Ac.Make(R)
  module L  = List
  module HS = Hstring
  module Ex = Explanation
  module R = R
  module Sy= Symbols
  module T = Term
  module F = Formula
  module MapT = Term.Map
  module SetT = Term.Set
  module SetF = Formula.Set
    
  module Lit = Literal.Make(struct type t = R.r include R end)
  module MapL = Lit.Map  

  module MapR = Map.Make(struct type t = R.r let compare = R.compare end)
    
  module SetR = Set.Make(struct type t = R.r let compare = R.compare end)

  module SetRR = Set.Make(struct 
    type t = R.r * R.r 
    let compare (r1, r1') (r2, r2') = 
      let c = R.compare r1 r2 in
      if c <> 0 then c 
      else  R.compare r1' r2'
  end)

  module SetAc = Set.Make(struct type t = Ac.t let compare = Ac.compare end)

  module SetRL = Set.Make
    (struct 
      type t = Ac.t * R.r * Ex.t
      let compare (ac1,_,_) (ac2,_,_)= Ac.compare ac1 ac2
     end)

  module RS = struct
    include Map.Make(struct type t = Sy.t let compare = Sy.compare end)
      
    let find k m = 
      try find k m with Not_found -> SetRL.empty

    let add_rule (({h=h},_,_) as rul) mp =
      add h (SetRL.add rul (find h mp)) mp

    let remove_rule (({h=h},_,_) as rul) mp =
      add h (SetRL.remove rul (find h mp)) mp

  end


  type t = { 

    (* term -> [t] *)
    make : R.r MapT.t; 
    
    (* representative table *)
    repr : (R.r * Ex.t) MapR.t; 
    
    (* r -> class (of terms) *)
    classes : SetT.t MapR.t;
    
    (*associates each value r with the set of semantical values whose
      representatives contains r *)
    gamma : SetR.t MapR.t; 
    
    (* the disequations map *)
    neqs: Ex.t MapL.t MapR.t; 
    
    (*AC rewrite system *)
    ac_rs : SetRL.t RS.t;
  }
      
  let empty = { 
    make  = MapT.empty; 
    repr = MapR.empty;
    classes = MapR.empty; 
    gamma = MapR.empty;
    neqs = MapR.empty;
    ac_rs = RS.empty
  }

  module Print = struct

    let rs_print fmt = SetR.iter (fprintf fmt "\t%a@." R.print)
    let lm_print fmt = 
      MapL.iter (fun k dep -> fprintf fmt "%a %a" Lit.print k Ex.print dep)

    let t_print fmt = SetT.iter (fprintf fmt "%a " T.print)
      
    let pmake fmt m = 
      fprintf fmt "[.] map:\n";
      MapT.iter (fun t r -> fprintf fmt "%a -> %a\n" T.print t R.print r) m
	
    let prepr fmt m = 
      fprintf fmt "------------- UF: Representatives map ----------------@.";
      MapR.iter 
	(fun r (rr,dep) -> 
	  fprintf fmt "%a --> %a %a\n" R.print r R.print rr Ex.print dep) m

    let prules fmt s = 
      fprintf fmt "------------- UF: AC rewrite rules ----------------------@.";
      RS.iter
	(fun k srl -> 
	  SetRL.iter
	    (fun (ac,d,dep)-> fprintf fmt "%a ~~> %a %a\n" 
              R.print (R.ac_embed ac) R.print d Ex.print dep
            )srl 
        )s
	
    let pclasses fmt m = 
      fprintf fmt "------------- UF: Class map --------------------------@.";
      MapR.iter 
	(fun k s -> fprintf fmt "%a -> %a\n" R.print k Term.print_list 
	  (SetT.elements s)) m

    let pgamma fmt m = 
      fprintf fmt "------------- UF: Gamma map --------------------------@.";
      MapR.iter (fun k s -> fprintf fmt "%a -> \n%a" R.print k rs_print s) m 
	
    let pneqs fmt m = 
      fprintf fmt "------------- UF: Disequations map--------------------@.";
      MapR.iter (fun k s -> fprintf fmt "%a -> %a\n" R.print k lm_print s) m

    let all fmt env = 
      fprintf fmt "------------------------------------------------------@.";
      fprintf fmt "%a %a %a %a %a" 
        pmake env.make 
        prepr env.repr 
        prules env.ac_rs 
        pclasses env.classes
        pneqs env.neqs;
      fprintf fmt "------------------------------------------------------@."

  end

  
  module Env = struct

    let mem env t = MapT.mem t env.make
      
    let lookup_by_t t env =
      try MapR.find (MapT.find t env.make) env.repr
      with Not_found -> 
	if debug_uf then fprintf fmt "Uf: Not_found %a@." Term.print t;
	assert false (*R.make t, Ex.empty*) (* XXXX *)
	  
    let lookup_by_r r env = 
      try MapR.find r env.repr with Not_found -> r, Ex.empty
	
    let lookup_for_neqs env r =
      try MapR.find r env.neqs with Not_found -> MapL.empty
	
    let add_to_classes t r classes =  
      MapR.add r 
	(SetT.add t (try MapR.find r classes with Not_found -> SetT.empty))
	classes
	
    let update_classes c nc classes = 
      let s1 = try MapR.find c classes with Not_found -> SetT.empty in
      let s2 = try MapR.find nc classes with Not_found -> SetT.empty in
      MapR.remove c (MapR.add nc (SetT.union s1 s2) classes)
	
    let add_to_gamma r c gamma = 
      L.fold_left
	(fun gamma x -> 
	  let s = try MapR.find x gamma with Not_found -> SetR.empty in
	  MapR.add x (SetR.add r s) gamma) gamma (R.leaves c)
	
    let update_neqs r1 r2 dep env = 
      let nq_r1 = lookup_for_neqs env r1 in
      let nq_r2 = lookup_for_neqs env r2 in
      let mapl = 
	MapL.fold
	  (fun l1 ex1 mapl ->  
	     try 
	       let ex2 = MapL.find l1 mapl in
	       let ex = Ex.union (Ex.union ex1 ex2) dep in (* VERIF *)
	       raise (Inconsistent ex)
	     with Not_found -> 
	       MapL.add l1 (Ex.union ex1 dep) mapl) 
	  nq_r1 nq_r2
      in
      MapR.add r2 mapl (MapR.add r1 mapl env.neqs)

    let disjoint_union l_1 l_2 = 
      let rec di_un (l1,c,l2) (l_1,l_2)= 
        match l_1,l_2 with
	  | [],[] -> l1, c, l2
	  | l, [] -> di_un (l @ l1,c,l2) ([],[])
	  | [], l -> di_un (l1,c,l @ l2) ([],[])
	  | (a,m)::r, (b,n)::s ->
	    let cmp = R.compare a b in
	    if cmp = 0 then
	      if m = n then di_un (l1,(a,m)::c,l2) (r,s)
	      else if m > n then di_un ((a,m-n)::l1,(a,n)::c,l2) (r,s)
	      else di_un (l1,(b,n)::c,(b,n-m)::l2) (r,s)
	      else if cmp > 0 then di_un ((a,m)::l1,c,l2) (r,(b,n)::s)
	      else di_un (l1,c,(b,n)::l2) ((a,m)::r,s)
      in di_un ([],[],[]) (l_1,l_2)

    exception List_minus_exn
    let list_minus l_1 l_2 = 
      let rec di_un l1 l_1 l_2 = 
        match l_1, l_2 with
	    [],[] -> l1
	  | l, [] -> l @ l1
	  | [], l -> raise List_minus_exn
	  | (a,m)::r, (b,n)::s ->
	    let cmp = R.compare a b in
	    if cmp = 0 then
	      if m = n then di_un l1 r s
	      else if m > n then di_un ((a,m-n)::l1) r s
	      else raise List_minus_exn
	      else if cmp > 0 then di_un ((a,m)::l1) r ((b,n)::s)
	      else raise List_minus_exn
      in di_un [] l_1 l_2
        
    let apply_rs r rls = 
      let fp = ref true in
      let r = ref r in
      let ex = ref Ex.empty in
      let rec apply_rule ((p, v, dep) as rul) =
	let c = Ac.compare !r p in
	if c = 0 then begin
          r := {!r with l=[v, 1]};
          ex := Ex.union !ex dep
        end
	else if c < 0 then raise Exit
	else 
          try 
            r := {!r with l = Ac.add !r.h (v, 1) (list_minus !r.l p.l)};
            ex := Ex.union !ex dep;
	    fp := false;
            apply_rule rul
          with List_minus_exn -> ()
      in
      let rec fixpoint () = 
        (try SetRL.iter apply_rule rls with Exit -> ());
	if !fp then !r, !ex else (fp := true; fixpoint ())
      in fixpoint()

    let filter_leaves r = 
      L.fold_left 
	(fun (p,q) r -> match R.ac_extract r with 
	  | None    -> SetR.add r p, q
	  | Some ac -> p, SetAc.add ac q
	)(SetR.empty,SetAc.empty) (R.leaves r)
	
    let canon_empty st env = 	
      SetR.fold
	(fun p ((z, ex) as acc) -> 
          let q, ex_q = lookup_by_r p env in 
	  if R.equal p q then acc else (p,q)::z, Ex.union ex_q ex)
	st ([], Ex.empty)

    let canon_ac st env = 
      SetAc.fold
	(fun ac (z,ex) ->
	  let rac, ex_ac = apply_rs ac (RS.find ac.h env.ac_rs) in
	  if Ac.compare ac rac = 0 then z, ex
	  else (R.color ac, R.color rac) :: z, Ex.union ex ex_ac)
        st ([], Ex.empty)
	
    let canon_aux rx = L.fold_left (fun r (p,v) -> R.subst p v r) rx
      
    let rec canon env r ex_r = 
      let se, sac = filter_leaves r in
      let subst, ex_subst = canon_empty se env in
      let sac, ex_ac = canon_ac sac env in (* explications? *)
      let r2 = canon_aux (canon_aux r sac) subst in
      let ex_r2 = Ex.union (Ex.union ex_r ex_subst) ex_ac in
      if R.equal r r2 then r2, ex_r2 else canon env r2 ex_r2

    let canon env r =
      let rr, ex = canon env r Ex.empty in
      if rewriting && verbose then 
        fprintf fmt "canon %a = %a@." R.print r R.print rr;
      rr,ex

    let find_or_canon env r =
      try MapR.find r env.repr with Not_found -> canon env r

    let init_leaf env p = 
      if MapR.mem p env.repr then env 
      else begin
        if debug_uf then fprintf fmt "init_leaf: %a@." R.print p;
	{ env with
	    repr    = MapR.add p (p, Ex.empty) env.repr;
	    classes = update_classes p p env.classes;
	    gamma   = add_to_gamma p p env.gamma ;
	    neqs    = update_neqs p p Ex.empty env } 
      end
          
    let init_term env t = 
      let mkr, ctx = R.make t in
      let rp, ex = canon env mkr in
      {env with
	make    = MapT.add t mkr env.make; 
	repr    = MapR.add mkr (rp,ex) env.repr;
	classes = add_to_classes t rp env.classes;
	gamma   = add_to_gamma mkr rp env.gamma;
	neqs    = 
	  if MapR.mem rp env.neqs then env.neqs 
	  else MapR.add rp MapL.empty env.neqs}, ctx


    let head_cp eqs env (({h=h} as ac), v, dep) = 
      if RS.mem h env.ac_rs then
        SetRL.iter
	  (fun (g, d, dep_rl) ->
	     match disjoint_union ac.l g.l with
	       | _  , [] , _  -> ()
	       | l1 , cm , l2 -> 
		   let rx = R.color {ac with l = Ac.add h (d,1) l1} in
		   let ry = R.color {g  with l = Ac.add h (v,1) l2} in
                   if debug_uf then
                     fprintf fmt "[uf] critical pair: %a = %a@." 
                       R.print rx R.print ry;
                   if not (R.equal rx ry) then 
                     Queue.push (rx, ry, Ex.union dep dep_rl) eqs
	  )(RS.find h env.ac_rs)

	
    let comp_collapse eqs env (p, v, dep) = 
      RS.fold
	(fun h rls env ->
          SetRL.fold
	    (fun ((g, d, dep_rl) as rul) env ->
	      let env = {env with ac_rs = RS.remove_rule rul env.ac_rs} in
	      let gx = R.color g in
	      let g2, ex_g2 = canon env (Ac.subst p v g) in
	      let d2, ex_d2 = canon env (R.subst p v d) in
	      if R.equal g2 gx then (* compose *)
                let ex = Ex.union ex_d2 (Ex.union dep_rl dep) in
	        {env with ac_rs = RS.add_rule (g,d2, ex) env.ac_rs}
	      else (* collapse *)
                begin
                  if debug_ac then
                    fprintf fmt "[uf] collapse: %a = %a@."
		      R.print g2 R.print d2;
                  let ex = Ex.union 
		    (Ex.union ex_g2 ex_d2) (Ex.union dep_rl dep) in
                  Queue.push (g2, d2, ex) eqs;
	          env
                end
	    ) rls env
	) env.ac_rs env
	
    (* TODO explications: ajout de dep dans ac_rs *)
    let apply_sigma_ac eqs env ((p, v, dep) as sigma) = 
      match R.ac_extract p with
	| None -> 
	    comp_collapse eqs env sigma
	| Some r -> 
	    let env = {env with ac_rs = RS.add_rule (r, v, dep) env.ac_rs} in
	    let env = comp_collapse eqs env sigma in
	    head_cp eqs env (r, v, dep);
            env
	    
    let update_aux dep set env= 
      SetRR.fold 
	(fun (rr, nrr) env -> 
	   { env with
	       neqs = update_neqs rr nrr dep env ;
	       classes = update_classes rr nrr env.classes})
	set env

    let apply_sigma_uf env (p, v, dep) =
      assert (MapR.mem p env.gamma);
      let use_p = MapR.find p env.gamma in
      try 
	let env, tch, neqs_to_up = SetR.fold 
	  (fun r (env, touched, neqs_to_up) -> 
	     let rr, ex = MapR.find r env.repr in
	     let nrr = R.subst p v rr in
	     if R.equal rr nrr then env, touched, neqs_to_up
	     else 
	       let ex  = Ex.union ex dep in
               let env = 
		 {env with
		   repr = MapR.add r (nrr, ex) env .repr;
		   gamma = add_to_gamma r nrr env.gamma } 
	       in
	       env, (r, nrr, ex)::touched, SetRR.add (rr, nrr) neqs_to_up
	  ) use_p (env, [], SetRR.empty) in
	(* Correction : Do not update neqs twice for the same r *)
	update_aux dep neqs_to_up env, tch 
	
      with Not_found -> assert false

    let up_uf_rs dep env tch =
      if RS.is_empty env.ac_rs then env, tch
      else
	let env, tch, neqs_to_up = MapR.fold
	  (fun r (rr,ex) (env,tch,neqs_to_up) ->
	     let nrr, ex_nrr = canon env rr in
	     if R.equal nrr rr then env, tch, neqs_to_up
	     else 
	       let ex = Ex.union ex ex_nrr in
               let env = 
		 {env with
	            repr = MapR.add r (nrr, ex) env.repr;
	            gamma = add_to_gamma r nrr env.gamma }
               in
               env, (r,[r, nrr, ex],nrr)::tch, SetRR.add (rr, nrr) neqs_to_up
	  ) env.repr (env, tch, SetRR.empty)
        in 
        (* Correction : Do not update neqs twice for the same r *)
	update_aux dep neqs_to_up env, tch 
	

	  
    let apply_sigma eqs env tch ((p, v, dep) as sigma) = 
      let env = init_leaf env p in
      let env = apply_sigma_ac eqs env sigma in
      let env, touched = apply_sigma_uf env sigma in 
      up_uf_rs dep env ((p, touched, v) :: tch)
	
  end
    
  let add env t = 
    if MapT.mem t env.make then env, [] else Env.init_term env t

  let ac_solve eqs dep (env, tch) (p, v) = 
    if debug_uf then 
      printf "[uf] ac-solve: %a |-> %a %a@." R.print p R.print v Ex.print dep;
    assert ( let rp, _ = Env.find_or_canon env p in R.equal p rp);
    let rv, ex_rv = Env.find_or_canon env v in
    let dep = Ex.union ex_rv dep in
    Env.apply_sigma eqs env tch (p, rv, dep)

  let x_solve env r1 r2 dep = 
    let rr1, ex_r1 = Env.find_or_canon env r1 in
    let rr2, ex_r2 = Env.find_or_canon env r2 in
    let dep = Ex.union dep (Ex.union ex_r1 ex_r2) in
    if debug_uf then 
      printf "[uf] x-solve: %a = %a %a@."
	R.print rr1 R.print rr2 Ex.print dep;
    if R.equal rr1 rr2 then [] (* Remove rule *)
    else 
      begin
	ignore (Env.update_neqs rr1 rr2 dep env);
        try R.solve rr1 rr2 
	with Unsolvable -> raise (Inconsistent dep)
      end
        
  let rec ac_x eqs env tch = 
    if Queue.is_empty eqs then env, tch
    else 
      let r1, r2, dep = Queue.pop eqs in
      if debug_uf then 
	printf "[uf] ac(x): delta (%a) = delta (%a)@." 
	  R.print r1 R.print r2;
      let sbs = x_solve env r1 r2 dep in
      let env, tch = List.fold_left (ac_solve eqs dep) (env, tch) sbs in
      if debug_uf then Print.all fmt env;
      ac_x eqs env tch
      
  let union env r1 r2 dep =
    let equations = Queue.create () in 
    Queue.push (r1,r2, dep) equations;
    ac_x equations env []

  let rec distinct env rl dep =
    let d = Lit.make (Literal.Distinct (false,rl)) in
    if debug_uf then fprintf fmt "[uf] distinct %a@." Lit.print d;
    let neqs, _, newds = 
      List.fold_left
	(fun (neqs, mapr, newds) r -> 
	   let rr, ex = Env.find_or_canon env r in 
	   try 
	     raise (Inconsistent (Ex.union ex (MapR.find rr mapr)))
	   with Not_found ->
	     let uex = Ex.union ex dep in
	     let mdis = 
	       try MapR.find rr neqs with Not_found -> MapL.empty in
	     let mdis = 
	       try 
		 MapL.add d (Ex.merge uex (MapL.find d mdis)) mdis
	       with Not_found -> 
		 MapL.add d uex mdis
	     in
	     MapR.add rr mdis neqs, MapR.add rr uex mapr, (rr, ex, mapr)::newds
	)
	(env.neqs, MapR.empty, [])
	rl
    in
    let env = { env with neqs = neqs } in
    List.fold_left 
      (fun env (r1, ex1, mapr) -> 
	 MapR.fold (fun r2 ex2 env -> 
		      let ex = Ex.union ex1 (Ex.union ex2 dep) in
		      try match R.solve r1 r2 with
			| [a, b] -> 
			    if (R.equal a r1 && R.equal b r2) ||
			      (R.equal a r2 && R.equal b r1) then env
			    else
			      distinct env [a; b] ex
			| []  -> raise (Inconsistent ex) 
			| _   -> env
		      with Unsolvable -> env) mapr env)
      env newds
			  
  let are_equal env t1 t2 = 
    let r1, ex_r1 = Env.lookup_by_t t1 env in
    let r2, ex_r2 = Env.lookup_by_t t2 env in
    if R.equal r1 r2 then Yes(Ex.union ex_r1 ex_r2) else No

  let are_distinct env t1 t2 = 
    if debug_uf then
      printf " [uf] are_distinct %a %a @." T.print t1 T.print t2; 
    let r1, ex_r1 = Env.lookup_by_t t1 env in
    let r2, ex_r2 = Env.lookup_by_t t2 env in
    try
      ignore (union env r1 r2 (Ex.union ex_r1 ex_r2));
      No
    with Inconsistent ex -> Yes(ex)

  let class_of env t = 
    try 
      let rt, _ = MapR.find (MapT.find t env.make) env.repr in
      SetT.elements (MapR.find rt env.classes)
    with Not_found -> [t]
      
  let find env t = Env.lookup_by_t t env

  let find_r = Env.find_or_canon

  let print = Print.all 

  let mem = Env.mem

end
end
include (IMPLEMENTATION : INTERFACE)
end
and Use: sig
#0 "use.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

module T  : sig type t = Term.t end
module S  : sig type t = Symbols.t end
module ST : sig type elt = T.t type t = Term.Set.t end
module SA : Set.S with type elt = Literal.LT.t * Explanation.t
  
type elt = ST.t * SA.t
    
module Make :
  functor (X : Sig.X) ->
sig
  
  type t 
  val empty : t
  val find : X.r -> t -> elt
  val add : X.r -> elt -> t -> t
  val mem : X.r -> t -> bool
  val print : t -> unit
  val up_add : t -> ST.elt -> X.r -> X.r list -> t
      
  val congr_add : t -> X.r list -> ST.t
  
  val up_close_up :t -> X.r -> X.r -> t
  val congr_close_up : t -> X.r -> X.r list -> elt
end
end = struct
let _ = Printf.fprintf stderr "Executing use.ml\n%!"module type INTERFACE = sig
#0 "use.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

module T  : sig type t = Term.t end
module S  : sig type t = Symbols.t end
module ST : sig type elt = T.t type t = Term.Set.t end
module SA : Set.S with type elt = Literal.LT.t * Explanation.t
  
type elt = ST.t * SA.t
    
module Make :
  functor (X : Sig.X) ->
sig
  
  type t 
  val empty : t
  val find : X.r -> t -> elt
  val add : X.r -> elt -> t -> t
  val mem : X.r -> t -> bool
  val print : t -> unit
  val up_add : t -> ST.elt -> X.r -> X.r list -> t
      
  val congr_add : t -> X.r list -> ST.t
  
  val up_close_up :t -> X.r -> X.r -> t
  val congr_close_up : t -> X.r -> X.r list -> elt
end
end
module IMPLEMENTATION = struct
#0 "use.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Options
module F = Format
module L = List
module T = Term
module S = Symbols
module ST = T.Set
(* module SA = Literal.LT.Set *)

module SA = Set.Make(struct
  type t = Literal.LT.t * Explanation.t
  let compare (s1,_) (s2,_) = Literal.LT.compare s1 s2
end)

type elt = ST.t * SA.t
  
module Make (X : Sig.X) = struct

  let inter_tpl (x1,y1) (x2,y2) = ST.inter x1 x2, SA.inter y1 y2
  let union_tpl (x1,y1) (x2,y2) = ST.union x1 x2, SA.union y1 y2
  let leaves r = 
    let one, _ = X.make (T.make (Symbols.name "@bottom") [] Ty.Tint) in
    match X.leaves r with [] -> [one] | l -> l

  module G = Map.Make(struct type t = X.r include X end)

  open G

  type t = elt G.t

      
  let find k m = try find k m with Not_found -> (ST.empty,SA.empty)
      
  let add_term k t mp =
    let g_t,g_a = find k mp in add k (ST.add t g_t,g_a) mp
				 
  let up_add g t rt lvs = 
    let g = if mem rt g then g else add rt (ST.empty, SA.empty) g in
    L.fold_left (fun g x -> add_term x t g) g lvs 
      
  let congr_add g lvs = 
    match lvs with
	[]    -> ST.empty
      | x::ls -> 
	  L.fold_left 
	    (fun acc y -> ST.inter (fst(find y g)) acc)
	    (fst(find x g)) ls
	    
  let up_close_up g p v = 
    let lvs = leaves v in
    let g_p = find p g in
    L.fold_left (fun gg q -> add q (union_tpl g_p (find q g)) gg) g lvs
      
  let congr_close_up g p touched =
    let inter = function 
	[] -> (ST.empty, SA.empty)
      | rx::l -> 
	  L.fold_left (fun acc x ->inter_tpl acc (find x g))(find rx g) l
    in 
    L.fold_left 
      (fun (st,sa) tch -> union_tpl (st,sa)(inter (leaves tch)))
      (find p g) touched 
      
  let print g = 
    let sterms fmt = ST.iter (F.fprintf fmt "%a " T.print) in
    let satoms fmt = SA.iter (fun (a,e) -> 
      F.fprintf fmt "%a %a" Literal.LT.print a Explanation.print e) in
    F.fprintf fmt "@{<C.Bold>[use]@} gamma :\n";
    iter 
      (fun t (st,sa) -> 
	 F.fprintf fmt "%a is used by {%a} and {%a}\n"  
	   X.print t sterms st satoms sa
      ) g

  let mem = G.mem
  let add = G.add
  let empty = G.empty

end
end
include (IMPLEMENTATION : INTERFACE)
end
and Intervals: sig
#0 "intervals.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Num

type t

exception NotConsistent of Explanation.t
exception Not_a_float

val undefined : Ty.t -> t

val point : num -> Ty.t -> Explanation.t -> t

val doesnt_contain_0 : t -> Sig.answer

val is_strict_smaller : t -> t -> bool

val new_borne_sup : Explanation.t -> num -> is_le : bool -> t -> t

val new_borne_inf : Explanation.t -> num -> is_le : bool -> t -> t

val is_point : t -> (num * Explanation.t) option

val intersect : t -> t -> t

val exclude : t -> t -> t

val mult : t -> t -> t

val power : int -> t -> t

val sqrt : t -> t

val root : int -> t -> t 

val add : t -> t -> t

val scale : num -> t -> t

val print : Format.formatter -> t -> unit

val finite_size : t -> num option

val borne_inf : t -> num

val div : t -> t -> t
end = struct
let _ = Printf.fprintf stderr "Executing intervals.ml\n%!"module type INTERFACE = sig
#0 "intervals.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Num

type t

exception NotConsistent of Explanation.t
exception Not_a_float

val undefined : Ty.t -> t

val point : num -> Ty.t -> Explanation.t -> t

val doesnt_contain_0 : t -> Sig.answer

val is_strict_smaller : t -> t -> bool

val new_borne_sup : Explanation.t -> num -> is_le : bool -> t -> t

val new_borne_inf : Explanation.t -> num -> is_le : bool -> t -> t

val is_point : t -> (num * Explanation.t) option

val intersect : t -> t -> t

val exclude : t -> t -> t

val mult : t -> t -> t

val power : int -> t -> t

val sqrt : t -> t

val root : int -> t -> t 

val add : t -> t -> t

val scale : num -> t -> t

val print : Format.formatter -> t -> unit

val finite_size : t -> num option

val borne_inf : t -> num

val div : t -> t -> t
end
module IMPLEMENTATION = struct
#0 "intervals.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Num
open Format
open Options

type borne = Strict of (num * Explanation.t) | Large of (num * Explanation.t) 
	     | Pinfty | Minfty

let compare_bornes b1 b2 =
  match b1, b2 with
    | Minfty, Minfty | Pinfty, Pinfty -> 0
    | Minfty, _ | _, Pinfty -> -1
    | Pinfty, _ | _, Minfty -> 1
    | Strict (v1, _), Strict (v2, _) | Large (v1, _), Large (v2, _) 
    | Strict (v1, _), Large (v2, _) | Large (v1, _), Strict (v2, _) -> 
      compare_num v1 v2

let compare_bu_bl b1 b2 =
  match b1, b2 with
    | (Minfty | Pinfty), _ | _,(Minfty | Pinfty) 
    | Strict _, Strict _ | Large _, Large _ -> 
      compare_bornes b1 b2 
    | Strict (v1, _), Large (v2, _) | Large (v1, _), Strict (v2, _) ->
      let c = compare_num v1 v2 in
      if c = 0 then -1 else c
      
let compare_bl_bu b1 b2 =
  match b1, b2 with
    | (Minfty | Pinfty), _ | _,(Minfty | Pinfty) 
    | Strict _, Strict _ | Large _, Large _ -> 
      compare_bornes b1 b2 
    | Strict (v1, _), Large (v2, _) | Large (v1, _), Strict (v2, _) ->
      let c = compare_num v1 v2 in
      if c = 0 then 1 else c

let compare_bl_bl b1 b2 = 
  match b1, b2 with 
    | (Minfty | Pinfty), _ | _,(Minfty | Pinfty) 
    | Strict _, Strict _ | Large _, Large _ -> 
      compare_bornes b1 b2 
    | Strict (v1, _), Large (v2, _) ->
      let c = compare_num v1 v2 in
      if c = 0 then 1 else c
    | Large (v1, _), Strict (v2, _) ->
      let c = compare_num v1 v2 in
      if c = 0 then -1 else c

let compare_bu_bu b1 b2 =
  match b1, b2 with
    | (Minfty | Pinfty), _ | _,(Minfty | Pinfty) 
    | Strict _, Strict _ | Large _, Large _ -> 
      compare_bornes b1 b2 
    | Strict (v1, _), Large (v2, _) ->
      let c = compare_num v1 v2 in
      if c = 0 then -1 else c
    | Large (v1, _), Strict (v2, _) ->
      let c = compare_num v1 v2 in
      if c = 0 then 1 else c

(*      
module SB =
  Set.Make(struct
    type t = (borne * borne)
    let compare (l1,u1) (l2,u2) =
      let cl = compare_bornes l1 l2 in
      if cl <> 0 then cl
      else compare_bornes u1 u2
  end)
  *)

(* module SB =  *)
(*   Set.Make(struct  *)
(*     type t = borne *)
(*     let compare = compare_bornes  *)
(*   end) *)

type t = { 
  ints : (borne * borne) list;
  is_int : bool;
  expl: Explanation.t
}

exception EmptyInterval of Explanation.t
exception NotConsistent of Explanation.t
exception Not_a_float

let print_borne fmt = function
  | Minfty -> fprintf fmt "-inf" 
  | Pinfty -> fprintf fmt "+inf"
  | Strict (v, e) | Large (v, e) ->
    if verbose then fprintf fmt "%s %a" (string_of_num v) Explanation.print e
    else fprintf fmt "%s" (string_of_num v)
      
let print_interval fmt (b1,b2) =
  let c1, c2 = match b1, b2 with
    | Large _, Large _ -> '[', ']'
    | Large _, _ -> '[', '['
    | _, Large _ -> ']', ']'
    | _, _ -> ']', '['
  in 	    
  fprintf fmt "%c%a;%a%c" c1 print_borne b1 print_borne b2 c2
    
let print fmt {ints = ints; is_int = b; expl = e } = 
  List.iter (fun i -> fprintf fmt "%a" print_interval i) ints;
  if verbose then fprintf fmt " %a" Explanation.print e
  

let undefined ty = {
  ints = [Minfty, Pinfty];
  is_int =  ty  = Ty.Tint;
  expl = Explanation.empty
}

let point b ty e = {
  ints = [Large (b, e), Large (b, e)]; 
  is_int = ty  = Ty.Tint;
  expl = Explanation.empty
}

let explain_borne = function
  | Large (_, e) | Strict (_, e) -> e
  | _ -> Explanation.empty

let borne_of k e n = if k then Large (n, e) else Strict (n, e)

let is_point { ints = l; expl = e } =
  match l with
    | [Large (v1, e1) , Large (v2, e2)] when v1 =/ v2 ->
      Some (v1, Explanation.union e2 (Explanation.union e1 e))
    | _ -> None

let check_one_interval b1 b2 is_int =
    match b1, b2 with
      | Pinfty, _ | _, Minfty  -> raise (EmptyInterval Explanation.empty)
      | (Strict (v1, e1) | Large (v1,e1)), (Strict (v2, e2) | Large (v2, e2)) ->
	  let c = compare_num v1 v2 in 
	  if c > 0 then raise 
	    (EmptyInterval (Explanation.union e2 e1));
	  if c = 0 then begin
	    match b1, b2 with
	      | Large _, Large _ when not is_int || is_integer_num v1 ->
		  ()
	      | _ -> raise (EmptyInterval (Explanation.union e2 e1))
	  end
      | _ -> ()

let min_borne b1 b2 = 
  match b1, b2 with
    | Minfty , _ | _ , Minfty -> Minfty
    | b , Pinfty | Pinfty, b -> b
    | (Strict (v1, _) | Large (v1, _)) , (Strict (v2, _) | Large (v2, _)) -> 
	let c = compare_num v1 v2 in
	if c < 0 then b1
	else if c > 0 then b2
	else match b1, b2 with 
	  | (Strict _ as b) , _ | _, (Strict _ as b) -> b
	  | _, _ -> b1
 
let max_borne b1 b2 = 
  match b1, b2 with
    | Pinfty , _ | _ , Pinfty -> Pinfty
    | b , Minfty | Minfty, b -> b
    | (Strict (v1, _) | Large (v1, _)) , (Strict (v2, _) | Large (v2, _)) -> 
	let c = compare_num v1 v2 in
	if c > 0 then b1
	else if c < 0 then b2
	else match b1, b2 with 
	  | (Strict _ as b) , _ | _, (Strict _ as b) -> b
	  | _, _ -> b1
	
let pos_borne b1 =
  compare_bornes b1 (borne_of true Explanation.empty (Int 0)) >= 0
let pos_borne_strict b1 = 
  compare_bornes b1 (borne_of true Explanation.empty (Int 0)) > 0
let neg_borne b1 = 
  compare_bornes b1 (borne_of true Explanation.empty (Int 0)) <= 0
let neg_borne_strict b1 = 
  compare_bornes b1 (borne_of true Explanation.empty (Int 0)) < 0
let zero_borne b1 = 
  compare_bornes b1 (borne_of true Explanation.empty (Int 0)) = 0

exception Found of Sig.answer

let doesnt_contain_0 {ints=l} =
  try
    let max = List.fold_left
      (fun old_u (l, u) -> 
	if neg_borne l && pos_borne u then raise (Found Sig.No);
	if neg_borne_strict old_u && pos_borne_strict l then 
	  raise (Found 
		   (Sig.Yes 
		      (Explanation.union 
			 (explain_borne old_u) (explain_borne l))));
	u) Minfty l in
    if neg_borne_strict max then Sig.Yes (explain_borne max)
    else Sig.No
  with Found ans -> ans

let is_strict_smaller i1 i2 =
  match i1, i2 with
    | _, [] -> false
    | [], _ -> true
    | _ ->
      try
	List.iter2 (fun (l1, u1) (l2, u2) ->
	  if compare_bornes l1 l2 > 0 || compare_bornes u1 u2 < 0
	  then raise Exit
	) i1 i2;
	false
      with 
	| Exit -> true
	| Invalid_argument _ -> List.length i1 > List.length i2

let is_strict_smaller {ints=i1} {ints=i2} = 
  is_strict_smaller i1 i2

(*      
  let inf_greater =
      | (b1,_)::_, (b2,_)::_ ->compare_bornes b1 b2 > 0
  in
  let sup_lesser =
    match List.rev i1, List.rev i2 with
      | _, [] -> false
      | [], _ -> true
      | (_,b1)::_, (_,b2)::_ -> compare_bornes b1 b2 < 0
  in
  inf_greater || sup_lesser
*)

let rec union_bornes l =
  match l with
    | [] | [_] -> l
    | (l1, u1)::((l2, u2)::r as r2) ->
	if compare_bornes u1 l2 < 0 then
	  (l1, u1)::(union_bornes r2)
	else if compare_bornes u1 u2 > 0 then
	  union_bornes ((l1, u1)::r)
	else
	  union_bornes ((l1, u2)::r)

let union ({ints = l} as uints) =
  let l = List.sort (fun (l1, _) (l2, _) -> compare_bornes l1 l2) l in
  { uints with ints = union_bornes l }

let add_borne b1 b2 =
  match b1,b2 with
    | Minfty, Pinfty | Pinfty, Minfty -> assert false
    | Minfty, _ | _, Minfty -> Minfty
    | Pinfty, _ | _, Pinfty -> Pinfty
    | Large (v1, e1), Large (v2, e2) -> 
      Large (v1 +/ v2, Explanation.union e1 e2)
    | (Large (v1, e1) | Strict (v1, e1)), (Large (v2, e2) | Strict (v2, e2)) ->
      Strict (v1 +/ v2, Explanation.union e1 e2)

let add_interval l (b1,b2) =
  List.fold_right
    (fun (b1', b2') l ->
       let l1 = ((add_borne b1 b1'),(add_borne b2 b2'))::l in
       union_bornes (l1)
    ) l []

let add {ints = l1; is_int = is_int; expl = e1} {ints = l2; expl = e2}=
  let l = 
    List.fold_left
      (fun l bs -> let i = add_interval l1 bs in i@l) [] l2 
  in
  union { ints = l ; is_int = is_int; expl = Explanation.union e1 e2 }

let minus_borne = function
  | Minfty -> Pinfty
  | Pinfty -> Minfty
  | Large (v, e) -> Large (minus_num v, e)
  | Strict (v, e) -> Strict (minus_num v, e)

let scale_borne n b =
  assert (n >=/ Int 0);
  if n =/ Int 0 then 
    match b with
    | Pinfty | Minfty -> Large (Int 0, Explanation.empty)
    | Large (_, e) | Strict (_, e) ->  Large (Int 0, e)
  else match b with
    | Pinfty | Minfty -> b
    | Large (v, e) -> Large (n */ v, e)
    | Strict (v, e) -> Strict (n */ v, e)

let scale_interval n (b1,b2) =
  if n </ Int 0 then
    (minus_borne (scale_borne (minus_num n) b2),
     minus_borne (scale_borne (minus_num n) b1))
  else (scale_borne n b1, scale_borne n b2)

(*
let scale_bexpl n be =
  SB.fold (fun (b1,b2) acc ->
    if n >=/ (Int 0) then SB.add ((scale_borne n b1), (scale_borne n b2)) acc
    else SB.add ((scale_borne n b2), (scale_borne n b1)) acc
  ) be SB.empty
  *)

let scale n uints =
  let l = List.map (scale_interval n) uints.ints in
  union { uints with ints = l; expl = uints.expl }
	    
let mult_borne b1 b2 =
  match b1,b2 with
    | Minfty, Pinfty | Pinfty, Minfty -> assert false
    | Minfty, b | b, Minfty ->
	if compare_bornes b (borne_of true Explanation.empty (Int 0)) = 0 then b
	else if pos_borne b then Minfty
	else Pinfty
    | Pinfty, b | b, Pinfty ->
	if compare_bornes b (borne_of true Explanation.empty (Int 0)) = 0 then b
	else if pos_borne b then Pinfty
	else Minfty
    | Strict (v1, e1), Strict (v2, e2) | Strict (v1, e1), Large (v2, e2)
    | Large (v1, e1), Strict (v2, e2) -> 
      Strict (v1 */ v2, Explanation.union e1 e2)
    | Large (v1, e1), Large (v2, e2) -> 
      Large (v1 */ v2, Explanation.union e1 e2)

let mult_borne_inf b1 b2 =
  match b1,b2 with
    | Minfty, Pinfty | Pinfty, Minfty -> Minfty
    | _, _ -> mult_borne b1 b2

let mult_borne_sup b1 b2 =
  match b1,b2 with
    | Minfty, Pinfty | Pinfty, Minfty -> Pinfty
    | _, _ -> mult_borne b1 b2

type interval_class = P | M | N | Z

let class_of (l,u) =
  if zero_borne l && zero_borne u then Z
  else if pos_borne l && pos_borne u then P
  else if neg_borne l && neg_borne u then N
  else M

let mult_bornes (a,b) (c,d) =
  (* see util/intervals_mult.png *)
  match class_of (a,b), class_of (c,d) with
    | P, P -> mult_borne_inf a c, mult_borne_sup b d
    | P, M -> mult_borne_inf b c, mult_borne_sup b d
    | P, N -> mult_borne_inf b c, mult_borne_sup a d
    | M, P -> mult_borne_inf a d, mult_borne_sup b d
    | M, M -> 
      min_borne (mult_borne_inf a d) (mult_borne_inf b c),
      max_borne (mult_borne_sup a c) (mult_borne_sup b d)
    | M, N -> mult_borne_inf b c, mult_borne_sup a c
    | N, P -> mult_borne_inf a d, mult_borne_sup b c
    | N, M -> mult_borne_inf a d, mult_borne_sup a c
    | N, N -> mult_borne_inf b d, mult_borne_sup a c
    | Z, (P | M | N | Z) -> (a, b)
    | (P | M | N ), Z -> (c, d)
      
let rec power_borne_inf p b =
  match p with
    | 1 -> b
    | p -> mult_borne_inf b (power_borne_inf (p-1) b)

let rec power_borne_sup p b =
  match p with
    | 1 -> b
    | p -> mult_borne_sup b (power_borne_sup (p-1) b)

let max_merge b1 b2 =
  let ex = Explanation.union (explain_borne b1) (explain_borne b2) in
  let max = max_borne b1 b2 in
  match max with
    | Minfty | Pinfty -> max
    | Large (v, e) -> Large (v, ex)
    | Strict (v, e) -> Strict (v, ex)

let power_bornes p (b1,b2) =
  if neg_borne b1 && pos_borne b2 then
    match p with
      | 0 -> assert false
      | p when p mod 2 = 0 ->
	  (* max_merge to have explanations !!! *)
	  let m = max_merge (power_borne_sup p b1) (power_borne_sup p b2) in
	  (Large (Int 0, Explanation.empty), m)
      | _ -> (power_borne_inf p b1, power_borne_sup p b2)
  else if pos_borne b1 && pos_borne b2 then
    (power_borne_inf p b1, power_borne_sup p b2)
  else if neg_borne b1 && neg_borne b2 then
    match p with
      | 0 -> assert false
      | p when p mod 2 = 0 -> (power_borne_inf p b2, power_borne_sup p b1)
      | _ -> (power_borne_inf p b1, power_borne_sup p b2)
  else assert false
    
(* let intersect2 (l1, u1) (l2, u2) = (max_borne l1 l2, min_borne u1 u2) *)

let int_of_borne_inf b =
  match b with
    | Minfty | Pinfty -> b
    | Large (v, e) -> Large (ceiling_num v, e)
    | Strict (v, e) ->
	let v' = ceiling_num v in
	if v' >/ v then Large (v', e) else Large (v +/ (Int 1), e) 

let int_of_borne_sup b =
  match b with
    | Minfty | Pinfty -> b
    | Large (v, e) -> Large (floor_num v, e)
    | Strict (v, e) ->
	let v' = floor_num v in
	if v' </ v then Large (v', e) else Large (v -/ (Int 1), e) 

let int_div_of_borne_inf b =
  match b with
    | Minfty | Pinfty -> b
    | Large (v, e) -> Large (floor_num v, e)
    | Strict (v, e) ->
	let v' = floor_num v in
	if v' >/ v then Large (v', e) else Large (v +/ (Int 1), e) 

let int_div_of_borne_sup b =
  match b with
    | Minfty | Pinfty -> b
    | Large (v, e) -> Large (floor_num v, e)
    | Strict (v, e) ->
	let v' = floor_num v in
	if v' </ v then Large (v', e) else Large (v -/ (Int 1), e)

let int_bornes l u = 
  int_of_borne_inf l, int_of_borne_sup u

let int_div_bornes l u = 
  int_div_of_borne_inf l, int_div_of_borne_sup u

(*
let expl_of_bexpl be =
  SB.fold (fun (b1,b2) acc -> 
    let acc = match b1 with
      | Large (_,e1) | Strict (_, e1) -> Explanation.union e1 acc
      | _ -> acc in
    match b2 with
      | Large (_,e2) | Strict (_, e2) -> Explanation.union e2 acc
      | _ -> acc
  ) be Explanation.empty
*)

(*
let intersect_bornes (b1, b2) {ints = l; is_int = is_int; bexpl = bexpl} =
  let l = List.map (intersect2 (b1, b2)) l in
  let l, be = 
    List.fold_right
      (fun (l, u) (l', be) -> try
	 let l,u = if is_int then int_bornes l u else l,u in
	 check_one_interval l u is_int;
	 (l, u)::l', be
       with EmptyInterval be' -> (l', SB.union be be')
      ) l ([], SB.empty) 
  in
  let l = union_bornes l in
  (*debug: 
     let s = if is_strict_smaller l old.ints then "<" else ">=" in
     fprintf fmt "%a %s %a@." print {ints=l;is_int=is_int;expl=expl}
       s print old;
  let e = 
    if is_strict_smaller l old.ints then Explanation.union e expl
    else e in 
  if l = [] then raise (NotConsistent e)
  else *)
  { ints = l; is_int = is_int; bexpl = (SB.union be bexpl) }
*)

(*
let intersect ({ints=l1} as uints1) ({ints=l2} as uints2) =
  (*fprintf fmt "%a inter %a (with %a) = " print uints1 print uints2 Explanation.print expl;*)
  let u =
    List.fold_left
      (fun u' bs ->
	let ui = intersect_bornes bs uints2 in
	{ u' with ints = (u'.ints)@(ui.ints);
	  expl = Explanation.union ui.expl u'.expl }
      ) {ints = []; is_int = uints1.is_int; expl = Explanation.empty}
      uints1.ints in
  let u = union u in
  let e = 
    if is_strict_smaller u uints2 then 
      Explanation.union uints1.expl uints2.expl
    else uints2.expl in
  let u = { u with expl = e } in
  (*fprintf fmt "%a@." print u;*)
  if u.ints = [] then raise (NotConsistent u.expl) else u
*)

(*
let build_relevant_bexpl be bexpl =
  SB.fold (fun (b1, b2) acc ->
    SB.fold (fun (b'1, b'2) acc' ->
      let b = if compare_bornes b2 b'1 < 0 || compare_bornes b1 b'2 > 0 
	then (b'1, b'2)
	else (min_borne b1 b'1, max_borne b2 b'2)
      in
      SB.add b acc') bexpl SB.empty
  ) be SB.empty
*)

let intersect ({ints=l1; expl=e1; is_int=is_int} as uints1) {ints=l2; expl=e2} =
  let rec step (l1,l2) acc expl =
    match l1, l2 with
      | (lo1,up1)::r1, (lo2,up2)::r2 ->
	let (lo1,up1), (lo2,up2) = 
	  if is_int then (int_bornes lo1 up1), (int_bornes lo2 up2)
	  else (lo1,up1), (lo2,up2) in
	let cll = compare_bl_bl lo1 lo2 in
	let cuu = compare_bu_bu up1 up2 in
	let clu = compare_bl_bu lo1 up2 in
	let cul = compare_bu_bl up1 lo2 in
	if cul < 0 then
	  let expl = 
	    (*if r1 <> [] && compare_bu_bl (snd (List.hd r1)) lo2 < 0 then expl
	      else Explanation.union (explain_borne up1) 
	      (Explanation.union (explain_borne lo2) expl) *)
	    if r1 = [] || (r1 <> [] && acc = [] &&
		not (compare_bl_bu lo2 (snd (List.hd r1)) > 0)) then
	      Explanation.union (explain_borne up1) 
		(Explanation.union (explain_borne lo2) expl) 
	    else expl
	  in
	  step (r1, l2) acc expl
	else if clu > 0 then 
	  let expl = 
	    (*if r2 <> [] && compare_bu_bl (snd (List.hd r2)) lo1 < 0 then expl
	      else Explanation.union (explain_borne up2) 
	      (Explanation.union (explain_borne lo1) expl) *)
	    if r2 = [] || (r2 <> [] && acc = [] &&
		not (compare_bl_bu lo1 (snd (List.hd r2)) > 0)) then 
	      Explanation.union (explain_borne up2) 
		(Explanation.union (explain_borne lo1) expl)
	    else expl 
	  in
	  step (l1, r2) acc expl
	else if cll <= 0 && cuu >= 0 then 
	  step (l1, r2) ((lo2,up2)::acc) expl
	else if cll >= 0 && cuu <= 0 then 
	  step (r1, l2) ((lo1,up1)::acc) expl
	else if cll <= 0 && cuu <= 0 && cul >= 0 then 
	  step (r1, l2) ((lo2,up1)::acc) expl
	else if cll >= 0 && cuu >= 0 && clu <= 0 then 
	  step (l1, r2) ((lo1,up2)::acc) expl
	else assert false
      | [], _ | _, [] ->  List.rev acc, expl 
    in
  let l, expl = step (l1,l2) [] (Explanation.union e1 e2) in
  if l = [] then raise (NotConsistent expl)
  else { uints1 with ints = l; expl = expl }


let new_borne_sup expl b ~is_le uints =
  intersect 
    { ints = [Minfty, (borne_of is_le expl b)];
      is_int = uints.is_int;
      expl = Explanation.empty } uints
(* let e =
    if is_strict_smaller new_u uints then Explanation.union expl uints.expl
    else uints.expl in 
  if new_u.ints = [] then raise (NotConsistent (expl_of_bexpl new_u.bexpl))
  else new_u *)

let new_borne_inf expl b ~is_le uints =
  intersect 
    { ints = [(borne_of is_le expl b), Pinfty];
      is_int = uints.is_int;
      expl = Explanation.empty } uints
  (* let e =
     if is_strict_smaller new_u uints then Explanation.union expl uints.expl
    else uints.expl in
  if new_u.ints = [] then raise (NotConsistent (expl_of_bexpl new_u.bexpl))
  else new_u *)


let complement ({ints=l; expl=e} as uints) =
  let rec step l prev acc =
    match l with
      | (b1,b2)::r ->
	let bu = match b1 with
	  | Strict v -> Large v
	  | Large v -> Strict v
	  | _ -> b1 in
	let bl = match b2 with
	  | Strict v -> Large v
	  | Large v -> Strict v
	  | _ -> b2 in
	if bu = Minfty then step r bl acc
	else step r bl ((prev, bu)::acc)
      | [] -> 
	if prev = Pinfty then List.rev acc
	else List.rev ((prev, Pinfty)::acc)
  in
  { uints with ints = step l Minfty [] }
    
(*
let exclude_bornes (b1,b2) ui =
  let bu = match b1 with
    | Strict v -> Large v
    | Large v -> Strict v
    | _ -> b1 in
  let bl = match b2 with
    | Strict v -> Large v
    | Large v -> Strict v
    | _ -> b2 in
  let u1 = intersect_bornes (Minfty, bu) ui in
  let u2 = intersect_bornes (bl, Pinfty) ui in
  let u = {ui with ints = u1.ints@u2.ints;
    expl = Explanation.union u1.expl u2.expl} in
  if u.ints = [] then raise (NotConsistent u.expl) else u
    
let exclude uints1 uints2 =
  let u = 
    union (List.fold_left 
	     (fun u bs ->
	       exclude_bornes bs u) uints2 uints1.ints) in
  let e = 
    if is_strict_smaller u uints2 then 
      Explanation.union uints1.expl uints2.expl
    else uints2.expl in
  let u = { u with expl = e } in
  if u.ints = [] then raise (NotConsistent u.expl) else u
*)

let exclude uints1 uints2 =
  intersect (complement uints1) uints2 

let mult u1 u2 =
  let resl = 
    List.fold_left
      (fun l' (u,l) -> (List.map (mult_bornes (u,l)) u2.ints)@l') 
      [] u1.ints 
  in
  union { ints=resl; is_int = u1.is_int;
	  expl = Explanation.union u1.expl u2.expl }

let power n u =
  let l = List.map (power_bornes n) u.ints in
  union { u with ints = l }


let num_of_float x =
  if x = infinity or x = neg_infinity then raise Not_a_float;
  let (f, n) = frexp x in
  let z =
    Big_int.big_int_of_string
      (Int64.to_string (Int64.of_float (f *. 2. ** 52.))) in
  (*
    Si on a ocaml >= 3.11 on peut mettre (mieux) :
    let z =
      Big_int.big_int_of_int64
        (Int64.of_float (f *. 2. ** 52.)) in
  *)
  let factor = (Int 2) **/ (Int (n - 52)) in
  (Big_int z) */ factor

let root_num a n = 
  if a </ (Int 0) then assert false
  else if a =/ (Int 0) then (Int 0)
  else if n = 2 then num_of_float (sqrt (float_of_num a))
  else num_of_float ((float_of_num a) ** (1./. (float n)))

let root_default_num a n =
  let s = root_num a n in
  let d = a -/ (s **/ (Int n)) in
  if d >=/ (Int 0) then s else a // (s **/ ((Int n) -/ (Int 1)))

let root_exces_num a n =
  let s = root_num a n in
  let d = a -/ (s **/ (Int n)) in
  if d <=/ (Int 0) then s else a // (s **/ ((Int n) -/ (Int 1)))

let root_default_borne is_int x n =
  match x with
    | Pinfty -> Pinfty
    | Minfty -> Minfty
    | Large (v, e) | Strict (v, e) ->
	let s = if v >=/ (Int 0) then root_default_num v n
	else (minus_num (root_exces_num (minus_num v) n)) in
	if is_int then
	  let cs = ceiling_num s in
	  let cs2 = cs **/ (Int n) in
	  if v <=/ cs2 then Large (cs, e)
	  else Large (cs +/ (Int 1), e)
	else Large (s, e)

let root_exces_borne is_int x n =
  match x with
    | Pinfty -> Pinfty
    | Minfty -> Minfty
    | Large (v, e) | Strict (v, e) ->
	let s = if v >=/ (Int 0) then root_exces_num v n
	else (minus_num (root_default_num (minus_num v) n)) in
	if is_int then
	  let cs = floor_num s in
	  let cs2 = cs **/ (Int n) in
	  if v >=/ cs2 then Large (cs, e)
	  else Large (cs -/ (Int 1), e)
	else Large (s, e)

let sqrt_interval is_int (b1,b2) =
  let l1, u1 = (minus_borne (root_exces_borne is_int b2 2),
		minus_borne (root_default_borne is_int b1 2)) in
  let l2, u2 = (root_default_borne is_int b1 2,
		root_exces_borne is_int b2 2) in
  if compare_bornes l1 u1 > 0 then
    if compare_bornes l2 u2 > 0 then []
    else [l2,u2]
  else if compare_bornes l2 u2 > 0 then [l1, u1]
  else  union_bornes [(l1,u1); (l2, u2)]

let root_interval is_int (b1,b2) n =
  let u,l = (root_default_borne is_int b1 n, root_exces_borne is_int b2 n) in
  if compare_bornes u l > 0 then [] else [u,l]

let sqrt {ints = l; is_int = is_int; expl = e } =
  let l =
    List.fold_left
      (fun l' bs ->
	 (sqrt_interval is_int bs)@l'
      ) [] l in
  union { ints = l; is_int = is_int; expl = e }

let rec root n ({ints = l; is_int = is_int; expl = e} as u) =
  if n mod 2 = 0 then root (n/2) (sqrt u)
  else
    let l =
      List.fold_left
	(fun l' bs ->
	  (root_interval is_int bs n)@l'
	) [] l in
    union { ints = l; is_int = is_int; expl = e }
      
let finite_size {ints = l; is_int = is_int} =
  if (not is_int) then None
  else
    try
      let n =
	List.fold_left
	  (fun n (b1,b2) ->
	     match b1, b2 with
	       | Minfty, _ | _, Pinfty -> raise Exit
	       | Large (v1, _) , Large (v2, _) -> n +/ (v2 -/ v1 +/ (Int 1))
	       | _, _ -> assert false
	  ) (Int 0) l in
      Some n
    with Exit -> None
		 
let borne_inf = function
  | {ints = (Large (v, _), _)::_} -> v
  | _ -> invalid_arg "Intervals.borne_inf : No finite lower bound"



let inv_borne_inf b is_int ~other =
  match b with
    | Pinfty -> assert false
    | Minfty ->
      if is_int then Large (Int 0,  explain_borne other) 
      else Strict (Int 0, explain_borne other)
    | Strict (Int 0, e) | Large (Int 0, e) -> Pinfty
    | Strict (v, e) -> Strict (Int 1 // v, e)
    | Large (v, e) -> Large (Int 1 // v, e)

let inv_borne_sup b is_int ~other =
  match b with
    | Minfty -> assert false
    | Pinfty ->
      if is_int then Large (Int 0, explain_borne other)
      else Strict (Int 0, explain_borne other)
    | Strict (Int 0, e) | Large (Int 0, e) -> Minfty
    | Strict (v, e) -> Strict (Int 1 // v, e)
    | Large (v, e) -> Large (Int 1 // v, e)

let inv_bornes (l, u) is_int =
  inv_borne_sup u is_int ~other:l, inv_borne_inf l is_int ~other:u


let inv ({ints=l; is_int=is_int} as u) =
  try
    let l' = List.fold_left 
      (fun acc (l,u) ->
	if (pos_borne_strict l && pos_borne_strict u) 
	  || (neg_borne_strict l && neg_borne_strict u) then 
	  (inv_bornes (l, u) is_int) :: acc
	else raise Exit
      ) [] l in
    union { u with ints=l' }
  with Exit -> { u with ints = [Minfty, Pinfty]  }

let div i1 i2 =
  let inv_i2 = inv i2 in
  if inv_i2.ints = [Minfty, Pinfty] then inv_i2
  else
    let ({ints=l; is_int=is_int} as i) = mult i1 inv_i2 in
    let l = 
      if is_int then 
	List.map (fun (l,u) -> int_div_bornes l u) l
      else l in
    { i with ints = l }

	
end
include (IMPLEMENTATION : INTERFACE)
end
and Fm: sig
#0 "fm.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

module type EXTENDED_Polynome = sig
  include Polynome.T
  val poly_of : r -> t
  val alien_of : t -> r
end

module Make 
  (X : Sig.X)
  (P : EXTENDED_Polynome with type r = X.r) 
  : Sig.RELATION with type r = X.r
end = struct
let _ = Printf.fprintf stderr "Executing fm.ml\n%!"module type INTERFACE = sig
#0 "fm.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

module type EXTENDED_Polynome = sig
  include Polynome.T
  val poly_of : r -> t
  val alien_of : t -> r
end

module Make 
  (X : Sig.X)
  (P : EXTENDED_Polynome with type r = X.r) 
  : Sig.RELATION with type r = X.r
end
module IMPLEMENTATION = struct
#0 "fm.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Num
open Format
open Options
open Sig

let ale = Hstring.make "<=" 
let alt = Hstring.make "<"
let is_le n = Hstring.compare n ale = 0
let is_lt n = Hstring.compare n alt = 0

let (-@) l1 l2 = List.rev_append l1 l2

module L = Literal
module Sy = Symbols
  
exception NotConsistent of Literal.LT.Set.t

module type EXTENDED_Polynome = sig
  include Polynome.T
  val poly_of : r -> t
  val alien_of : t -> r
end

module Make 
  (X : Sig.X)
  (P : EXTENDED_Polynome with type r = X.r) = struct

  module MP = Map.Make(P)
  module SX = Set.Make(struct type t = X.r include X end)
  module MX = Map.Make(struct type t = X.r include X end)
  
  type r = P.r

  module LR = Literal.Make(struct type t = X.r include X end)

  module Seq = 
    Set.Make
      (struct
         type t = r L.view * L.LT.t option * Explanation.t
         let compare (a, _, _) (b, _, _) = 
	   LR.compare (LR.make a) (LR.make b)
       end)
      
  module Inequation = struct
    type t = { 
      ple0 : P.t; 
      is_le : bool;
      dep : (Literal.LT.t * num * P.t * bool) list;
      expl : Explanation.t
    }
	
    let print fmt ineq = fprintf fmt "%a %s 0 %a" P.print ineq.ple0
      (if ineq.is_le then "<=" else "<") Explanation.print ineq.expl

    let create p1 p2 is_le a expl = 
      let p = P.add p1 (P.mult (P.create [] (Int (-1)) (P.type_info p1)) p2) in
      { ple0 = p; is_le = is_le; dep = [a, Int 1, p, is_le]; expl = expl }

    let choose ineq = snd (P.choose ineq.ple0)

    let find x ineq = P.find x ineq.ple0

    let is_monomial ineq = P.is_monomial ineq.ple0

    let pos_neg mx { ple0 = p } = 
      List.fold_left (fun m (c,x) ->
	let cmp = compare_num c (Int 0) in
	if cmp = 0 then m
	else 
	  let (pos, neg) = try MX.find x m with Not_found -> (0,0) in
	  if cmp > 0 then MX.add x (pos+1, neg) m 
	  else MX.add x (pos, neg+1) m ) mx (fst (P.to_list p))
      
  end

  type t = { 
    inequations : (Literal.LT.t * Inequation.t) list ;
    monomes: (Intervals.t * SX.t) MX.t;
    polynomes : Intervals.t MP.t;
    known_eqs : SX.t;
  }

  module Debug = struct
 
    let list_of_ineqs fmt = List.iter (fprintf fmt "%a  " Inequation.print)

    let assume a = 
      if debug_fm then 
	fprintf fmt "[fm] We assume: %a@." LR.print (LR.make a)
	
    let cross x cpos cneg others ninqs =
      if debug_fm then begin
	fprintf fmt "[fm] We cross on %a@." X.print x;
	fprintf fmt "with:@.  cpos = %a@.  cneg = %a@.  others = %a@."
	  list_of_ineqs cpos list_of_ineqs cneg 
	  list_of_ineqs others;
	fprintf fmt "result:@.  ninqs = %a@."
	  list_of_ineqs ninqs
      end

    let print_use fmt use = 
      SX.iter (fprintf fmt "%a, " X.print) use

    let env env = 
      if debug_fm then begin
	fprintf fmt "------------- FM: inequations-------------------------@.";
        List.iter
          (fun (a,{Inequation.ple0=p; is_le=is_le}) ->
             fprintf fmt "%a%s0  |  %a@." 
               P.print p (if is_le then "<=" else "<") L.LT.print a
          )env.inequations;
        fprintf fmt "------------- FM: monomes ----------------------------@.";
	MX.iter 
	  (fun x (i, use) -> 
		fprintf fmt "%a : %a |-use-> {%a}@." 
		  X.print x Intervals.print i print_use use) 
	  env.monomes;
	fprintf fmt "------------- FM: polynomes---------------------------@.";
	MP.iter 
	  (fun p i -> 
		fprintf fmt "%a : %a@." 
		  P.print p Intervals.print i) 
	  env.polynomes;
	fprintf fmt "------------------------------------------------------@."
      end

    let implied_equalities l = 
      if debug_fm then 
        begin
          fprintf fmt "[fm] %d implied equalities@." (List.length l);
          List.iter 
	    (fun (ra, _, ex) -> 
               fprintf fmt "  %a %a@." 
		 LR.print (LR.make ra) Explanation.print ex) l
        end
  end
      
  let empty _ = { 
    inequations = [] ; 
    monomes = MX.empty ; 
    polynomes = MP.empty ; 
    known_eqs = SX.empty ; 
  }

  let replace_inequation env x ineq = 
    { env with
	inequations = (x, ineq)::(List.remove_assoc x env.inequations) }

(*
  let oldify_inequations env =
    { env with
	inequations = env.inequations@env.new_inequations;
      new_inequations = [] } *)
    
  let mult_bornes_vars vars monomes ty=
    List.fold_left
      (fun ui (y,n) ->
	 let ui' = try
	   fst (MX.find y monomes)
	 with Not_found -> Intervals.undefined ty
	 in
	 Intervals.mult ui (Intervals.power n ui')
      ) (Intervals.point (Int 1) ty Explanation.empty) vars 


  let intervals_from_monomes env p =
    let pl, v = P.to_list p in
    List.fold_left
      (fun i (a, x) ->
	 let i_x, _  = MX.find x env.monomes in
	 Intervals.add (Intervals.scale a i_x) i
      ) (Intervals.point v (P.type_info p) Explanation.empty) pl

  let rec add_monome expl use_x env x =
    try 
      let u, old_use_x = MX.find x env.monomes in
      { env with monomes = MX.add x (u, SX.union old_use_x use_x) env.monomes }
    with Not_found -> 
      update_monome expl use_x env x

  and init_monomes env p use_p expl = 
    List.fold_left
      (fun env (_, x) -> add_monome expl use_p env x)
      env (fst (P.to_list p))

  and init_alien expl p (normal_p, c, d) ty use_x env =
    let env = init_monomes env p use_x expl in
    let i = intervals_from_monomes env p in
    let i = 
      try 
	let old_i = MP.find normal_p env.polynomes in
	let old_i = Intervals.scale d
	  (Intervals.add old_i (Intervals.point c ty Explanation.empty)) in
	Intervals.intersect i old_i
      with Not_found -> i
    in
    env, i

      

  and update_monome expl use_x env x =
    let ty = X.type_info x in
    let ui, env = match  X.ac_extract x with
      | Some {h=h; l=l } 
	  when Symbols.equal h (Symbols.Op Symbols.Mult) ->
	let use_x = SX.singleton x in
	let env =
	  List.fold_left
	    (fun env (r,_) ->
	      update_monome expl use_x env r) env l in
	let m = mult_bornes_vars l env.monomes ty in
	m, env
      | _ ->
	match X.term_extract x with
	  | Some t ->
	    let use_x = SX.singleton x in
	    begin
	      match Term.view t with
		| {Term.f = (Sy.Op Sy.Div); xs = [a; b]} ->
		  let pa = P.poly_of (fst (X.make a)) in
		  let pb = P.poly_of (fst (X.make b)) in
		  let (pa', ca, da) as npa = P.normal_form_pos pa in
		  let (pb', cb, db) as npb = P.normal_form_pos pb in
		  let env, ia = init_alien expl pa npa ty use_x env in
		  let env, ib = init_alien expl pb npb ty use_x env in
		  let ia, ib = match Intervals.doesnt_contain_0 ib with
		    | Yes ex when Num.compare_num ca cb = 0 
			       && P.compare pa' pb' = 0 ->
		      let expl = Explanation.union ex expl in
		      Intervals.point da ty expl, Intervals.point db ty expl
		    | _ -> ia, ib
		  in
		  Intervals.div ia ib, env
		| _ -> Intervals.undefined ty, env
	    end
	  | _ -> Intervals.undefined ty, env
    in
    let u, use_x' =
      try MX.find x env.monomes
      with Not_found -> Intervals.undefined (X.type_info x), use_x in
    let ui = Intervals.intersect ui u in
    { env with monomes = MX.add x (ui, (SX.union use_x use_x')) env.monomes }

  let rec tighten_ac x env expl =
    let ty = X.type_info x in
    let u, use_x =
      try MX.find x env.monomes
      with Not_found -> Intervals.undefined ty, SX.empty in
    try
      match X.ac_extract x with
	| Some {h=h;t=t;l=[x,n]} 
            when Symbols.equal h (Symbols.Op Symbols.Mult) && n mod 2 = 0  ->
	  let u = Intervals.root n u in
	  let u, use_x =
	    let (pu, use_px) = 
	      try MX.find x env.monomes
	      with Not_found -> Intervals.undefined ty, SX.empty
	    in
	    Intervals.intersect u pu, use_px in
	  let env =
	    (* let u =  Intervals.new_borne_inf expl (Int 0) true u in *)
	    let env = { env with monomes = MX.add x (u, use_x) env.monomes } in
	    tighten_non_lin x use_x env expl
	  in env
	| Some {h=h;t=t;l=[x,n]} when Symbols.equal h (Symbols.Op Symbols.Mult)
	    && n > 2 ->
	  let u = Intervals.root n u in
	  let u, use_x = 
	    let pu, use_px =
	      try MX.find x env.monomes 
	      with Not_found -> Intervals.undefined ty, SX.empty
	    in
	    Intervals.intersect u pu, use_px in
	  let env = { env with monomes = MX.add x (u, use_x) env.monomes } in
	  tighten_non_lin x use_x env expl
	| _ -> env
    with Intervals.Not_a_float -> env
      

  and tighten_div x env expl =
    env

  and tighten_non_lin x use_x env expl =
    let env' = tighten_ac x env expl in
    let env' = tighten_div x env' expl in
    (*let use_x = SX.union use1_x use2_x in*)
     (* let i, _ = MX.find x env.monomes in *)
    SX.fold 
      (fun x acc -> 
	let _, use = MX.find x acc.monomes in
	(*if Intervals.is_strict_smaller new_i i then*)
	  update_monome expl use acc x
       (*else acc*))
      use_x env' 

  let update_ple0 env p is_le expl =
    if P.is_empty p then env
    else 
      let ty = P.type_info p in
      let a, _ = P.choose p in
      let p, change =
	if a </ Int 0 then
	  P.mult (P.create [] (Int (-1)) ty) p, true
	else p, false in
      let p, c, _ = P.normal_form p in
      let c = minus_num c in
      let u =
	if change then
	  Intervals.new_borne_inf expl c is_le (Intervals.undefined ty)
	else
	  Intervals.new_borne_sup expl c is_le (Intervals.undefined ty) in
      let u =
	try 
	  let pu = MP.find p env.polynomes in
	  let i = Intervals.intersect u pu in
	  i
	with Not_found -> u
      in
      { env with polynomes = MP.add p u env.polynomes }

  let update_polynomes env expl =
    let polynomes = MP.fold
      (fun p i polynomes ->
	 let new_i = intervals_from_monomes env p in
	 let i = Intervals.intersect new_i i in
	 MP.add p i polynomes
      ) env.polynomes env.polynomes in
    {env with polynomes = polynomes }


  let find_one_eq x u =
    match Intervals.is_point u with
      | Some (v, ex) when X.type_info x <> Ty.Tint or is_integer_num v ->
          let eq = 
	    L.Eq (x,(P.alien_of (P.create [] v (X.type_info x)))) in
	  Some (eq, None, ex)
      | _ -> None

  let find_eq eqs x u env =
    match find_one_eq x u with
      | None -> eqs
      | Some eq1 ->
	  begin
            match X.ac_extract x with
	      | Some {h = h; l = [y,n]} 
		  when Symbols.equal h (Symbols.Op Symbols.Mult) ->
		  let neweqs = try
		    let u, _ = MX.find y env.monomes in
		    match find_one_eq y u with
		      | None -> eq1::eqs
		      | Some eq2 -> eq1::eq2::eqs
		  with Not_found -> eq1::eqs
		  in neweqs
	      | _ -> eq1::eqs
	  end

  type ineq_status = 
    | Trivial_eq
    | Trivial_ineq of num
    | Bottom
    | Monome of num * P.r * num
    | Other

  let ineq_status ({Inequation.ple0 = p ; is_le = is_le} as ineq) = 
    match Inequation.is_monomial ineq with
	Some (a, x, v) -> Monome (a, x, v)
      | None -> 
	  if P.is_empty p then
	    let _, v = P.to_list p in 
	    let c = compare_num v (Int 0) in
	    if c > 0 || (c >=0 && not is_le) then Bottom
	    else 
	      if c = 0 && is_le then Trivial_eq
	      else Trivial_ineq v
	  else Other
	    
  (*let ineqs_from_dep dep borne_inf is_le =
    List.map
      (fun {poly_orig = p; coef = c} -> 
	 let (m,v,ty) = P.mult_const minusone p in
	 (* quelle valeur pour le ?????? *)
	 { ple0 = {poly = (m, v +/ (borne_inf // c), ty); le = is_le} ;
	   dep = []}
      )dep*)

  let mk_equality p =
    let r1 = P.alien_of p in
    let r2 = P.alien_of (P.create [] (Int 0) (P.type_info p)) in
    L.Eq (r1, r2)

  let fm_equalities env eqs { Inequation.ple0 = p; dep = dep; expl = ex } =
    let inqs, eqs =
      List.fold_left
	(fun (inqs, eqs) (a, _, p, _) -> 
           List.remove_assoc a inqs, (mk_equality p, Some a, ex) :: eqs
	) (env.inequations, eqs) dep
    in
    { env with inequations = inqs }, eqs

  let update_intervals env eqs expl (a, x, v) is_le =
    let uints, use_x = 
      match X.ac_extract x with
	| Some {h=h; l=l} 
	    when Symbols.equal h (Symbols.Op Symbols.Mult) ->
	    let u', use_x' = MX.find x env.monomes in
	    let m = mult_bornes_vars l env.monomes (X.type_info x) in
	    Intervals.intersect m u', use_x'
	| _ -> MX.find x env.monomes
    in
    let b = ((Int (-1)) */ v) // a in
    let u =
      if a >/ (Int 0) then
	Intervals.new_borne_sup expl b is_le uints
      else   
	Intervals.new_borne_inf expl b is_le uints in
    let env = { env with monomes = MX.add x (u, use_x) env.monomes } in
    let env =  tighten_non_lin x use_x env expl in
    env, (find_eq eqs x u env)
  
  let add_inequations acc lin expl = 
    List.fold_left
      (fun (env, eqs) ineq ->
	(* let expl = List.fold_left 
	  (fun expl (l,_,_,_) -> 
	    Explanation.union (*Explanation.everything*)
	      (Explanation.singleton (Formula.mk_lit l))
	      expl
	  ) expl ineq.Inequation.dep 
	in *)
	let expl = Explanation.union ineq.Inequation.expl expl in
	 match ineq_status ineq with
	   | Bottom           ->
	       raise (Exception.Inconsistent expl)
		 
	   | Trivial_eq       -> 
	       fm_equalities env eqs ineq
		 
	   | Trivial_ineq  c  ->
	       let n, pp = 
		 List.fold_left 
		   (fun ((n, pp) as acc) (_, _, p, is_le) ->  
		      if is_le then acc else 
			match pp with
			  | Some _ -> n+1, None
			  | None when n=0 -> 1, Some p
			  | _ -> n+1, None) (0,None) ineq.Inequation.dep
		    in
	       let env = 
		 List.fold_left
		   (fun env (_, coef, p, is_le) ->
		      let ty = P.type_info p in
		      let is_le = 
			match pp with 
			    Some x -> P.compare x p = 0 | _ -> is_le && n=0 
		      in
		      let p' = P.sub (P.create [] (c // coef) ty) p in
		      update_ple0 env p' is_le expl
		   ) env ineq.Inequation.dep
	       in
	       env, eqs

	   | Monome (a, x, v) ->
	       let env, eqs = 
		 update_intervals env eqs expl (a, x, v) ineq.Inequation.is_le
	       in
               
	       (*let env,eqs = update_bornes env eqs ((a,x),c) ineq.ple0.le in
		 let env,eqs = update_polynomes env eqs ineq in
		 env, pers_ineqs, eqs*)
	       env, eqs

	   | Other            -> 
	       env, eqs
	       (*t env,eqs = update_polynomes env eqs ineq in
	       env, pers_ineqs, eqs*)

	       
      ) acc lin

  let mult_list c = 
    List.map (fun (a, coef, p, is_le) -> (a, coef */ c, p, is_le))

  let div_by_pgcd (a, b) ty =
    try
      if ty = Ty.Tint then
	let p = Big_int.gcd_big_int (big_int_of_num a) (big_int_of_num b) in
	let p = num_of_big_int p in
	a // p, b // p
      else a, b
    with Failure "big_int_of_ratio" -> a, b

  let cross x cpos cneg = 
    let rec cross_rec acc = function 
      | [] -> acc
      | { Inequation.ple0 = p1; is_le = k1; dep = d1; expl = ex1 } :: l ->
	  let n1 = abs_num (P.find x p1) in
	  (* let ty = P.type_info p1 in *)
	  let acc = 
	    List.fold_left 
	      (fun acc {Inequation.ple0 = p2; is_le = k2; dep=d2; expl = ex2} ->
		 let n2 = abs_num (P.find x p2) in
		 (* let n1, n2 =  div_by_pgcd (n1, n2) ty in *)
		 let p = P.add
		   (P.mult (P.create [] n2 (P.type_info p2)) p1)
		   (P.mult (P.create [] n1 (P.type_info p1)) p2) in
		 let d1 = mult_list n2 d1 in
		 let d2 = mult_list n1 d2 in
		 let ni = 
		   { Inequation.ple0 = p;  is_le = k1&&k2; dep = d1 -@ d2;
		     expl = Explanation.union ex1 ex2 }
		 in 
		 ni::acc
	      ) acc cpos
	  in 
	  cross_rec acc l
    in
    cross_rec [] cneg

  let split x l = 
    let rec split_rec (cp, cn, co) ineq =
      try
	let a = Inequation.find x ineq in
	if a >/ (Int 0) then ineq::cp, cn, co 
	else cp, ineq::cn, co
      with Not_found ->	cp, cn, ineq::co
    in 
    List.fold_left split_rec ([], [], []) l

  let length s = SX.fold (fun _ acc -> acc+1) s 0          

  let choose_var l = 
    let pos_neg = List.fold_left Inequation.pos_neg MX.empty l in
    let xopt = MX.fold (fun x (pos, neg) acc ->
      match acc with
	| None -> Some (x, pos * neg)
	| Some (y, c') -> 
	  let c = pos * neg in 
	  if c < c' then Some (x, c) else acc
    ) pos_neg None in
    match xopt with
      | Some (x, _) -> x
      | None -> raise Not_found

  let rec fourier ( (env, eqs) as acc) l expl =
     match l with
      | [] -> acc
      | ineq :: l' ->
	try
	  (* let x = Inequation.choose ineq in *)
	  let x = choose_var l in
	  let cpos, cneg, others = split x l in
	  let ninqs = cross x cpos cneg in
	  Debug.cross x cpos cneg others ninqs;
	  let acc = add_inequations acc cpos expl in
	  let acc = add_inequations acc cneg expl in
	  fourier acc (ninqs -@ others) expl
	with Not_found -> add_inequations acc l expl

  (*
  let fm env eqs expl = 
    fourier (env, eqs)
      (List.map snd env.inequations)
      (List.map snd env.new_inequations) expl
*)

  let fm env eqs expl = 
    fourier (env, eqs) (List.map snd env.inequations) expl

  let is_num r = 
    let ty = X.type_info r in ty = Ty.Tint || ty = Ty.Treal

  let add_disequality env eqs p expl =
    let ty = P.type_info p in
    match P.to_list p with
      | ([], (Int 0)) ->
	  raise (Exception.Inconsistent expl)
      | ([], v) ->
	  env, eqs
      | ([a, x], v) -> 
	  let b = (minus_num v) // a in
	  let i1 = Intervals.point b ty expl in
	  let i2, use2 = 
	    try 
	      MX.find x env.monomes 
	    with Not_found -> Intervals.undefined ty, SX.empty
	  in
	  let i = Intervals.exclude i1 i2 in
	  let env ={ env with monomes = MX.add x (i,use2) env.monomes } in
	  let env = tighten_non_lin x use2 env expl in
	  env, find_eq eqs x i env
      | _ ->
	  let a, _ = P.choose p in
	  let p = if a >=/ Int 0 then p
	  else P.mult (P.create [] (Int (-1)) ty) p in
	  let p, c, _ = P.normal_form p in
	  let i1 = Intervals.point (minus_num c) ty expl in
	  let i2 = 
	    try 
	      MP.find p env.polynomes 
	    with Not_found -> Intervals.undefined ty
	  in
	  let i = Intervals.exclude i1 i2 in
	  let env ={ env with polynomes = MP.add p i env.polynomes } in
	  env, eqs
					      
  let add_equality env eqs p expl =
    let ty = P.type_info p in
    match P.to_list p with	
      | ([], Int 0) -> env, eqs
      | ([], v) ->
	  raise (Exception.Inconsistent expl)
      | ([a, x], v) -> 
	  let b = (minus_num v) // a in
	  let i = Intervals.point b ty expl in
	  let i, use = 
	    try 
	      let i', use' = MX.find x env.monomes in
	      Intervals.intersect i i', use'
	    with Not_found -> i, SX.empty
	  in
	  let env = { env with monomes = MX.add x (i, use) env.monomes} in
	  let env = tighten_non_lin x use env expl in
	  env, find_eq eqs x i env
      | _ ->
	  let a, _ = P.choose p in
	  let p = if a >=/ Int 0 then p
	  else P.mult (P.create [] (Int (-1)) ty) p in
	  let p, c, _ = P.normal_form p in
	  let i = Intervals.point (minus_num c) ty expl in
	  let i = 
	    try
	      let i' =  MP.find p env.polynomes in
	      Intervals.intersect i i'
	    with Not_found -> i
	  in
	  let env = { env with 
                        polynomes = MP.add p i env.polynomes;
                        known_eqs = SX.add (P.alien_of p) env.known_eqs
                    } in
	  env, eqs

  let normal_form a = match a with
    | L.Builtin (false, n, [r1; r2]) when is_le n && X.type_info r1 = Ty.Tint ->
        let pred_r1 = P.sub (P.poly_of r1) (P.create [] (Int 1) Ty.Tint) in
	L.Builtin (true, n, [r2; P.alien_of pred_r1])

    | L.Builtin (true, n, [r1; r2]) when 
	not (is_le n) && X.type_info r1 = Ty.Tint ->
        let pred_r2 = P.sub (P.poly_of r2) (P.create [] (Int 1) Ty.Tint) in
	L.Builtin (true, ale, [r1; P.alien_of pred_r2])

    | L.Builtin (false, n, [r1; r2]) when is_le n -> 
	L.Builtin (true, alt, [r2; r1])

    | L.Builtin (false, n, [r1; r2]) when is_lt n ->
	L.Builtin (true, ale, [r2; r1])

    | _ -> a
	  
  let remove_trivial_eqs eqs la =
      let set_of l =
        List.fold_left (fun s e -> Seq.add e s) Seq.empty l
      in
      Seq.elements (Seq.diff (set_of eqs) (set_of la))
          

  let equalities_from_polynomes env eqs =
    let known, eqs = 
      MP.fold
      (fun p i (knw, eqs) ->
        let xp = P.alien_of p in
         if SX.mem xp knw then knw, eqs
         else 
           match Intervals.is_point i with
             | Some (num, ex) ->
               let r2 = P.alien_of (P.create [] num (P.type_info p)) in
               SX.add xp knw, (L.Eq(xp, r2), None, ex) :: eqs
           | None -> knw, eqs
      ) env.polynomes  (env.known_eqs, eqs)
    in {env with known_eqs= known}, eqs



  let equalities_from_monomes env eqs =
    let known, eqs = 
      MX.fold
        (fun x (i,_) (knw, eqs) ->
          if SX.mem x knw then knw, eqs
          else 
            match Intervals.is_point i with
              | Some (num, ex) ->
                let r2 = P.alien_of (P.create [] num (X.type_info x)) in
                SX.add x knw, (L.Eq(x, r2), None, ex) :: eqs
              | None -> knw, eqs
        ) env.monomes  (env.known_eqs, eqs)
    in {env with known_eqs= known}, eqs

  let equalities_from_intervals env eqs =
    let env, eqs = equalities_from_polynomes env eqs in
    equalities_from_monomes env eqs

  let assume env la expl = 
    Debug.env env;
    (*let expl = 
      List.fold_left 
      (fun expl (a,_) ->
      Explanation.union 
      (Explanation.singleton (Formula.mk_lit a)) expl
      ) Explanation.empty env.inequations
      in*)
    let env, eqs, new_ineqs, expl =
      List.fold_left
	(fun (env, eqs, new_ineqs, expl) (a, root, e) ->
	   let a = normal_form a in
	   let expl = Explanation.union e expl in
	   (*let expl = match root with | Some a ->
	   (*Explanation.everything*) Explanation.union expl
	     (Explanation.singleton (Formula.mk_lit a)) | None -> expl
	     in*)
           if debug_fm then 
	     begin 
	       Debug.assume a;
	       fprintf fmt "explanations: %a@." Explanation.print expl
	     end;
	   try
             match a with
	       | L.Builtin(_, n, [r1;r2]) when is_le n || is_lt n ->
                   let root = match root with
	             | Some a -> a | None -> assert false in
		   let p1 = P.poly_of r1 in
		   let p2 = P.poly_of r2 in
		   let ineq = Inequation.create p1 p2 (is_le n) root expl in
		   let env =
		     init_monomes env ineq.Inequation.ple0 SX.empty expl in
		   let env =
		     update_ple0 env ineq.Inequation.ple0 (is_le n) expl in
		   let env = replace_inequation env root ineq in
		   env, eqs, true, expl

	       | L.Distinct (false, [r1; r2]) when is_num r1 && is_num r2 -> 
		   let p = P.sub (P.poly_of r1) (P.poly_of r2) in
		   let env = init_monomes env p SX.empty expl in
		   let env, eqs = add_disequality env eqs p expl in
                   env, eqs, new_ineqs, expl
		     
	       | L.Eq(r1, r2) when is_num r1 && is_num r2 -> 
		   let p = P.sub (P.poly_of r1) (P.poly_of r2) in
		   let env = init_monomes env p SX.empty expl in
		   let env, eqs = add_equality env eqs p expl in
                   env, eqs, new_ineqs, expl

	       | _ -> (env, eqs, new_ineqs, expl) 
		   
	   with Intervals.NotConsistent expl -> 	       
	     if debug_fm then 
	       fprintf fmt "interval inconsistent %a@." 
		 Explanation.print expl; 
	     raise (Exception.Inconsistent expl)
	)
	(env, [], false, expl) la 
	
    in
    (* explanations for new inequations *)
    (*let expl = if new_ineqs then 
      List.fold_left 
      (fun expl (a,_) ->
      Explanation.union 
      (Explanation.singleton (Formula.mk_lit a)) expl
      ) expl env.inequations
      else expl in*)
    if new_ineqs then 
      if debug_fm then 
	fprintf fmt "new explanations %a@." Explanation.print expl; 
    try
      (* we only call fm when new ineqs are assumed *)
      let env, eqs = if new_ineqs then fm env eqs expl else env, eqs in
      (* let env = oldify_inequations env in *)
      let env = update_polynomes env expl in
      let env, eqs = equalities_from_intervals env eqs in
      Debug.env env;
      let eqs = remove_trivial_eqs eqs la in
      Debug.implied_equalities eqs;
      env, eqs

    with Intervals.NotConsistent expl -> 
      if debug_fm then 
	fprintf fmt "interval inconsistent %a@." 
	  Explanation.print expl; 
      raise (Exception.Inconsistent expl)
      
  let query (a,r) env expl =
    try 
      ignore(assume env [a,r,Explanation.empty] expl); 
      No
    with Exception.Inconsistent expl -> Yes expl

  let case_split_polynomes env = 
    let o = MP.fold
      (fun p i o ->
	 match Intervals.finite_size i with
	   | Some s when s >/ (Int 1) ->
	       begin
		 match o with
		   | Some (s',p',n') when s' <=/ s -> o
		   | _ -> Some (s, p, Intervals.borne_inf i)
	       end
	   | _ -> o
      ) env.polynomes None in
    match o with 
      | Some (s,p,n) -> 
          let r1 = P.alien_of p in
	  let r2 = P.alien_of (P.create [] n  (P.type_info p)) in
	  if debug_fm then
	    fprintf fmt "[case-split] %a = %a@." X.print r1 X.print r2;
	  [(L.Eq(r1, r2), None), s]
      | None -> 
	  if debug_fm then fprintf fmt "[case-split] polynomes: nothing@.";
	  []

  let case_split_monomes env = 
    let o = MX.fold
      (fun x (i,_) o ->
	 match Intervals.finite_size i with
	   | Some s when s >/ (Int 1) ->
	       begin
		 match o with
		   | Some (s',p',n') when s' <=/ s -> o
		   | _ -> Some (s, x, Intervals.borne_inf i)
	       end
	   | _ -> o
      ) env.monomes None in
    match o with 
      | Some (s,x,n) -> 
          let ty = X.type_info x in
          let r1 = x in
	  let r2 = P.alien_of (P.create [] n  ty) in
	  if debug_fm then
	    fprintf fmt "[case-split] %a = %a@." X.print r1 X.print r2;
	  [(L.Eq(r1, r2), None), s]
      | None -> 
	  if debug_fm then fprintf fmt "[case-split] monomes: nothing@.";
	  []
   
  let case_split env = 
    match case_split_polynomes env with
      | []     -> case_split_monomes env
      | choices -> choices
   
  let add env _ = env

  let instantiate env _ _ _ _ = env, []

end
end
include (IMPLEMENTATION : INTERFACE)
end
and Arith: sig
#0 "arith.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

module Type (X : Sig.X ): Polynome.T with type r = X.r

module Make 
  (X : Sig.X)
  (P : Polynome.T with type r = X.r)
  (C : Sig.C with type t = P.t and type r = X.r) : Sig.THEORY 
  with type r = X.r and type t = P.t
end = struct
let _ = Printf.fprintf stderr "Executing arith.ml\n%!"module type INTERFACE = sig
#0 "arith.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

module Type (X : Sig.X ): Polynome.T with type r = X.r

module Make 
  (X : Sig.X)
  (P : Polynome.T with type r = X.r)
  (C : Sig.C with type t = P.t and type r = X.r) : Sig.THEORY 
  with type r = X.r and type t = P.t
end
module IMPLEMENTATION = struct
#0 "arith.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Format
open Options
open Sig
open Num
module A = Literal
module Sy = Symbols
module T = Term

let ale = Hstring.make "<=" 
let alt = Hstring.make "<"
let is_le n = Hstring.compare n ale = 0
let is_lt n = Hstring.compare n alt = 0
let is_mult h = Sy.equal (Sy.Op Sy.Mult) h
let mod_symb = Sy.name "@mod"

module Type (X:Sig.X) : Polynome.T with type r =  X.r = struct

  module Ac = Ac.Make(X)

  let mult v1 v2 = 
    X.ac_embed
      { h = Sy.Op Sy.Mult;
	t = X.type_info v1;
	l = let l2 = match X.ac_extract v1 with
	  | Some {h=h; l=l} when Sy.equal h (Sy.Op Sy.Mult) -> l 
	  | _ -> [v1, 1]
	in Ac.add (Sy.Op Sy.Mult) (v2,1) l2 }

  include Polynome.Make(struct include X let mult = mult end)

end

module Make 
  (X : Sig.X)
  (P : Polynome.T with type r = X.r)
  (C : Sig.C with type t = P.t and type r = X.r) = struct

  type t = P.t

  type r = P.r
  
  module Ac = Ac.Make(X)

  let name = "arith"

  let is_mine_a a = 
    match A.LT.view a with
      | A.Builtin (_,p,_) -> is_le p || is_lt p
      | _ -> false

  let is_mine_symb = function
    | Sy.Int _ | Sy.Real _ 
    | Sy.Op (Sy.Plus | Sy.Minus | Sy.Mult | Sy.Div | Sy.Modulo) -> true
    | _ -> false

  let is_mine_type p = 
    let ty = P.type_info p in 
    ty = Ty.Tint || ty = Ty.Treal

  let unsolvable _ = false
	  
  let empty_polynome ty = P.create [] (Int 0) ty

  let is_mine p = match P.is_monomial p with
    | Some (a,x,b) when a =/ (Int 1) && b =/ (Int 0) -> x
    | _ -> C.embed p
    
  let embed r = match C.extract r with
    | Some p -> p
    | _ -> P.create [Int 1, r] (Int 0) (X.type_info r)  

  let check_int exn p =  
    if P.type_info p = Ty.Tint then
      let _, c = P.to_list p in
      let ppmc = P.ppmc_denominators p in
      if not (is_integer_num (ppmc */ c)) then raise exn
      
  (* t1 % t2 = md  <-> 
     c1. 0 <= md ;
     c2. md < t2 ;
     c3. exists k. t1 = t2 * k + t ;
     c4. t2 <> 0 (already checked) *)
  let mk_modulo md t1 t2 ctx = 
    let zero = T.int "0" in
    let c1 = A.LT.make (A.Builtin(true, ale, [zero; md])) in
    let c2 = A.LT.make (A.Builtin(true, alt, [md; t2])) in
    let k  = T.fresh_name Ty.Tint in
    let t3 = T.make (Sy.Op Sy.Mult) [t2;k] Ty.Tint in
    let t3 = T.make (Sy.Op Sy.Plus) [t3;md] Ty.Tint in
    let c3 = A.LT.make (A.Eq (t1, t3)) in
    c3 :: c2 :: c1 :: ctx    

  let mk_euc_division p p2 t1 t2 ctx = 
    match P.to_list p2 with
      | [], coef_p2 ->
          let md = T.make (Sy.Op Sy.Modulo) [t1;t2] Ty.Tint in
          let r, ctx' = X.make md in
          let rp = P.mult (P.create [] ((Int 1) //coef_p2) Ty.Tint) (embed r) in
          P.sub p rp, ctx' @ ctx
      | _ -> assert false

  let rec mke coef p t ctx =
    let {T.f = sb ; xs = xs; ty = ty} = T.view t in
    match sb, xs with
      | (Sy.Int n | Sy.Real n) , _  -> 
	  let c = coef */ (num_of_string (Hstring.view n)) in
	  P.add (P.create [] c ty) p, ctx

      | Sy.Op Sy.Mult, [t1;t2] ->
	  let p1, ctx = mke coef (empty_polynome ty) t1 ctx in
	  let p2, ctx = mke (Int 1) (empty_polynome ty) t2 ctx in
	  P.add p (P.mult p1 p2), ctx

      | Sy.Op Sy.Div, [t1;t2] -> 
	  let p1, ctx = mke coef (empty_polynome ty) t1 ctx in
	  let p2, ctx = mke (Int 1) (empty_polynome ty) t2 ctx in
	  let p3, ctx = 
	    try 
              let p, approx = P.div p1 p2 in
              if approx then mk_euc_division p p2 t1 t2 ctx
              else p, ctx
	    with Division_by_zero | Polynome.Maybe_zero -> 
              P.create [coef, X.term_embed t] (Int 0) ty, ctx
	  in
	  P.add p p3, ctx
		
      | Sy.Op Sy.Plus , [t1;t2] -> 
	  let p2, ctx = mke coef p t2 ctx in
	  mke coef p2 t1 ctx

      | Sy.Op Sy.Minus , [t1;t2] -> 
	  let p2, ctx = mke (minus_num coef) p t2 ctx in
	  mke coef p2 t1 ctx

      | Sy.Op Sy.Modulo , [t1;t2] -> 
	  let p1, ctx = mke coef (empty_polynome ty) t1 ctx in
	  let p2, ctx = mke (Int 1) (empty_polynome ty) t2 ctx in
          let p3, ctx = 
            try P.modulo p1 p2, ctx
            with e ->
	      let t = T.make mod_symb [t1; t2] Ty.Tint in    
              let ctx = match e with
                | Division_by_zero | Polynome.Maybe_zero -> ctx
                | Polynome.Not_a_num -> mk_modulo t t1 t2 ctx
                | _ -> assert false 
              in 
              P.create [coef, X.term_embed t] (Int 0) ty, ctx 
	  in         
	  P.add p p3, ctx
	    
      | _ ->
	let a, ctx' = X.make t in
	let ctx = ctx' @ ctx in
	match C.extract a with
	  | Some p' -> P.add p (P.mult (P.create [] coef ty) p'), ctx
	  | _ -> P.add p (P.create [coef, a] (Int 0) ty), ctx

  let arith_to_ac p = p
(*
    match P.to_list p with
      | []         , c     -> p
      | [Int 1, x] , Int 0 -> p
      | l          , c     ->
        let ty = P.type_info p in
        let l = 
          List.fold_left 
            (fun acc (coef,x) ->
              if coef =/ Int 0 then acc
              else if coef =/ Int 1 || coef =/ Int (-1) then (coef,x)::acc
              else match X.ac_extract x with
                | Some ac when is_mult ac.h ->
                  let unit_coef, abs_coef =
                    if coef > Int 0 then Int 1, coef
                    else Int (-1), minus_num coef 
                  in
                  let p_cst = is_mine (P.create [] abs_coef ty) in
                  let ac = {ac with l = Ac.add ac.h (p_cst, 1) ac.l} in
                  (unit_coef, X.ac_embed ac)::acc
                | _      -> (coef,x)::acc
            )[] l 
        in 
        P.create l c ty
*)
  let make t = 
    let {T.ty = ty} = T.view t in
    let p, ctx = mke (Int 1) (empty_polynome ty) t [] in
    is_mine (arith_to_ac p), ctx

  let rec expand p n acc =
    assert (n >=0);
    if n = 0 then acc else expand p (n-1) (p::acc)

  let unsafe_ac_to_arith {h=sy; l=rl; t=ty} =
    let mlt = List.fold_left (fun l (r,n) -> expand (embed r)n l) [] rl in
    List.fold_left P.mult (P.create [] (Int 1) ty) mlt


  let rec number_of_vars l = 
    List.fold_left (fun acc (r, n) -> acc + n * nb_vars_in_alien r) 0 l 

  and nb_vars_in_alien r = 
    match C.extract r with
      | Some p -> 
	  let l, _ = P.to_list p in
          List.fold_left (fun acc (a, x) -> max acc (nb_vars_in_alien x)) 0 l
      | None -> 
	  begin
	    match X.ac_extract r with
	      | Some ac when is_mult ac.h -> 
		  number_of_vars ac.l
	      | _ -> 1
	  end

  let max_list_ = function
    | [] -> 0
    | [ _, x ] -> nb_vars_in_alien x
    | (_, x) :: l ->
	let acc = nb_vars_in_alien x in
	List.fold_left (fun acc (_, x) -> max acc (nb_vars_in_alien x)) acc l

  let color ac = 
    match ac.l with
      | [(r, 1)] -> assert false
      | _ -> 
        let p = unsafe_ac_to_arith ac in 
	let l, _ = P.to_list p in
        let mx = max_list_ l in
        if mx = 0 || mx = 1 || number_of_vars ac.l > mx then is_mine p 
	else X.ac_embed ac

	(*try
          List.iter
            (fun (coef,x) ->
              match X.ac_extract x with
                  Some ac when is_mult ac.h -> raise Exit | _ -> ()
            )(fst (P.to_list p));
          is_mine p
        with Exit -> X.ac_embed ac*)


  let type_info p = P.type_info p

  let is_int r = X.type_info r = Ty.Tint

  module XS = Set.Make(struct type t = X.r let compare = X.compare end)
    
  let xs_of_list = 
    List.fold_left (fun s x -> XS.add x s) XS.empty
      
  let rec leaves p = 
    let s = 
      List.fold_left
	(fun s (_, a) -> XS.union (xs_of_list (X.leaves a)) s)
	XS.empty (fst (P.to_list p))
    in
    XS.elements s

  let subst x t p = 
    let p = P.subst x (embed t) p in
    let ty = P.type_info p in
    let l, c = P.to_list p in
    let p  = 
      List.fold_left
        (fun p (ai, xi) ->
	   let xi' = X.subst x t xi in
	   let p' = match C.extract xi' with
	     | Some p' -> P.mult (P.create [] ai ty) p'
	     | _ -> P.create [ai, xi'] (Int 0) ty
	   in
	   P.add p p')
        (P.create [] c ty) l
    in 
    check_int (Exception.Unsolvable) p;
    is_mine p


  let compare = P.compare

  let hash = P.hash

  (* symmetric modulo p 131 *)
  let mod_sym a b = 
    let m = mod_num a b in 
    let m = 
      if m </ Int 0 then
        if m >=/ minus_num b then m +/ b else assert false
      else 
        if m <=/ b then m else assert false
	  
    in
    if m </ b // (Int 2) then m else m -/ b

  let mult_const p c =
    P.mult p (P.create [] c (P.type_info p))
  
  let map_monomes f l ax =
    List.fold_left
      (fun acc (a,x) -> 
         let a = f a in if a =/ Int 0 then acc else (a, x) :: acc)
      [ax] l 

  let apply_subst sb v = 
    is_mine (List.fold_left (fun v (x, p) -> embed (subst x p v)) v sb)

  (* substituer toutes variables plus grandes que x *)
  let subst_bigger x l = 
    List.fold_left 
      (fun (l, sb) (b, y) ->
         if X.compare y x > 0 then
	   let k = X.term_embed (T.fresh_name Ty.Tint) in
	   (b, k) :: l, (y, embed k)::sb
	 else (b, y) :: l, sb)
      ([], []) l

  let is_mine_p = List.map (fun (x,p) -> x, is_mine p)
   
  let extract_min = function
      | [] -> assert false
      | [c] -> c, []
      | (a, x) :: s -> 
	  List.fold_left 
	     (fun ((a, x), l) (b, y) ->
		if abs_num a <=/ abs_num b then 
		  (a, x), ((b, y) :: l) 
		else (b, y), ((a, x):: l)) ((a, x),[]) s
      

  (* Decision Procedures. Page 131 *)
  let rec omega l b = 
    
    (* 1. choix d'une variable donc le |coef| est minimal *)
    let (a, x), l = extract_min l in 

    (* 2. substituer les aliens plus grand que x pour 
       assurer l'invariant sur l'ordre AC *)
    let l, sbs = subst_bigger x l in
    let p = P.create l b Ty.Tint in
    match a with
      | Int 0 -> assert false
      | Int 1 -> 
          (* 3.1. si a = 1 alors on a une substitution entiere pour x *)
          let p = mult_const p (Int (-1)) in 
          (x, is_mine p) :: (is_mine_p sbs)
            
      | Int (-1) -> 
          (* 3.2. si a = -1 alors on a une subst entiere pour x*)
          (x,is_mine p) :: (is_mine_p sbs)
      | _        -> 
          (* 4. sinon, (|a| <> 1) et a <> 0 *)
          (* 4.1. on rend le coef a positif s'il ne l'est pas deja *)
          let a, l, b = 
            if compare_num a (Int 0) < 0  then 
	      (minus_num a,
	       List.map (fun (a,x) -> minus_num a,x) l, (minus_num b))
            else (a, l, b)
          in
          (* 4.2. on reduit le systeme *)
          omega_sigma sbs a x l b

  and omega_sigma sbs a x l b =
    
    (* 1. on definie m qui vaut a + 1 *)
    let m = a +/ Int 1 in

    (* 2. on introduit une variable fraiche *)
    let sigma = X.term_embed (T.fresh_name Ty.Tint) in
    
    (* 3. l'application de la formule (5.63) nous donne la valeur du pivot x*)
    let mm_sigma = (minus_num m, sigma) in
    let l_mod = map_monomes (fun a -> mod_sym a m) l mm_sigma in

    (* 3.1. Attention au signe de b : 
       on le passe a droite avant de faire mod_sym, d'ou minus_num *)
    let b_mod = minus_num (mod_sym (minus_num b) m) in
    let p = P.create l_mod b_mod Ty.Tint in

    let sbs = (x, p) :: sbs in
    
    (* 4. on substitue x par sa valeur dans l'equation de depart. 
       Voir la formule (5.64) *)
    let p' = P.add (P.mult_const a p) (P.create l b Ty.Tint) in
   
    (* 5. on resoud sur l'equation simplifiee *)
    let sbs2 = solve_int p' in

    (* 6. on normalise sbs par sbs2 *)
    let sbs =  List.map (fun (x, v) -> x, apply_subst sbs2 v) sbs in

    (* 7. on supprime les liaisons inutiles de sbs2 et on merge avec sbs *)
    let sbs2 = List.filter (fun (y, _) -> y <> sigma) sbs2 in
    List.rev_append sbs sbs2

  and solve_int p = 
    if P.is_empty p then raise Not_found;
    let pgcd = P.pgcd_numerators p in
    let ppmc = P.ppmc_denominators p in
    let p = mult_const p (ppmc // pgcd)  in
    let l, b = P.to_list p in
    if not (is_integer_num b) then raise Exception.Unsolvable;
    omega l b

  let is_null p = 
    if snd (P.to_list p) <>/ (Int 0) then raise Exception.Unsolvable; 
    []

  let solve_int p = 
    try solve_int p with Not_found -> is_null p

  let solve_real p =
    try
      let a, x = P.choose p in
      let p = 
	P.mult 
	  (P.create [] ((Int (-1)) // a) (P.type_info p))
	  (P.remove x p) 
      in
      [x, is_mine p]
    with Not_found -> is_null p
      

  let unsafe_ac_to_arith {h=sy; l=rl; t=ty} =
    let mlt = List.fold_left (fun l (r, n) -> expand (embed r) n l) [] rl in
    List.fold_left P.mult (P.create [] (Int 1) ty) mlt

  let safe_distribution p = 
    let l, c = P.to_list p in
    let ty = P.type_info p in
    let pp = 
      List.fold_left
	(fun p (coef, x) ->
           match X.ac_extract x with
             | Some ac when is_mult ac.h -> 
		 P.add p (P.mult_const coef (unsafe_ac_to_arith ac))
             | _ -> 
		 P.add p (P.create [coef,x] (Int 0) ty)
	) (P.create [] c ty) l
    in
    if List.exists 
      (fun (_, x)-> 
	 match X.ac_extract x with | Some ac -> is_mult ac.h | _ -> false)
      (fst (P.to_list pp)) then p else pp


  let solve_aux r1 r2 =
    if debug_arith then 
      fprintf fmt "[arith] we solve %a=%a@." X.print r1 X.print r2;
    let p1 = embed r1 in
    let p2 = embed r2 in
    let ty = P.type_info p2 in
    let p = P.add p1 (P.mult (P.create [] (Int (-1)) ty) p2) in
    let pp = safe_distribution p in
    if ty = Ty.Treal then solve_real pp else solve_int pp

  let solve r1 r2 = 
    let sbs = solve_aux r1 r2 in
    let sbs = List.fast_sort (fun (a,_) (x,y) -> X.compare x a)sbs in
    if debug_arith then begin
      fprintf fmt "[arith] solving %a = %a yields:@." X.print r1 X.print r2;
      let c = ref 0 in
      List.iter 
        (fun (p,v) -> 
           incr c;
           fprintf fmt " %d) %a |-> %a@." !c X.print p X.print v) sbs
    end;
    sbs

  let print = P.print

  let fully_interpreted sb = 
    match sb with
      | Sy.Op (Sy.Plus | Sy.Minus) -> true
      | _ -> false


  module Rel = Fm.Make (X) 
    (struct
       include P 
       let poly_of = embed
       let alien_of = is_mine
     end)
    
end
end
include (IMPLEMENTATION : INTERFACE)
end
and Pairs: sig
#0 "pairs.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type 'a abstract

module type ALIEN = sig
  include Sig.X
  val embed : r abstract -> r
  val extract : r -> (r abstract) option
end

module Make 
  (X : ALIEN) : Sig.THEORY with type r = X.r and type t = X.r abstract

end = struct
let _ = Printf.fprintf stderr "Executing pairs.ml\n%!"module type INTERFACE = sig
#0 "pairs.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type 'a abstract

module type ALIEN = sig
  include Sig.X
  val embed : r abstract -> r
  val extract : r -> (r abstract) option
end

module Make 
  (X : ALIEN) : Sig.THEORY with type r = X.r and type t = X.r abstract

end
module IMPLEMENTATION = struct
#0 "pairs.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Format
open Options

type ('a, 'b) mine = Yes of 'a | No of 'b

type 'a abstract = 
    Pair of 'a abstract * 'a abstract * Ty.t
  | Fst of 'a abstract * Ty.t
  | Snd of 'a abstract * Ty.t
  | Other of 'a * Ty.t

module type ALIEN = sig
  include Sig.X
  val embed : r abstract -> r
  val extract : r -> (r abstract) option
end

module Make (X : ALIEN) = struct 

  module XS = Set.Make(struct type t = X.r let compare = X.compare end)

  let name = "pairs"

  type t = X.r abstract
  type r = X.r

  let rec print fmt = function
    | Pair(t, u,_) -> fprintf fmt "<%a, %a>" print t print u
    | Fst(t,_) -> fprintf fmt "fst(%a)" print t
    | Snd(t,_) -> fprintf fmt "snd(%a)" print t
    | Other(t,_) -> X.print fmt t

  let print_mine fmt = function
      No r -> X.print fmt r
    | Yes t -> print fmt t

  let is_pair =
    let c = Hstring.make "pair" in
    fun s -> Hstring.compare s c = 0

  let is_fst =
    let n = Hstring.make "fst" in
    fun s -> Hstring.compare s n = 0

  let is_snd =
    let n = Hstring.make "snd" in
    fun s -> Hstring.compare s n = 0

  let rec raw_comp t' u' =
    match t', u' with
      | Other(t,_), Other(u,_) -> X.compare t u
      | Other _, _ -> -1
      | _, Other _ -> 1
      | Snd(p,_), Snd(q,_) -> raw_comp p q
      | Snd _, _ -> -1
      | _, Snd _ -> 1
      | Fst(p,_), Fst(q,_) -> raw_comp p q
      | Fst _, _ -> -1
      | _, Fst _ -> 1
      | Pair(t, u,_), Pair(t', u',_) ->
	  let c = raw_comp t t' in
	    if c = 0 then raw_comp u u'
	    else c
	      
  let rec normalize = function
    | Pair(u, v, t) -> 
	let u' = normalize u and v' = normalize v in
	  (match u',v' with
	     | Fst(u1,_), Snd(u2,_) when raw_comp u1 u2 = 0 -> u1
	     | _ -> Pair(u', v',t))
    | Fst(p,t) ->
	(match normalize p with
	   | Pair(a, _,_) -> a
	   | p' -> Fst(p',t))
    | Snd(p,t) ->
	(match normalize p with
	   | Pair(_, b,_) -> b
	   | p' -> Snd(p',t))
    | Other(r,t) -> Other(r,t)
	
  let is_mine t =
    match normalize t with
      | Other(r,_) -> r
      | x -> X.embed x

  let make t = 
    let rec make_rec t ctx =
      match (Term.view t) with
	| {Term.f = Symbols.Name (f,_); xs = l; ty=ty} ->
	    begin
	      if is_pair f then
		match l with 
		  | [lc; rc] -> 
		      let f, ctx = make_rec lc ctx in
		      let s, ctx = make_rec rc ctx in
		      Pair (f, s,ty), ctx
		  | _ -> assert false
	      else if is_fst f then
		match l with
		  | [p] -> 
		      let f, ctx = make_rec p ctx in
		      Fst (f,ty), ctx
		  | _ -> assert false
	      else if is_snd f then
		match l with
		  | [p] -> 
		      let s, ctx = make_rec p ctx in
		      Snd (s,ty), ctx
		  | _ -> assert false
	      else
		let r, ctx' = X.make t in
		let ctx = ctx'@ctx in
		Other (r,ty), ctx
	    end
	| {Term.ty=ty} -> 
	    let r, ctx' = X.make t in
	    let ctx = ctx'@ctx in
	    Other (r,ty), ctx
    in 
    let r, ctx = make_rec t [] in
    is_mine r, ctx

  let color _ = assert false
    
  let embed r = 
    match X.extract r with
      | Some p -> p
      | None -> Other(r, X.type_info r)

  let xs_of_list = List.fold_left (fun s x -> XS.add x s) XS.empty

  let leaves t = 
    let rec leaves t = 
      match (normalize t) with
	| Pair(lc, rc,_) -> XS.union (leaves lc) (leaves rc)
	| Fst (p,_) 
	| Snd (p,_) -> leaves p
	| Other(x,_) -> xs_of_list (X.leaves x)
    in
    XS.elements (leaves t)

  let compare t u =
    raw_comp (normalize t) (normalize u)

      (*of 'a abstract * 'a abstract * Ty.t*)
  let rec hash  = function
    | Pair (x, y, t) -> 
	hash x + 11 * hash y + Ty.hash t
    | Fst (x, t) ->
	17 * hash x + Ty.hash t
    | Snd (x, t) ->
	19 * hash x + Ty.hash t
    | Other (x, t) ->
	Ty.hash t + 23 * X.hash x

(* This module is a naive union-find structure for *)
(* elements of type t, implemented as a set of lists. *)
  module UF = 
  struct 
    type tag = Left | Right

    module S = Set.Make(
      struct
	type t = (X.r abstract * tag) list
	let rec comp l1 l2 = match l1, l2 with
	  | [], [] -> 0
	  | _, [] -> 1
	  | [], _ -> -1
	  | a::q1, b::q2 ->
	      let c = raw_comp (fst a) (fst b) in
		if c = 0 then comp q1 q2 else c
	let compare = comp
      end)
      
    type t = S.t
	
    let empty = S.empty
    let in_class t = List.exists (fun e -> raw_comp t (fst e) = 0)
    let mem t = S.exists (in_class t)
	
    let add t tag uf =
      if mem t uf then uf else S.add [t,tag] uf
    
    let classof_ uf t = 
      match S.elements (S.filter (in_class t) uf) with
	| [] -> raise Not_found
	| [c] -> c
	| _ -> assert false 
	    (* on ne doit pas trouver deux classes pour un element donne *)
    let classof uf t = fst (List.split (classof_ uf t))

    let find uf t = List.hd (classof_ uf t)
	
    let union uf t1 t2 =
      let c1 = classof_ uf t1 and c2 = classof_ uf t2 in
	S.add (c2@c1) (S.remove c2 (S.remove c1 uf))

    let find_mate uf t tag =
      match List.filter (fun e -> raw_comp t (fst e) <> 0) (classof_ uf t) with
	| [] -> None
	| (e,_)::_ -> Some e

    let rec find_new_mate uf t tag =
      match List.filter (fun e -> raw_comp t (fst e) <> 0) (classof_ uf t) with
	| [] -> None
	| (((e,_)::_) as l) -> 
	    let r =
	      match List.partition (fun (_,t) -> t = tag) l with
		| (e,_)::_,_ -> Some e
		| [],l -> build_new_mate uf tag l
	    in match r with None -> Some e | _ -> r
    
    and build_new_mate uf tag = function
      | [] -> None
      | (Other(_,_),_)::q ->
	  build_new_mate uf tag q
      | (Fst(t,ty),_)::q ->
	  begin
	    match find_new_mate uf t tag with
	      | Some t' -> Some (Fst(t',ty))
	      | None -> build_new_mate uf tag q
	  end
      | (Snd(t,ty),_)::q ->
	  begin
	    match find_new_mate uf t tag with
	      | Some t' -> Some (Snd(t',ty))
	      | None -> build_new_mate uf tag q
	  end
      | (Pair(t1,t2,ty),_)::q ->
	  begin
	    match 
	      find_new_mate uf t1 tag,
	      find_new_mate uf t2 tag with
		| Some t1', Some t2' -> Some (Pair(t1',t2',ty))
		| Some t1', None -> Some (Pair(t1',t2,ty))
		| None, Some t2' -> Some (Pair(t1,t2',ty))
		| None, None -> build_new_mate uf tag q
	  end
  end
    
  module Map = 
    Map.Make (struct type t = X.r abstract let compare = compare end)
  module Set = 
    Set.Make (struct type t = X.r abstract let compare = compare end)
    
  let rec subst_rec p v r = 
    match r with
      | Other(t,ty) -> 
	  let v' = if X.compare p t = 0 then v else X.subst p v t in
	  (match X.extract v' with Some x -> x | None -> Other(v',ty))
      | Fst(t,ty) -> Fst(subst_rec p v t,ty)
      | Snd(t,ty) -> Snd(subst_rec p v t,ty)
      | Pair(t, u,ty) -> Pair (subst_rec p v t, subst_rec p v u,ty)
	  
  let subst p v r = is_mine (subst_rec p v r)
      
  let is_mine_symb =  function 
    | Symbols.Name (f,_) when pairs -> is_fst f || is_snd f || is_pair f
    | _ -> false
      
  let is_mine_a _ = false

  let rec is_mine_type = function
      Pair _ -> true
    | Other _ -> false
    | Fst(t,_) | Snd(t,_) -> is_mine_type t
	
  let unsolvable _ = false

  let type_info = 
    function Pair(_,_,t) | Fst(_,t) | Snd(_,t) | Other(_,t) -> t

  let type_snd t = 
    match type_info t with 
	Ty.Text(([_;ty] | [ty]),_) -> ty | _ -> assert false

  let type_fst t = 
    match type_info t with Ty.Text(([ty;_]|[ty]),_) -> ty  
      | _ -> assert false

(** [decompose uf t] adds [t] and all its subterms to [uf] *)
  let decompose tag uf = 
    let add p = UF.add p tag in
    let rec dec uf = function
    | Pair(t, u,_) as p -> 
	add p (dec (dec uf t) u)
    | Fst(t,ty) as p ->
	let t' = Snd(t,type_snd t) in
	let t'' = Pair(p,t',type_info t) in
	let uf = add t' (add t'' (add p (dec uf t))) in
	  UF.union uf t'' t
    | Snd(t,_) as p ->
	let t' = Fst(t,type_fst t) in
	let t'' = Pair(t',p,type_info t) in
	let uf = add t' (add t'' (add p (dec uf t))) in
	  UF.union uf t'' t
    | p -> add p uf
    in dec uf

(** [find_new_eqs uf] tries to find new equalities between elements
    of [uf] by applying simple rules.
    When no equality is found, raises Not_found. *)
  let find_new_eqs uf =
    (* Three possible origins of new equalities : *)
    (* _ fst(pair(x,y)) = x *)
    let find_fst_pair uf =
      UF.S.fold
	(fun c acc -> List.fold_left 
	   (fun acc (t,_) -> match t with
	      | Fst(e,_) -> 
		  (List.fold_left 
		     (fun acc e' -> match e' with 
			| Pair(a, _,_) ->
			    if UF.in_class a c then acc else (t,a)::acc
			| _ -> acc)
		     acc (UF.classof uf e))
	      | _ -> acc) acc c)
	uf in
    (* _ snd(pair(x,y)) = y *)
    let find_snd_pair uf =
      UF.S.fold
	(fun c acc -> List.fold_left 
	   (fun acc (t,_) -> match t with 
	      | Snd(e,_) -> 
		  (List.fold_left 
		     (fun acc e' -> match e' with
			| Pair(_, b,_) ->
			    if UF.in_class b c then acc else (t,b)::acc
			| _ -> acc)
		     acc (UF.classof uf e))
	      | _ -> acc) acc c)
	uf in
    (* _ cons(x,y) = cons(x',y') -> x=x' /\ y=y' *)
    let find_pair_pair uf =
      let rec apparier acc = function
	| [] -> acc
	| (t1,t2)::q -> 
	    let newacc = 
	      (List.fold_left 
		 (fun acc (u1,u2) ->
		    let add = ref [] in
		      if not (List.mem u1 (UF.classof uf t1)) then
			add := (t1, u1)::!add;
		      if not (List.mem u2 (UF.classof uf t2)) then 
			add := (t2, u2)::!add;
		      (!add)@acc) acc q)
	    in apparier newacc q
      in
	UF.S.fold
	  (fun c acc -> 
	     apparier acc 
	       (List.fold_left 
		  (fun acc i -> 
		     match i with 
		       | Pair(t1,t2,_), _ -> (t1,t2)::acc
		       | _ -> acc) [] c))
	  uf
    in
      (** we search all kinds of equations *)
      find_fst_pair uf (find_snd_pair uf (find_pair_pair uf []))
	
  let solve r1 r2 = 
    let leaves t = 
      let rec leaves t = 
	match (normalize t) with
	  | Pair(lc, rc,_) -> XS.union (leaves lc) (leaves rc)
	  | Fst(p,_) 
	  | Snd(p,_) -> leaves p
	  | Other(x,_) -> XS.singleton x
      in
      XS.elements (leaves t)
    in
    if debug_pairs then 
      printf "[pairs] Solving %a = %a @." X.print r1 X.print r2;
    (* populate the uf *)
    let t1 = match X.extract r1 with 
	Some t1 -> t1 | None -> Other(r1, X.type_info r1) in
    let t2 = match X.extract r2 with 
	Some t2 -> t2 | None -> Other(r2, X.type_info r2) in
    let uf = decompose UF.Right (decompose UF.Left UF.empty t1) t2 in
    (* merge t1 and t2 *)
    let uf' = UF.union uf t1 t2 in

    (* close the uf wrt the new equalities *)
    let rec closure uf =
      match find_new_eqs uf with
	| [] -> uf
	| lt -> closure 
	    (List.fold_left (fun acc (t1, t2) -> UF.union acc t1 t2) uf lt)
    in
    let ufsat = closure uf' in

    (* For each leaf, we find a term in its class which was not
       already equal to itself, and which contaings parts with tag *)
    let f tag =
      List.fold_left
	(fun acc t -> 
	   match UF.find_new_mate ufsat (Other(t, X.type_info t)) tag with
	     | Some e -> (t, is_mine e)::acc
	     | None -> (* Format.printf "ici : %a\n" X.print t; *) 
		 acc) []
    in
    let res = match t1,t2 with
	Other _ , Other _ -> assert false
      | Other _ , _ -> f UF.Left (leaves t2) 
      | _ , Other _ -> f UF.Right (leaves t1) 
      | _ , _ -> 
	  let sols (l,t) (l',t') =
	    match f t l with [] -> f t' l' | r -> r
	  in
	  let l1, l2 = leaves t1, leaves t2 in
(* 	    if List.length l1 > List.length l2 then *)
	      sols (l1,UF.Right) (l2,UF.Left)
(* 	    else  *)
(* 	      sols (l2,UF.Left) (l1,UF.Right) *)
    in

    if debug_pairs then 
      (printf "[pairs] Results :@ ";
       List.iter (fun (t, r) -> 
		    printf "%a |-> %a@ ;@ " X.print t X.print r) res);
    
    (* AC ordering : Take 1*) 
    List.fold_left
      (fun acc (p,v) ->
	 if X.unsolvable v && X.compare  v p > 0 then (v,p) :: acc 
	 else (p,v) :: acc
      )[] res

  let fully_interpreted sb = false
          
  module Rel =
  struct
    type r = X.r
    type t = unit
    exception Inconsistent    
    let empty _ = ()
    let assume _ _ _ = (), []
    let query _ _ _ = Sig.No
    let case_split env = []
    let add env _ = env
    let instantiate env _ _ _ _ = env, []
  end
end
end
include (IMPLEMENTATION : INTERFACE)
end
and Bitv: sig
#0 "bitv.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type 'a abstract
  
module type ALIEN = sig
  include Sig.X
  val embed : r abstract -> r
  val extract : r -> (r abstract) option
end

module Make 
  (X : ALIEN) : Sig.THEORY with type r = X.r and type t = X.r abstract


end = struct
let _ = Printf.fprintf stderr "Executing bitv.ml\n%!"module type INTERFACE = sig
#0 "bitv.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type 'a abstract
  
module type ALIEN = sig
  include Sig.X
  val embed : r abstract -> r
  val extract : r -> (r abstract) option
end

module Make 
  (X : ALIEN) : Sig.THEORY with type r = X.r and type t = X.r abstract


end
module IMPLEMENTATION = struct
#0 "bitv.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Format
open Hashcons

module Sy = Symbols
module T = Term

type sort_var = A | B | C
    
type tvar = { var : int ; sorte : sort_var }

type 'a xterm = Var of tvar | Alien of 'a
    
type 'a alpha_term = {
  bv : 'a;
  sz : int;
}

type 'a simple_term_aux = 
  | Cte of bool 
  | Other of 'a xterm
  | Ext of 'a xterm * int * int * int (*// id * size * i * j //*)
      
type 'a simple_term = ('a simple_term_aux) alpha_term

type 'a abstract =  ('a simple_term) list 
    

(* for the solver *)

type solver_simple_term_aux = 
    | S_Cte of bool 
    | S_Var of tvar

type solver_simple_term = solver_simple_term_aux alpha_term


module type ALIEN = sig
  include Sig.X
  val embed : r abstract -> r
  val extract : r -> (r abstract) option
end

module Make(X : ALIEN) = struct

  type t = X.r abstract
  type r = X.r

  let name = "bitv"

  let is_mine_a _ = false

  let is_mine_symb = function
    | Sy.Bitv _ | Sy.Op (Sy.Concat | Sy.Extract)  -> true
    | _ -> false

  let is_mine_type _ = assert false

  let unsolvable = function
      [{bv =Other (Var _)}] -> true
    | _ -> false
	
  let embed r =
    match X.extract r with
      | None ->
	  begin
	    match X.type_info r with
	      | Ty.Tbitv n -> [{bv = Other (Alien r) ; sz = n}]
	      | _  -> assert false
	  end
      | Some b -> b


  let err = err_formatter

  let compare_xterm xt1 xt2 = match xt1,xt2 with
    | Var v1, Var v2 -> 
	let c1 = compare v1.sorte v2.sorte in 
	if c1 <> 0 then c1 
	else -(compare v1.var v2.var)
	  (* on inverse le signe : les variables les plus fraiches sont 
	     les plus jeunes (petites)*)

    | Alien t1, Alien t2 -> X.compare t1 t2
    | Var v, Alien t -> 1
    | Alien t, Var v -> -1

  let compare_simple_term st1 st2 = 
    if st1.sz <> st2.sz then st1.sz - st2.sz
    else 
      begin
	match st1.bv,st2.bv with
	  | Cte b,Cte b' -> compare b b'
	  | Cte false , _ | _ , Cte true -> -1
	  | _ , Cte false | Cte true,_ -> 1
	      
	  | Other t1 , Other t2 -> compare_xterm t1 t2
	  | _ , Other _ -> -1
	  | Other _ , _ -> 1
	  | Ext(t1,s1,i1,_) , Ext(t2,s2,i2,_) ->
	      let c1 = compare s1 s2 in
	      if c1<>0 then c1
	      else let c2 = compare i1 i2 in
	      if c2 <> 0 then c2 else compare_xterm t1 t2
      end
       
  module ST_Set = Set.Make (
    struct 
      type t = solver_simple_term 
      let compare st1 st2 = 
	if st1.sz <> st2.sz then st1.sz - st2.sz
	else 
	  begin
	    match st1.bv,st2.bv with
	      | S_Cte b, S_Cte b' -> compare b b'
	      | S_Cte false, _ | _, S_Cte true -> -1
	      | _ , S_Cte false | S_Cte true,_ -> 1
	      | S_Var v1, S_Var v2 -> 
		  let c1 = compare v1.sorte v2.sorte
		  in if c1 <> 0 then c1 else compare v1.var v2.var
	  end
    end)
    
  module Canonizer = struct
    
    type term_aux  = 
      | I_Cte of bool 
      | I_Other of X.r xterm
      | I_Ext of term * int * int 
      | I_Comp of term * term
	  
    and term = term_aux alpha_term

    (** **)
    let rec alpha t = match t.bv with
      |I_Cte _ -> [t]
      |I_Other _ -> [t]
      |I_Comp (t1,t2) -> (alpha t1)@(alpha t2)
      |I_Ext(t',i,j) ->
	 begin
	   match t'.bv with
	     |I_Cte _ -> [{t' with sz = j-i+1}]
	     |I_Other _ -> [t]
	     |I_Ext(t'',k,_) -> 
		alpha {t with bv = I_Ext(t'',i+k,j+k)}  

	     |I_Comp(u,v) when j < v.sz -> 
		alpha{t with bv =I_Ext(v,i,j)}

	     |I_Comp(u,v) when i >= v.sz ->
		alpha{t with bv=I_Ext(u,i-v.sz,j-v.sz)}

	     |I_Comp(u,v) -> 
		(alpha {sz = j-v.sz+1 ; bv = I_Ext(u,0,j-v.sz)}) 
		@(alpha{sz = v.sz-i ; bv = I_Ext(v,i,v.sz-1)})
	 end
	   
    (** **)   
    let rec beta lt = 
      let simple_t st = match st.bv with
	|I_Cte b -> {bv = Cte b ; sz = st.sz}
	|I_Other x -> {bv = Other x ; sz = st.sz}
	|I_Ext(t',i,j) -> 
	   begin
	     match t'.bv with
	       |I_Other v -> 
		  let siz = j-i+1 
		  in {sz=siz ;
		      bv =if siz=t'.sz then Other v else Ext(v,t'.sz,i,j)}
	       |I_Comp _ |I_Ext _ |I_Cte _ -> assert false
	   end	
	|I_Comp(_,_) -> assert false
      
      in match lt with
	|[] -> [] (*on peut passer de 2 elts a 0 elts*)
	|[s] -> [simple_t s]
	|s::t::tl' ->
	   begin
	     match s.bv , t.bv with
	       |I_Cte b1,I_Cte b2 when b1=b2 ->beta({s with sz=s.sz+t.sz}::tl')
	       |I_Ext(d1,i,j),I_Ext(d2,k,l) when d1=d2 && l=i-1 ->
		  let tmp = {sz = s.sz + t.sz ; bv = I_Ext(d1,k,j)}
		  in if k=0 then (simple_t tmp)::(beta tl') else beta (tmp::tl')
	       |_ -> (simple_t s)::(beta (t::tl'))
	   end
	
    (** **)     
    let sigma term = beta (alpha term)
      
    let bitv_to_icomp =
      List.fold_left (fun ac bt ->{ bv = I_Comp (ac,bt) ; sz = bt.sz + ac.sz })

    let string_to_bitv s =
      let tmp = ref[] in
      String.iter(fun car -> tmp := (car<>'0',1)::(!tmp)) s;
      let rec f_aux l acc = match l with
	| [] -> assert false
	| [(b,n)] -> { sz = n ; bv = I_Cte b }::acc
	| (b1,n)::(b2,m)::r when b1 = b2 -> f_aux ((b1,n+m)::r) acc
	| (b1,n)::(b2,m)::r -> 
	    (f_aux ((b2,m)::r)) ({ sz = n ; bv = I_Cte b1 }::acc)
      in 
      let res = f_aux (!tmp) [] in 
      bitv_to_icomp (List.hd res) (List.tl res)

    let make t =
      let rec make_rec t' ctx = match T.view t' with
	| {T.f = Sy.Bitv s } -> string_to_bitv s, ctx
	| {T.f = Sy.Op Sy.Concat ; xs = [t1;t2] ; ty = Ty.Tbitv n} ->
	    let r1, ctx = make_rec t1 ctx in
	    let r2, ctx = make_rec t2 ctx in
	    { bv = I_Comp (r1, r2) ; sz = n }, ctx
	| {T.f = Sy.Op Sy.Extract; xs = [t1;ti;tj] ; ty = Ty.Tbitv n} ->
	    begin 
	      match T.view ti , T.view tj with
		| { T.f = Sy.Int i } , { T.f = Sy.Int j } -> 
		    let i = int_of_string i.node in
		    let j = int_of_string j.node in
		    let r1, ctx = make_rec t1 ctx in
		    { sz = j - i + 1 ; bv = I_Ext (r1,i,j)}, ctx
		| _ -> assert false
	    end
	| {T.ty = Ty.Tbitv n} -> 
	    let r', ctx' = X.make t' in
	    let ctx = ctx' @ ctx in
	    {bv = I_Other (Alien r') ; sz = n}, ctx
	| _ -> assert false
      in 
      let r, ctx = make_rec t [] in
      sigma r, ctx
  end

  module Print = struct
    open Canonizer
    
    let print_tvar fmt ({var=v;sorte=s},sz) = 
      fprintf fmt "%s_%d[%d]@?" 
	(match s with | A -> "a" | B -> "b" | C -> "c")
	v sz
      
    let rec print_I_ast fmt ast = match ast.bv with
      | I_Cte b -> fprintf fmt "%d[%d]@?" (if b then 1 else 0) ast.sz
      | I_Other (Alien t) -> fprintf fmt "%a[%d]@?" X.print t ast.sz
      | I_Other (Var tv) -> fprintf fmt "%a@?" print_tvar (tv,ast.sz)
      | I_Ext (u,i,j) -> fprintf fmt "%a<%d,%d>@?" print_I_ast u i j
      | I_Comp(u,v) -> fprintf fmt "@[(%a * %a)@]" print_I_ast u print_I_ast v
   
    let print fmt ast = match ast.bv with 
      | Cte b -> fprintf fmt "%d[%d]@?" (if b then 1 else 0) ast.sz
      | Other (Alien t) -> fprintf fmt "%a@?" X.print t
      | Other (Var tv) -> fprintf fmt "%a@?" print_tvar (tv,ast.sz)   
      | Ext (Alien t,sz,i,j) -> 
	  fprintf fmt "%a@?" X.print t;
	  fprintf fmt "<%d,%d>@?" i j
      | Ext (Var tv,sz,i,j) -> 
	  fprintf fmt "%a@?" print_tvar (tv,ast.sz);
	  fprintf fmt "<%d,%d>@?" i j

    let print_C_ast fmt = function
	[] -> assert false
      | x::l -> print fmt x; List.iter (fprintf fmt " @@ %a" print) l

    let print_s fmt ast = match ast.bv with 
      | S_Cte b -> fprintf fmt "%d[%d]@?" (if b then 1 else 0) ast.sz
      | S_Var tv -> fprintf fmt "%a@?" print_tvar (tv,ast.sz)

    let print_S_ast fmt = function
	[] -> assert false
      | x::l -> print_s fmt x; List.iter (fprintf fmt " @@ %a" print_s) l

    let print_sliced_sys fmt l = 
      fprintf fmt "\nSlicing :\n";
      List.iter (fun (a,b) -> fprintf fmt " %a == %a\n" print a print b) l

    let print_c_solve_res fmt l = 
      fprintf fmt "\n(map)c_solve :\n";
      List.iter (fun (a,b) -> fprintf fmt " %a == %a\n" print a print_S_ast b) l

    let print_partition_res fmt l = 
      fprintf fmt "\npartition :\n";
      List.iter 
	(fun (t,cte_l) ->
	   fprintf fmt " %a%a \n" print t
	     (fun fmt -> 
		List.iter (fun l' -> fprintf fmt " == %a" print_S_ast l')) 
	     cte_l) l

    let print_final_solution fmt l = 
      fprintf fmt "\nSolution :\n";
      List.iter
	(fun (a,value) -> 
	   fprintf fmt " %a = %a \n" print a print_C_ast value ) l;
      fprintf fmt "@."
      
  end 

  module Solver = struct

    exception Valid

    let add elt l = if List.mem elt l then l else elt::l
      
    let get_vars = List.fold_left 
      (fun ac st -> match st.bv with 
	|Other v |Ext(v,_,_,_) -> add v ac  |_ -> ac )[] 

    let st_slice st siz = 
      let siz_bis = st.sz - siz in match st.bv with
	|Cte b -> {st with sz = siz},{st with sz = siz_bis}
	|Other x ->
	   let s1 = Ext(x,st.sz, siz_bis, st.sz - 1) in
	   let s2 = Ext(x,st.sz, 0, siz_bis - 1) in
	     {bv = s1 ; sz = siz},{bv = s2 ; sz = siz_bis}
	|Ext(x,s,p,q) -> 
	   let s1 = Ext(x,s,p+siz_bis,q) in
	   let s2 = Ext(x,s,p,p+siz_bis-1) in
	     {bv = s1 ; sz = siz},{bv = s2 ; sz = siz_bis}

    let slice t u  = 
      let f_add (s1,s2) acc = 
	if (s1 = s2 || List.mem (s1,s2) acc || List.mem (s2,s1) acc) then acc
	else (s1,s2)::acc
      in let rec f_rec acc = function
	|[],[] | _,[] | [],_ -> assert false
	|[s1],[s2] ->if s1.sz<>s2.sz then assert false else f_add (s1,s2) acc
	|s1::r1,s2::r2  ->
	   if s1.sz = s2.sz then f_rec (f_add (s1,s2) acc) (r1,r2)
	   else begin
	       if s1.sz > s2.sz then 
		 let (s11,s12) = st_slice s1 s2.sz
		 in f_rec (f_add (s11,s2) acc) (s12::r1,r2)
	       else 
		 let (s21,s22) = st_slice s2 s1.sz
		 in f_rec (f_add (s1,s21) acc) (r1,s22::r2)
	     end
      in f_rec [] (t,u) 

    let fresh_var = 
      let cpt = ref 0 in fun t -> incr cpt; { var = !cpt ; sorte = t}
   	
    let fresh_bitv genre size = 
      if size <= 0 then [] 
      else [ { bv = S_Var (fresh_var genre) ; sz = size } ] 
	   
    let cte_vs_other bol st = st , [{bv = S_Cte bol ; sz = st.sz}]
      
    let cte_vs_ext bol xt s_xt i j =
      let a1  = fresh_bitv A i in
      let a2  = fresh_bitv A (s_xt - 1 - j) in
      let cte = [ {bv = S_Cte bol ; sz =j - i + 1 } ] in
      let var = { bv = Other xt ; sz = s_xt }
      in var, a2@cte@a1
	
    let other_vs_other st1 st2 = 
      let c = fresh_bitv C st1.sz in [ (st1,c) ; (st2,c) ]

    let other_vs_ext st xt s_xt i j =        
      let c  = fresh_bitv C st.sz in
      let a1 = fresh_bitv A i in
      let a2 = fresh_bitv A (s_xt - 1 - j) in
      let extr = { bv = Other xt ; sz = s_xt }
      in [ (st,c) ; (extr,a2 @ c @ a1) ]

    let ext1_vs_ext2 (id,s,i,j) (id',s',i',j') = (* id != id' *)
      let c   = fresh_bitv (C) (j - i + 1) in
      let a1  = fresh_bitv A i  in
      let a1' = fresh_bitv A i' in
      let a2  = fresh_bitv A (s - 1 - j)   in
      let a2' = fresh_bitv A (s' - 1 - j') in
      let x_v = { sz = s  ; bv = Other id  } in
      let y_v = { sz = s' ; bv = Other id' } in
	[ (x_v , a2 @ c @ a1) ; (y_v , a2' @ c @ a1') ]

    let ext_vs_ext xt siz (i1,i2) tai = 
      let overl = i1 + tai -i2 in
	if overl <= 0 then begin
	    let a1 = fresh_bitv A i1     in
	    let a2 = fresh_bitv A (-overl) in
	    let a3 = fresh_bitv A (siz - tai - i2) in
	    let b  = fresh_bitv  B tai
	    in ({ bv = Other xt ; sz = siz } , a3 @ b @ a2 @ b @ a1)
	  end
	else begin
	    let b_box = i2 + tai - i1 in
	    let nn_overl = tai - overl in(* =i2-i1 >0 sinon egalite sytaxique*)
	    let sz_b1 = b_box mod nn_overl in
	    let a1 = fresh_bitv A i1                 in
	    let a3 = fresh_bitv A (siz - tai - i2) in
	    let b1 = fresh_bitv B sz_b1              in
	    let b2 = fresh_bitv B (nn_overl - sz_b1 )in
	    let acc = ref b1 in
	    let cpt = ref nn_overl in
	      while !cpt <= b_box do
		acc := b1 @ b2 @(!acc);
		cpt := !cpt + nn_overl
	      done;
	      ({ bv = Other xt ; sz = siz } , a3 @ (!acc) @ a1)
	  end
	  
    let sys_solve sys = 
      let c_solve (st1,st2) = match st1.bv,st2.bv with
	|Cte _, Cte _ -> raise Exception.Unsolvable (* forcement un 1 et un 0 *)

	|Cte b, Other (Var _) -> [cte_vs_other b st2]
	|Other (Var _), Cte b -> [cte_vs_other b st1]

	|Cte b, Other (Alien t) -> [cte_vs_other b st2]
	|Other (Alien t), Cte b -> [cte_vs_other b st1]

	|Cte b, Ext(xt,s_xt,i,j) -> [cte_vs_ext b xt s_xt i j]
	|Ext(xt,s_xt,i,j), Cte b -> [cte_vs_ext b xt s_xt i j]
	|Other _, Other _ -> other_vs_other st1 st2 

	|Other _, Ext(xt,s_xt,i,j) -> 
	   other_vs_ext st1 xt s_xt i j

	|Ext(xt,s_xt,i,j), Other _ -> other_vs_ext st2 xt s_xt i j
	|Ext(id,s,i,j), Ext(id',s',i',j') -> 
	   if id <> id' then ext1_vs_ext2 (id,s,i,j) (id',s',i',j')
	   else[ext_vs_ext id s (if i<i' then (i,i') else (i',i)) (j - i + 1)]

      in List.flatten (List.map c_solve sys)


    let partition l = 
      let rec add acc (t,cnf) = match acc with
	|[] -> [(t,[cnf])]
	|(t',cnf')::r -> if t = t' then (t',cnf::cnf')::r
	  else (t',cnf')::(add r (t,cnf))
      in List.fold_left add [] l


    let rec slicing_pattern s_l =
      let rec f_aux l1 l2 = match (l1,l2) with
	|[],[] -> []
	|a::r1,b::r2 when a = b -> a::(f_aux r1 r2)
	|a::r1,b::r2 -> 
	   if a < b then a::(f_aux r1 ((b-a)::r2))
	   else b::(f_aux ((a-b)::r1) r2)
	|_ -> assert false
      in List.fold_left f_aux (List.hd s_l)(List.tl s_l)
    
    let slice_var var s1 = 
      let s2 = var.sz - s1 in    
      match var.bv with
	|S_Cte _ -> {var with sz = s1},{var with sz = s2},None
	|S_Var v -> 
	   let (fs,sn,tr) = match v.sorte with
	     |A -> (fresh_var A), (fresh_var A), A
	     |B -> (fresh_var B), (fresh_var B), B
	     |C -> (fresh_var C), (fresh_var C), C
	   in {bv = S_Var fs; sz = s1},{bv = S_Var sn; sz = s2},Some tr
	      
    let rec slice_composition eq pat (ac_eq,c_sub) = match (eq,pat) with
      |[],[] -> (ac_eq,c_sub)
      |st::_,n::_  when st.sz < n -> assert false 
      |st::comp,n::pt -> 
	 if st.sz = n then slice_composition comp pt (st::ac_eq , c_sub)
	 else let (st_n,res,flag) = slice_var st n
	 in begin
	   match flag with
	     |Some B -> let comp' = List.fold_right
		 (fun s_t acc -> if s_t <> st then s_t::acc
		  else st_n::res::acc
		 )comp  []
	       in slice_composition (res::comp') pt (st_n::ac_eq,c_sub)

	     |Some C -> let ac' = (st_n::ac_eq,(st,(st_n,res))::c_sub)
	       in slice_composition (res::comp) pt ac'
		    
	     | _ -> slice_composition (res::comp) pt (st_n::ac_eq,c_sub)
	 end
      | _ -> assert false

    let uniforme_slice vls = 
      let pat = slicing_pattern(List.map (List.map(fun bv ->bv.sz))vls) in
      let rec f_aux acc subs l_vs = match l_vs with
	|[] -> acc,subs
	|eq::eqs -> let (eq',c_subs) = slice_composition eq pat ([],[])
	  in f_aux (List.rev eq'::acc) (c_subs@subs) eqs	   
      in f_aux [] [] vls

    let rec apply_subs subs sys = 
      let rec f_aux = function 
	|[] -> assert false
	|v::r -> try let (v1,v2) = List.assoc v subs in v1::v2::(f_aux r)
	  with _ -> v::(f_aux r)
      in List.map (fun (t,vls) ->(t,List.map f_aux vls))sys   

    let equations_slice parts = 
      let rec slice_rec bw = function
	|[] -> bw 
	|(t,vls)::r -> 
	   let (vls',subs) = uniforme_slice vls
	   in if subs =[] then slice_rec ((t,vls')::bw) r
	   else 
	     begin
	       let _bw = apply_subs subs bw in 
	       let _fw = apply_subs subs r in
	       if _bw = bw then slice_rec ((t,vls')::bw) _fw
	       else slice_rec [] (bw@((t,vls'):: _fw))
	     end
      in slice_rec [] parts   
  
    let rec union_sets sets = 
      let included e1 e2 = 
	try 
	  ST_Set.iter (fun at -> if ST_Set.mem at e2 then raise Exit)e1;
	  false
	with Exit -> true 
      in match sets with 
	|[] -> []
	|st::tl -> 
	   let (ok,ko) = List.partition (included st) tl in 
	   if ok = [] then st::union_sets tl
	   else union_sets ((List.fold_left ST_Set.union st ok)::ko)
	     
    let rec init_sets vals =
      let acc = List.map (fun at -> ST_Set.singleton at) (List.hd vals) in
      let tl = (List.tl vals) in
      let f_aux = List.map2 (fun ac_e e -> ST_Set.add e ac_e)      
      in List.fold_left f_aux acc tl
      
    let equalities_propagation eqs_slic = 
      let init_sets = List.map (fun (t,vls) -> init_sets vls) eqs_slic in
      let init_sets = List.flatten init_sets
      in List.map
	   (fun set -> 
	      let st1 = ST_Set.min_elt set and st2 = ST_Set.max_elt set
	      in  match st1.bv , st2.bv with
		|S_Cte false, S_Cte true -> raise Exception.Unsolvable 
		|S_Cte false , _ -> st1,set 
		|_ , _ -> st2,set    
	   ) (union_sets init_sets)
  
    let build_solution unif_slic sets =  
      let get_rep var = 
	fst(List.find ( fun(rep,set)->ST_Set.mem var set ) sets) in
      let to_external_ast v = 
	{sz = v.sz;
	 bv = match v.bv with
           |S_Cte b -> Cte b
	   |S_Var _ -> 
	      begin
		match (get_rep v).bv with
		  |S_Cte b -> Cte b
		  |S_Var tv -> Other (Var tv)
	      end 
	}in 
      let rec cnf_max l = match l with
	|[] -> []
	|[elt]-> [elt]
	|a::b::r -> 
	   begin
	     match a.bv,b.bv with
	       |Cte bol,Cte bol' when bol = bol' -> 
		  cnf_max ({ b with sz = a.sz + b.sz }::r)	    
	       | _,Cte _ -> a::(cnf_max (b::r))
	       | _ -> a::b::(cnf_max r)
	   end
      in List.map
	(fun (t,vls) -> 
	  t,cnf_max (List.map to_external_ast (List.hd vls))
	)unif_slic
	

    let solve u v =
      if u = v then raise Valid
      else begin
	let varsU = get_vars u in 
	let varsV = get_vars v in
	if varsU = [] && varsV = [] then raise Exception.Unsolvable
	else 
	  begin	      
	    let st_sys = slice u v in
	    let sys_sols = sys_solve st_sys in
	    let parts = partition sys_sols in
	    let unif_slic = equations_slice parts in
	    let eq_pr = equalities_propagation unif_slic in
	    let sol = build_solution unif_slic eq_pr in 
	    if Options.debug_bitv then 
	      begin
		Print.print_sliced_sys err st_sys;
		Print.print_c_solve_res err sys_sols;
		Print.print_partition_res err parts;
		Print.print_partition_res err unif_slic;
		Print.print_final_solution err sol;
	      end;
	    sol
	  end
      end

  end

  let compare b1 b2 = 
    let rec comp l1 l2 = match l1,l2 with
	[] , [] -> 0
      | [] , _ -> -1
      | _ , [] -> 1
      | st1::l1 , st2::l2 -> 
	  let c = compare_simple_term st1 st2 in
	  if c<>0 then c else comp l1 l2
    in comp b1 b2

  let hash_xterm = function
    | Var {var = i; sorte = A} -> 11 * i
    | Var {var = i; sorte = B} -> 17 * i
    | Var {var = i; sorte = C} -> 19 * i
    | Alien r -> 23 * X.hash r

  let hash_simple_term_aux = function
    | Cte b -> 11 * Hashtbl.hash b
    | Other x -> 17 * hash_xterm x
    | Ext (x, a, b, c) -> 
	hash_xterm x + 19 * (a + b + c)
      
  let hash l = 
    List.fold_left 
      (fun acc {bv=r; sz=sz} -> acc + 19 * (sz + hash_simple_term_aux r) ) 19 l

  let leaves bitv = 
    List.fold_left 
      (fun acc x -> 
	 match x.bv with 
	   | Cte _  -> acc
	   | Ext( Var v,sz,_,_) -> 
	       (X.embed [{bv=Other (Var v) ; sz = sz }])::acc
	   | Other (Var _)  -> (X.embed [x])::acc
	   | Other (Alien t) | Ext(Alien t,_,_,_) -> (X.leaves t)@acc
      ) [] bitv

  let is_mine = function [{bv = Other (Alien r)}] -> r | bv -> X.embed bv

  let print = Print.print_C_ast

  let make t = 
    let r, ctx = Canonizer.make t in
    is_mine r, ctx

  let color _ = assert false

  let type_info bv = 
    let sz = List.fold_left (fun acc bv -> bv.sz + acc) 0 bv in
    Ty.Tbitv sz
  
  let to_i_ast biv = 
    let f_aux st = 
      {sz = st.sz;
       bv = match st.bv with
	 | Cte b -> Canonizer.I_Cte b
	 | Other tt -> Canonizer.I_Other tt 
	 | Ext(tt,siz,i,j)  -> 
	     let tt' = { sz = siz ; bv = Canonizer.I_Other tt } 
	     in Canonizer.I_Ext(tt',i,j)
      } in
    List.fold_left
      (fun acc st -> 
	 let tmp = f_aux st
	 in { bv = Canonizer.I_Comp(acc,tmp) ; sz = acc.sz + tmp.sz }
      ) (f_aux (List.hd biv)) (List.tl biv)
      
  let size_of r = 
    match X.type_info r with Ty.Tbitv i -> i | _ -> 
      Format.eprintf "ici=%a@." X.print r;
      assert false
    
  let extract r ty = 
    match X.extract r with 
	Some (u::_ as bv) -> to_i_ast bv
      | None -> {bv =  Canonizer.I_Other (Alien r); sz = ty}
      | Some [] -> assert false

  let extract_xterm r = 
    match X.extract r with 
	Some ([{bv=Other(Var _ as x)}]) -> x
      | None -> Alien r
      | _ -> assert false

  let var_or_term x = 
    match x.bv with
	Other (Var _) -> X.embed [x]
      | Other (Alien r) -> r
      | _ -> assert false


  (* ne resout pas quand c'est deja resolu *)
  let solve u t = 
    if Options.debug_bitv then 
      eprintf "[Bitv] solve %a = %a@." X.print u X.print t;
    
    match X.extract u , X.extract t with 
      | None   , None   -> assert false
      | None   , Some _ -> [u , t]
      | Some _ , None   -> [t , u]
      | Some u , Some t -> 
	  try
	    List.map 
	      (fun (p,v) -> var_or_term p,is_mine v) 
	      (Solver.solve u t)
	  with Solver.Valid -> []
	      

 
  let rec subst_rec x subs biv = 
    match biv.bv , extract_xterm x with
      | Canonizer.I_Cte _ , _ -> biv
      | Canonizer.I_Other (Var y) , Var z when y=z -> extract subs biv.sz
      | Canonizer.I_Other (Var _) , _ -> biv
      | Canonizer.I_Other (Alien tt) , _ -> 
	  if X.compare x tt = 0 then 
	    extract subs biv.sz
	  else extract (X.subst x subs tt) biv.sz
      | Canonizer.I_Ext (t,i,j) , _ -> 
	  { biv with bv = Canonizer.I_Ext(subst_rec x subs t,i,j) }
      | Canonizer.I_Comp (u,v) , _ -> 
	  { biv with 
	      bv = Canonizer.I_Comp(subst_rec x subs u ,subst_rec x subs v)}

  let subst x subs biv = 
    if Options.debug_bitv then 
      eprintf "[Bitv] subst %a |-> %a in %a@." X.print x X.print subs print biv;
    if biv = [] then is_mine biv
    else 
      let r = Canonizer.sigma (subst_rec x subs (to_i_ast biv)) in
      is_mine r

    module M =  Map.Make 
      (struct 
         type t = X.r
         let compare = X.compare 
       end)


  module Map = Map.Make 
    (struct 
       type t = (X.r simple_term) list
       let compare = compare 
     end)
    
  module Set = Set.Make (
    struct 
      type t = (X.r simple_term) list
      let compare = compare
    end)

  let fully_interpreted sb = true

  module Rel = struct

    type r = X.r
    type t =  unit

    let empty () = ()
    let assume _ _ _ = (), []
    let add _ _ = ()
    let case_split _ = []    
    let query _ _ _ = Sig.No
    let instantiate _ _ _ _ _ = (), []
  end

end
end
include (IMPLEMENTATION : INTERFACE)
end
and Arrays: sig
#0 "arrays.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)


type 'a abstract
  
module type ALIEN = sig
  include Sig.X
  val embed : r abstract -> r
  val extract : r -> (r abstract) option
end

module Make 
  (X : ALIEN) : Sig.THEORY with type r = X.r and type t = X.r abstract


end = struct
let _ = Printf.fprintf stderr "Executing arrays.ml\n%!"module type INTERFACE = sig
#0 "arrays.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)


type 'a abstract
  
module type ALIEN = sig
  include Sig.X
  val embed : r abstract -> r
  val extract : r -> (r abstract) option
end

module Make 
  (X : ALIEN) : Sig.THEORY with type r = X.r and type t = X.r abstract


end
module IMPLEMENTATION = struct
#0 "arrays.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Options
open Format
  
module Sy = Symbols
module T  = Term
module A  = Literal
module L  = List
  
type 'a abstract = unit

module type ALIEN = sig
  include Sig.X
  val embed : r abstract -> r
  val extract : r -> (r abstract) option
end

module Make(X : ALIEN) = struct

  type t = X.r abstract
  type r = X.r

  let name           = "Farrays"
  let unsolvable _   = assert false 
  let is_mine_a _    = false
  let is_mine_symb _ = false
  let fully_interpreted sb = assert false
  let is_mine_type _ = false
  let type_info _    = assert false
  let color _        = assert false
  let print _ _      = assert false
  let embed _        = assert false
  let compare _ _    = assert false
  let hash _         = assert false
  let leaves _       = assert false
  let subst _ _ _    = assert false 
  let make _         = assert false
  let solve _ _    = assert false


  module Rel = struct

    open Sig
    module Ex = Explanation

    type r = X.r
    
    module LR = Literal.Make(struct type t = X.r include X end)
    
    (* map get |-> { set } des associations (get,set) deja splites *)
    module Tmap = struct
      include T.Map
      let update t a mp = 
        try add t (T.Set.add a (find t mp)) mp
        with Not_found -> add t (T.Set.singleton a) mp
      let splited t a mp = try T.Set.mem a (find t mp) with Not_found -> false
    end
      
    module LRset= LR.Set

    module Conseq = 
      Set.Make
        (struct
           type t = A.LT.t * Ex.t
           let compare (lt1,_) (lt2,_) = A.LT.compare lt1 lt2
         end)
    (* map k |-> {sem Atom} d'egalites/disegalites sur des atomes semantiques*)
    module LRmap = struct
      include LR.Map
      let find k mp = try find k mp with Not_found -> Conseq.empty
      let add k v ex mp = add k (Conseq.add (v,ex) (find k mp)) mp
    end

    (* ensemble de termes "get" avec leurs arguments et leurs types*)
    type gtype = {g:T.t; gt:T.t; gi:T.t; gty:Ty.t}
    module G :Set.S with type elt = gtype = Set.Make
      (struct type t = gtype let compare t1 t2 = T.compare t1.g t2.g end)

    (* ensemble de termes "set" avec leurs arguments et leurs types *)
    type stype = {s:T.t; st:T.t; si:T.t; sv:T.t; sty:Ty.t}
    module S :Set.S with type elt = stype = Set.Make
      (struct type t = stype let compare t1 t2 = T.compare t1.s t2.s end)

    (* map t |-> {set(t,-,-)} qui associe a chaque tableau l'ensemble 
       de ses affectations *)
    module TBS = struct
      include Map.Make(T)
      let find k mp = try find k mp with Not_found -> S.empty
        
      (* add reutilise find ci-dessus *)
      let add k v mp = add k (S.add v (find k mp)) mp
    end

    type t = 
        {gets  : G.t;               (* l'ensemble des "get" croises*)
         tbset : S.t TBS.t ;        (* map t |-> set(t,-,-) *)
         split : LRset.t;            (* l'ensemble des case-split possibles *)
         conseq   : Conseq.t LRmap.t; (* consequences des splits *)
         seen  : T.Set.t Tmap.t     (* combinaisons (get,set) deja splitees *) }
          

    let empty _ = 
      {gets  = G.empty;
       tbset = TBS.empty;
       split = LRset.empty;
       conseq   = LRmap.empty;
       seen  = Tmap.empty}

    module Debug = struct

      let assume fmt la = 
        if debug_arrays && la <> [] then begin
          fprintf fmt "[Arrays.Rel] We assume@.";
          L.iter (fun (a,_,_) -> fprintf fmt "  > %a@." 
                    LR.print (LR.make a)) la;
        end

      let print_gets fmt = G.iter (fun t -> fprintf fmt "%a@." T.print t.g)
      let print_sets fmt = S.iter (fun t -> fprintf fmt "%a@." T.print t.s)
      let print_splits fmt = 
        LRset.iter (fun a -> fprintf fmt "%a@." LR.print a)
      let print_tbs fmt = 
        TBS.iter (fun k v -> fprintf fmt "%a --> %a@." T.print k print_sets v)

      let env fmt env = 
        if debug_arrays then begin
          fprintf fmt "-- gets ----------------------------------------@.";
          print_gets fmt env.gets;
          fprintf fmt "-- tabs of sets --------------------------------@.";
          print_tbs fmt env.tbset;
          fprintf fmt "-- splits --------------------------------------@.";
          print_splits fmt env.split;
          fprintf fmt "------------------------------------------------@."
        end

      let new_equalities fmt st = 
        if debug_arrays then 
          begin
            fprintf fmt "[Arrays] %d implied equalities@." 
	      (Conseq.cardinal st);
            Conseq.iter (fun (a,ex) -> fprintf fmt "  %a : %a@."
                           A.LT.print a Ex.print ex) st
          end
    end

    (* met a jour gets et tbset en utilisant l'ensemble des termes donne*)
    let update_gets_sets st acc =
      List.fold_left
        (fun (gets,tbset) t ->
           let {T.f=f;xs=xs;ty=ty} = T.view t in 
           match Sy.is_get f, Sy.is_set f, xs with
             | true , false, [a;i]   -> 
                 G.add {g=t; gt=a; gi=i; gty=ty} gets, tbset

             | false, true , [a;i;v] -> 
                 gets, TBS.add a {s=t; st=a; si=i; sv=v; sty=ty} tbset

             | false, false, _ -> 
                 (gets,tbset)

             | _  -> assert false
        )acc st
        
    (* met a jour les composantes gets et tbset de env avec les termes 
       contenus dans les atomes de la *)
    let new_terms env la =
      let fct acc r =
        match X.term_extract r with
          | Some t -> 
              let {T.xs=xs} = T.view t in
              update_gets_sets (t::xs) acc
          | None   -> acc
      in 
      let gets, tbset = 
        L.fold_left
          (fun acc (a,_,_)->
             match a with 
               | A.Eq (r1,r2) -> fct (fct acc r1) r2
               | A.Builtin (_,_,l) | A.Distinct (_, l) -> L.fold_left fct acc l
          )(env.gets,env.tbset) la
      in 
      {env with gets=gets; tbset=tbset}

        
    (* mise a jour de env avec les instances 
       1) p   => p_ded 
       2) n => n_ded *)
    let update_env are_eq are_dist dep env acc gi si p p_ded n n_ded =
      match are_eq gi si, are_dist gi si with
        | Sig.Yes idep, Sig.No -> 
            let conseq = LRmap.add n n_ded dep env.conseq in
            {env with conseq = conseq}, 
            Conseq.add (p_ded, Ex.union dep idep) acc
              
        | Sig.No, Sig.Yes idep -> 
            let conseq = LRmap.add p p_ded dep env.conseq in
            {env with conseq = conseq},
            Conseq.add (n_ded, Ex.union dep idep) acc
              
        | Sig.No, Sig.No ->
            let sp = LRset.add p env.split in
            let conseq = LRmap.add p p_ded dep env.conseq in
            let conseq = LRmap.add n n_ded dep conseq in
            { env with split = sp; conseq = conseq }, acc
              
        | Sig.Yes _,  Sig.Yes _ -> assert false
        
    (*----------------------------------------------------------------------
      get(set(-,-,-),-) modulo egalite
      ---------------------------------------------------------------------*)
    let get_of_set are_eq are_dist gtype (env,acc) class_of = 
      let {g=get; gt=gtab; gi=gi; gty=gty} = gtype in
      L.fold_left
        (fun (env,acc) set -> 
           if Tmap.splited get set env.seen then (env,acc)
           else 
             let env = {env with seen = Tmap.update get set env.seen} in
             let {T.f=f;xs=xs;ty=sty} = T.view set in 
             match Sy.is_set f, xs with
               | true , [stab;si;sv] -> 
                   let xi, _ = X.make gi in
                   let xj, _ = X.make si in
                   let get_stab  = T.make (Sy.Op Sy.Get) [stab;gi] gty in
                   let p       = LR.make (A.Eq(xi,xj)) in
                   let p_ded   = A.LT.make (A.Eq(get,sv)) in
                   let n     = LR.make (A.Distinct(false, [xi;xj])) in
                   let n_ded = A.LT.make (A.Eq(get,get_stab)) in
                   let dep = match are_eq gtab set with
                       Yes dep -> dep | No -> assert false
                   in 
                   update_env are_eq are_dist dep env acc gi si p p_ded n n_ded
               | _ -> (env,acc)
        ) (env,acc) (class_of gtab)

    (*----------------------------------------------------------------------
      get(t,-) and set(t,-,-) modulo egalite
      ---------------------------------------------------------------------*)
    let get_and_set are_eq are_dist gtype (env,acc) class_of =
      let {g=get; gt=gtab; gi=gi; gty=gty} = gtype in
      let suff_sets = 
        L.fold_left
          (fun acc t -> S.union acc (TBS.find t env.tbset))
          S.empty (class_of gtab)
      in
      S.fold
        (fun  {s=set; st=stab; si=si; sv=sv; sty=sty} (env,acc) -> 
           if Tmap.splited get set env.seen then (env,acc)
           else 
             begin
               let env = {env with seen = Tmap.update get set env.seen} in
               let xi, _ = X.make gi in
               let xj, _ = X.make si in
               let get_stab  = T.make (Sy.Op Sy.Get) [stab;gi] gty in
               let gt_of_st  = T.make (Sy.Op Sy.Get) [set;gi] gty in
               let p       = LR.make (A.Eq(xi,xj)) in
               let p_ded   = A.LT.make (A.Eq(gt_of_st,sv)) in
               let n     = LR.make (A.Distinct(false, [xi;xj])) in
               let n_ded = A.LT.make (A.Eq(gt_of_st,get_stab)) in
               let dep = match are_eq gtab stab with
                   Yes dep -> dep | No -> assert false
               in 
               update_env are_eq are_dist dep env acc gi si p p_ded n n_ded
             end
        ) suff_sets (env,acc)
        
    (* Generer de nouvelles instantiations de lemmes *)
    let new_splits are_eq are_dist env acc class_of = 
      G.fold
        (fun gt_info accu ->
           let accu = get_of_set are_eq are_dist  gt_info accu class_of in
           get_and_set are_eq are_dist  gt_info accu class_of
        ) env.gets (env,acc)
        
    (* nouvelles disegalites par instantiation du premier
       axiome d'exentionnalite *)
    let extensionality acc la class_of =
      List.fold_left
        (fun acc (a, _, dep) ->
           match a with 
             | A.Distinct(false, [r;s]) -> 
                 begin
                   match X.type_info r, X.term_extract r, X.term_extract s with
                     | Ty.Tfarray (ty_k, ty_v), Some t1, Some t2  -> 
                         let i  = T.fresh_name ty_k in
                         let g1 = T.make (Sy.Op Sy.Get) [t1;i] ty_v in
                         let g2 = T.make (Sy.Op Sy.Get) [t2;i] ty_v in
                         let d  = A.Distinct(false, [g1;g2]) in
                         Conseq.add (A.LT.make d, dep) acc
                     | _ -> acc
                 end
             | _ -> acc
        ) acc la

    let implied_consequences env eqs la =
      let spl, eqs = 
        L.fold_left
          (fun (spl,eqs) (a,_,dep) ->
             let a = LR.make a in
             let spl = LRset.remove (LR.neg a) (LRset.remove a spl) in
             let eqs = 
               Conseq.fold
                 (fun (fact,ex) acc -> Conseq.add (fact, Ex.union ex dep) acc)
                 (LRmap.find a env.conseq) eqs 
             in
             spl, eqs
          )(env.split, eqs) la
      in
      {env with split=spl}, eqs
        
    (* deduction de nouvelles dis/egalites *)
    let new_equalities env eqs la class_of = 
      let la = L.filter 
        (fun (a,_,_) -> match a with A.Builtin _  -> false | _ -> true) la 
      in
      let eqs = extensionality eqs la class_of in
      implied_consequences env eqs la
        

    (* instantiation des axiomes des tableaux *)
    let instantiate env are_eq are_dist class_of la =
      Debug.assume fmt la; 
      let env = new_terms env la in
      let env, atoms = new_splits are_eq are_dist env Conseq.empty class_of in
      let env, atoms = new_equalities env atoms la class_of in
      Debug.env fmt env;
      Debug.new_equalities fmt atoms;
      env, Conseq.elements atoms 
        
    (* choisir une egalite sur laquelle on fait un case-split *)
    let case_split env = 
      try
        let a = LRset.choose env.split in
        if debug_arrays then 
          fprintf fmt "[Arrays.case-split] %a@." LR.print a;
        [(LR.view a, None), (Num.Int 2)]
      with Not_found ->
        if debug_arrays then fprintf fmt "[Arrays.case-split] Nothing@.";
        []
          
    let assume env _ _ = env, []
    let query a _ _ = Sig.No
    let add env r = env
  end
end
end
include (IMPLEMENTATION : INTERFACE)
end
and Sum: sig
#0 "sum.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type 'a abstract

module type ALIEN = sig
  include Sig.X
  val embed : r abstract -> r
  val extract : r -> (r abstract) option
end

module Make 
  (X : ALIEN) : Sig.THEORY with type r = X.r and type t = X.r abstract

end = struct
let _ = Printf.fprintf stderr "Executing sum.ml\n%!"module type INTERFACE = sig
#0 "sum.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type 'a abstract

module type ALIEN = sig
  include Sig.X
  val embed : r abstract -> r
  val extract : r -> (r abstract) option
end

module Make 
  (X : ALIEN) : Sig.THEORY with type r = X.r and type t = X.r abstract

end
module IMPLEMENTATION = struct
#0 "sum.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Options
open Format
open Exception  
module Sy = Symbols
module T  = Term
module A  = Literal
module L  = List
module Hs = Hstring
module Ex = Explanation

type 'a abstract = Cons of Hs.t * Ty.t |  Alien of 'a

module type ALIEN = sig
  include Sig.X
  val embed : r abstract -> r
  val extract : r -> (r abstract) option
end

module Make(X : ALIEN) = struct

  type t = X.r abstract
  type r = X.r

  let name = "Sum"
  
  let unsolvable _ = false
  
  let is_mine_a _ = false
  
  let is_mine_symb = function 
    | Sy.Name(_, Sy.Constructor) -> true 
    | _ -> false
        
  let fully_interpreted sb = true

  let type_info = function
    | Cons (_, ty) -> ty
    | Alien x -> X.type_info x
        
  let is_mine_type c = match type_info c with
    | Ty.Tsum _ -> true 
    | _ -> false
        
  let color _ = assert false
  
  let print fmt = function
    | Cons (hs,ty) -> fprintf fmt "%s" (Hs.view hs)
    | Alien x -> fprintf fmt "%a" X.print x

  let embed r =
    match X.extract r with
      | Some c -> c
      | None -> Alien r 

  let is_mine = function
    | Alien r -> r
    | Cons(hs,ty) as c -> X.embed c
        
  let compare c1 c2 = 
    match c1 , c2 with
      | Cons (h1,ty1) , Cons (h2,ty2)  -> 
          let n = Hs.compare h1 h2 in
          if n <> 0 then n else Ty.compare ty1 ty2
      | Alien r1, Alien r2 -> X.compare r1 r2
      | Alien _ , Cons _   -> 1
      | Cons _  , Alien _  -> -1
    
  let hash = function
    | Cons (h, ty) -> Hstring.hash h + 19 * Ty.hash ty
    | Alien r -> X.hash r

  let leaves _ = []

  let subst p v c = 
    let cr = is_mine c in
    if X.equal p cr then v
    else 
      match c with
        | Cons(hs,t) -> cr
        | Alien r    -> X.subst p v r
    
  let make t = match T.view t with
    | {T.f=Sy.Name(hs, Sy.Constructor); xs=[];ty=ty} ->
        is_mine (Cons(hs,ty)), []
    | _ -> assert false
        
  let solve a b = 
    match embed a, embed b with
      | Cons(c1,_) , Cons(c2,_) when Hs.equal c1 c2 -> []
      | Cons(c1,_) , Cons(c2,_) -> raise Unsolvable
      | Cons _     , Alien r2   -> [r2,a]
      | Alien r1   , Cons _     -> [r1,b]
      | Alien _    , Alien _    -> assert false
    
  let solve a b = 
    if debug_sum then fprintf fmt "[Sum] we solve %a = %a@."  
      X.print a X.print b;
    try
      let res = solve a b in
      if debug_sum then (match res with
          [p,v] -> fprintf fmt "\twe get: %a |-> %a@." X.print p X.print v
        | []    -> fprintf fmt "\tthe equation is trivial@."
        | _ -> assert false);
      res
    with Unsolvable -> 
      if debug_sum then fprintf fmt "\tthe equation is unsolvable@.";
      raise Unsolvable

  module Rel = struct
    type r = X.r

    exception Not_Cons

    module Ex = Explanation

    module MX = Map.Make(struct type t = X.r include X end)
    module HSS = Set.Make (struct type t=Hs.t let compare = Hs.compare end)

    type t = (HSS.t * Ex.t) MX.t

    let empty () = MX.empty

    module Debug = struct

      let assume bol r1 r2 =
        if debug_sum then
          fprintf fmt "[Sum.Rel] we assume %a %s %a@." 
            X.print r1 (if bol then "=" else "<>") X.print r2

        let print_env env =
          if debug_sum then begin
            fprintf fmt "--SUM env ---------------------------------@.";
            MX.iter
              (fun r (hss, ex) ->
                 fprintf fmt "%a ::= " X.print r;
                 begin
                   match HSS.elements hss with
                       []      -> ()
                     | hs :: l ->
                         fprintf fmt " %s" (Hs.view hs);
                         L.iter (fun hs -> fprintf fmt " | %s" (Hs.view hs)) l
                 end;
                 fprintf fmt " : %a@." Ex.print ex;
                       
              ) env;
            fprintf fmt "-------------------------------------------@.";
          end
    end

    let values_of r = match X.type_info r with
      | Ty.Tsum (_,l) -> 
        Some (List.fold_left (fun st hs -> HSS.add hs st) HSS.empty l)
      | _ -> None

    let add_diseq hss sm1 sm2 dep env eqs = 
      match sm1, sm2 with
        | Alien r , Cons(h,ty) 
        | Cons (h,ty), Alien r  ->
          let enum, ex = try MX.find r env with Not_found -> hss, Ex.empty in
          let enum = HSS.remove h enum in
          let ex = Ex.union ex dep in
          if HSS.is_empty enum then raise (Inconsistent ex)
          else 
            let env = MX.add r (enum, ex) env in
            if HSS.cardinal enum = 1 then
              let h' = HSS.choose enum in
              env, (A.Eq(r, is_mine (Cons(h',ty))), None, ex)::eqs
            else env, eqs
              
        | Alien r1   , Alien r2   -> env, eqs
        |  _ -> env, eqs

    let add_eq hss sm1 sm2 dep env eqs = 
      match sm1, sm2 with
        | Alien r , Cons(h,ty) 
        | Cons (h,ty), Alien r  ->
          let enum, ex = try MX.find r env with Not_found -> hss, Ex.empty in
          let ex = Ex.union ex dep in
          if HSS.mem h enum then MX.add r (HSS.singleton h, ex) env, eqs
          else raise (Inconsistent ex)
            
        | Alien r1 , Alien r2   -> 
          let enum1,ex1 = try MX.find r1 env with Not_found -> hss, Ex.empty in
          let enum2,ex2 = try MX.find r2 env with Not_found -> hss, Ex.empty in
          let ex = Ex.union dep (Ex.union ex1 ex2) in
          let diff = HSS.inter enum1 enum2 in 
          if HSS.is_empty diff then raise (Inconsistent ex)
          else 
            let env = MX.add r1 (diff, ex) env in
            let env = MX.add r2 (diff, ex) env in
            if HSS.cardinal diff = 1 then
              let h' = HSS.choose diff in
              let ty = X.type_info r1 in
              env, (A.Eq(r1, is_mine (Cons(h',ty))), None, ex)::eqs
            else env, eqs
        |  _ -> env, eqs

    let assume env la expl = 
      let aux bol r1 r2 dep env eqs = function
        | None     -> env, eqs
        | Some hss -> 
            Debug.assume bol r1 r2;
            if bol then 
              add_eq hss (embed r1) (embed r2) dep env eqs
            else
              add_diseq hss (embed r1) (embed r2) dep env eqs
      in
      Debug.print_env env;
      List.fold_left
        (fun (env,eqs) -> function
          | A.Eq(r1,r2) , _, ex -> 
              aux true  r1 r2 (Ex.union expl ex) env eqs (values_of r1)

          | A.Distinct(false, [r1;r2]), _, ex -> 
              aux false r1 r2 (Ex.union expl ex) env eqs (values_of r1)

          | _ -> env, eqs

        ) (env,[]) la

    let case_split env = 
      let acc = MX.fold
        (fun r (hss, ex) acc ->
           let sz = HSS.cardinal hss in
           if sz = 1 then acc
           else match acc with
	     | Some (n,r,hs) when n <= sz -> acc
	     | _ -> Some (sz, r, HSS.choose hss)
        ) env None 
      in
      match acc with 
        | Some (n,r,hs) -> 
	    let r' = is_mine (Cons(hs,X.type_info r)) in
	    if debug_sum then
	      fprintf fmt "[case-split] %a = %a@." X.print r X.print r';
	    [(A.Eq(r, r'), None), Num.Int n]
        | None -> 
	    if debug_sum then fprintf fmt "[case-split] sum: nothing@.";
	    []
      

    let query (a,r) env expl =
      try ignore(assume env [a,r,Explanation.empty] expl); Sig.No
      with Inconsistent expl -> Sig.Yes expl          

    let add env r = match embed r, values_of r with
      | Alien r, Some hss -> 
          if MX.mem r env then env else 
            MX.add r (hss, Ex.empty) env

      | _ -> env

    let instantiate env _ _ _ _ = env, []

  end
end
end
include (IMPLEMENTATION : INTERFACE)
end
and Combine: sig
#0 "combine.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

module CX : Sig.X
end = struct
let _ = Printf.fprintf stderr "Executing combine.ml\n%!"module type INTERFACE = sig
#0 "combine.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

module CX : Sig.X
end
module IMPLEMENTATION = struct
#0 "combine.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Format
open Options
open Sig

module rec CX : sig
  include Sig.X

  val extract1 : r -> X1.t option
  val embed1 : X1.t -> r

  val extract2 : r -> X2.t option
  val embed2 : X2.t -> r

  val extract3 : r -> X3.t option
  val embed3 : X3.t -> r

  val extract4 : r -> X4.t option
  val embed4 : X4.t -> r

  val extract5 : r -> X5.t option
  val embed5 : X5.t -> r

end =
struct

  (* Xi < Term < Ac *)
  type r =
    | Term  of Term.t (* XXX changement de l'ordre pour Arrays *)
    | Ac    of AC.t
    | X1    of X1.t 
    | X2    of X2.t 
    | X3    of X3.t 
    | X4    of X4.t 
    | X5    of X5.t 
    
  let extract1 = function X1 r   -> Some r | _ -> None
  let extract2 = function X2 r   -> Some r | _ -> None
  let extract3 = function X3 r   -> Some r | _ -> None
  let extract4 = function X4 r   -> Some r | _ -> None
  let extract5 = function X5 r   -> Some r | _ -> None
  
  let embed1 x = X1 x
  let embed2 x = X2 x
  let embed3 x = X3 x
  let embed4 x = X4 x  
  let embed5 x = X5 x
	
  let is_an_eq a = 
    match Literal.LT.view a with Literal.Builtin _ -> false | _ -> true

  let is_int v = 
    let ty  = match v with
      | X1 x -> X1.type_info x
      | X2 x -> X2.type_info x
      | X3 x -> X3.type_info x
      | X4 x -> X4.type_info x
      | X5 x -> X5.type_info x
      | Term t -> (Term.view t).Term.ty
      | Ac x -> AC.type_info x
    in 
    ty = Ty.Tint
      
  let rec compare a b = 
    let c = compare_tag a b in 
    if c = 0 then comparei a b else c

  and compare_tag a b = 
    Pervasives.compare (theory_num a) (theory_num b)
      
  and comparei a b = 
    match a, b with
      | X1 x, X1 y -> X1.compare x y
      | X2 x, X2 y -> X2.compare x y
      | X3 x, X3 y -> X3.compare x y
      | X4 x, X4 y -> X4.compare x y
      | X5 x, X5 y -> X5.compare x y
      | Term x  , Term y  -> Term.compare x y
      | Ac x    , Ac    y -> AC.compare x y
      | _                 -> assert false

  and theory_num x = Obj.tag (Obj.repr x)

  let equal a b = compare a b = 0

  let hash = function
    | Term  t -> Term.hash t 
    | Ac x -> AC.hash x
    | X1 x -> X1.hash x
    | X2 x -> X2.hash x
    | X3 x -> X3.hash x
    | X4 x -> X4.hash x
    | X5 x -> X5.hash x

  module MR = Map.Make(struct type t = r let compare = compare end)
    
  let print fmt r = 
    if verbose then 
      match r with
        | X1 t    -> fprintf fmt "X1(%s):[%a]" X1.name X1.print t
        | X2 t    -> fprintf fmt "X2(%s):[%a]" X2.name X2.print t
        | X3 t    -> fprintf fmt "X3(%s):[%a]" X3.name X3.print t
        | X4 t    -> fprintf fmt "X3(%s):[%a]" X4.name X4.print t
        | X5 t    -> fprintf fmt "X3(%s):[%a]" X5.name X5.print t
        | Term t  -> fprintf fmt "FT:[%a]" Term.print t
        | Ac t    -> fprintf fmt "Ac:[%a]" AC.print t
          
    else 
      match r with
        | X1 t    -> fprintf fmt "%a" X1.print t
        | X2 t    -> fprintf fmt "%a" X2.print t
        | X3 t    -> fprintf fmt "%a" X3.print t
        | X4 t    -> fprintf fmt "%a" X4.print t
        | X5 t    -> fprintf fmt "%a" X5.print t
        | Term t  -> fprintf fmt "%a" Term.print t
        | Ac t    -> fprintf fmt "%a" AC.print t

            
  let leaves r = 
    match r with 
      | X1 t -> X1.leaves t 
      | X2 t -> X2.leaves t 
      | X3 t -> X3.leaves t 
      | X4 t -> X4.leaves t 
      | X5 t -> X5.leaves t 
      | Ac t -> r :: (AC.leaves t)
      | Term _ -> [r]

  let ac_extract = function
      Ac t   -> Some t
    | _ -> None

  let ac_embed ({Sig.l = l} as t) = 
    match l with
      | []    -> 
	  assert false
      | [x, 1] -> x
      | l     -> 
	  let sort = List.fast_sort (fun (x,n) (y,m) -> compare x y) in
	  Ac { t with Sig.l = List.rev (sort l) }

  let term_embed t = Term t

  let term_extract = function Term t -> Some t | _ -> None

  let subst p v r = 
    if equal p v then r 
    else match r with
      | X1 t   -> X1.subst p v t
      | X2 t   -> X2.subst p v t
      | X3 t   -> X3.subst p v t
      | X4 t   -> X4.subst p v t
      | X5 t   -> X5.subst p v t
      | Ac t   -> if equal p r then v else AC.subst p v t
      | Term _ -> if equal p r then v else r

  let make t = 
    let {Term.f=sb} = Term.view t in
    match 
      X1.is_mine_symb sb,
      X2.is_mine_symb sb,
      X3.is_mine_symb sb,
      X4.is_mine_symb sb,
      X5.is_mine_symb sb,
      AC.is_mine_symb sb 
    with
      | true  , false , false, false, false, false -> X1.make t
      | false , true  , false, false, false, false -> X2.make t
      | false , false , true , false, false, false -> X3.make t
      | false , false , false, true , false, false -> X4.make t
      | false , false , false, false, true , false -> X5.make t
      | false , false , false, false, false, true  -> AC.make t
      | false , false , false, false, false, false -> Term t, []
      | _ -> assert false
	  
  let fully_interpreted sb =
    match 
      X1.is_mine_symb sb,
      X2.is_mine_symb sb,
      X3.is_mine_symb sb,
      X4.is_mine_symb sb,
      X5.is_mine_symb sb,
      AC.is_mine_symb sb 
    with
      | true  , false , false, false, false, false -> X1.fully_interpreted sb
      | false , true  , false, false, false, false -> X2.fully_interpreted sb
      | false , false , true , false, false, false -> X3.fully_interpreted sb
      | false , false , false, true , false, false -> X4.fully_interpreted sb
      | false , false , false, false, true , false -> X5.fully_interpreted sb
      | false , false , false, false, false, true  -> AC.fully_interpreted sb
      | false , false , false, false, false, false -> false
      | _ -> assert false


  let color ac = 
    match ac.Sig.l with
      | [] -> assert false
      | [r,1] -> r
      | _ -> 
        match 
          X1.is_mine_symb ac.Sig.h, 
          X2.is_mine_symb ac.Sig.h, 
          X3.is_mine_symb ac.Sig.h, 
          X4.is_mine_symb ac.Sig.h, 
          X5.is_mine_symb ac.Sig.h, 
          AC.is_mine_symb ac.Sig.h with 
	    | true  , false , false, false, false, false -> X1.color ac
	    | false , true  , false, false, false, false -> X2.color ac
	    | false , false , true , false, false, false -> X3.color ac
	    | false , false , false, true , false, false -> X4.color ac
	    | false , false , false, false, true, false -> X5.color ac
	    | false , false , false, false, false, true  -> ac_embed ac
	    | _ -> assert false
              

  let add_mr =
    List.fold_left 
      (fun solved (p,v) -> 
	 MR.add p (v::(try MR.find p solved with Not_found -> [])) solved)

  let unsolvable = function
    | X1 x -> X1.unsolvable x
    | X2 x -> X2.unsolvable x 
    | X3 x -> X3.unsolvable x 
    | X4 x -> X4.unsolvable x 
    | X5 x -> X5.unsolvable x 
    | Ac _ | Term _  -> true
	
  let partition tag = 
    List.partition 
      (fun (u,t) -> 
	 (theory_num u = tag || unsolvable u) && 
	   (theory_num t = tag || unsolvable t))

  let rec solve_list  solved l =
    List.fold_left
      (fun solved (a,b) -> 
         if debug_combine then
           fprintf fmt "solve_list %a=%a@." print a print b;
	 let cmp = compare a b in
	 if cmp = 0 then solved else
	   match a , b with
	       (* both sides are empty *)
	     | (Term _ | Ac _) , (Term _ | Ac _) -> 
		 add_mr solved (unsolvable_values cmp  a b)
		   
	     (* only one side is empty *)
	     | (a, b) 
                 when unsolvable a || unsolvable b ||  compare_tag a b = 0 ->
		 let a,b = if unsolvable a then b,a else a,b in
		 let cp , sol = partition (theory_num a) (solvei  b a) in
		 solve_list  (add_mr solved cp) sol
		   
	     (* both sides are not empty *)
	     | a , b -> solve_theoryj  solved a b
      ) solved l

  and unsolvable_values cmp a b =
    match a, b with
      (* Clash entre theories: On peut avoir ces pbs ? *)
      | X1 _, (X2 _ | X3 _ | X4 _ | X5 _) 
      | (X2 _ | X3 _ | X4 _ | X5 _), X1 _ 
      | X2 _, (X3 _ | X4 _ | X5 _) 
      | (X3 _ | X4 _ | X5 _), X2 _ 
      | X3 _, (X4 _ | X5 _)
      | (X4 _ | X5 _) , X3 _
      | X5 _, X4 _ -> assert false

      (* theorie d'un cote, vide de l'autre *)
      | X1 _, _ | _, X1 _ -> X1.solve a b
      | X2 _, _ | _, X2 _ -> X2.solve a b
      | X3 _, _ | _, X3 _ -> X3.solve a b
      | X4 _, _ | _, X4 _ -> X4.solve a b
      | X5 _, _ | _, X5 _ -> X5.solve a b
      | (Ac _|Term _), (Ac _|Term _) -> [if cmp > 0 then a,b else b,a]

  and solve_theoryj solved xi xj =
    if debug_combine then
      fprintf fmt "solvej %a=%a@." print xi print xj;
    let cp , sol = partition (theory_num xj) (solvei  xi xj) in
    solve_list  (add_mr solved cp) (List.rev_map (fun (x,y) -> y,x) sol)

  and solvei  a b =
    if debug_combine then
      fprintf fmt "solvei %a=%a@." print a print b;
    match b with
      | X1 _ -> X1.solve  a b
      | X2 _ -> X2.solve  a b
      | X3 _ -> X3.solve  a b
      | X4 _ -> X4.solve  a b
      | X5 _ -> X5.solve  a b
      | Term _ | Ac _ -> 
          (* XXX pour Arrays *)
          match a with
            | X4 _  -> X4.solve  a b
            | _ -> 
	        fprintf fmt "solvei %a = %a @." print a print b;
	        assert false

  let rec solve_rec  mt ab = 
    let mr = solve_list  mt ab in
    let mr , ab = 
      MR.fold 
	(fun p lr ((mt,ab) as acc) -> match lr with
	     [] -> assert false
	   | [_] -> acc
	   | x::lx -> 
	       MR.add p [x] mr , List.rev_map (fun y-> (x,y)) lx)	 
	mr (mr,[])
    in 
    if ab=[] then mr else solve_rec  mr ab
      
  let solve  a b =
    MR.fold 
      (fun p lr ret -> 
	 match lr with [r] -> (p ,r)::ret | _ -> assert false) 
      (solve_rec  MR.empty [a,b]) []


  let solve  a b =
    if debug_combine then 
      fprintf fmt "[combine] solving %a = %a yields:@." print a print b;
    let sbs = solve  a b in
    if debug_combine then begin
      let c = ref 0 in
      List.iter 
        (fun (p,v) -> 
           incr c;
           fprintf fmt " %d) %a |-> %a@." !c print p print v) sbs
    end;
    sbs


  let rec type_info = function
    | X1 t   -> X1.type_info t
    | X2 t   -> X2.type_info t
    | X3 t   -> X3.type_info t
    | X4 t   -> X4.type_info t
    | X5 t   -> X5.type_info t
    | Ac x   -> AC.type_info x
    | Term t -> let {Term.ty = ty} = Term.view t in ty
	
  module Rel =
  struct
    type elt = r
    type r = elt

    type t = { 
      r1: X1.Rel.t; 
      r2: X2.Rel.t; 
      r3: X3.Rel.t;  
      r4: X4.Rel.t; 
      r5: X5.Rel.t; 
    }
	
    let empty _ = {
      r1=X1.Rel.empty (); 
      r2=X2.Rel.empty (); 
      r3=X3.Rel.empty ();
      r4=X4.Rel.empty ();
      r5=X5.Rel.empty ();
    }
	
    let assume env sa expl = 
      let env1, seq1 = X1.Rel.assume env.r1 sa expl in
      let env2, seq2 = X2.Rel.assume env.r2 sa expl in
      let env3, seq3 = X3.Rel.assume env.r3 sa expl in
      let env4, seq4 = X4.Rel.assume env.r4 sa expl in
      let env5, seq5 = X5.Rel.assume env.r5 sa expl in
      {r1=env1; r2=env2; r3=env3; r4=env4; r5=env5}, seq1@seq2@seq3@seq4@seq5

    let instantiate env are_eq are_dist class_of sa = 
      let env1, seq1 = X1.Rel.instantiate env.r1 are_eq are_dist class_of sa in
      let env2, seq2 = X2.Rel.instantiate env.r2 are_eq are_dist class_of sa in
      let env3, seq3 = X3.Rel.instantiate env.r3 are_eq are_dist class_of sa in
      let env4, seq4 = X4.Rel.instantiate env.r4 are_eq are_dist class_of sa in
      let env5, seq5 = X5.Rel.instantiate env.r5 are_eq are_dist class_of sa in 
      {r1=env1; r2=env2; r3=env3; r4=env4; r5=env5}, seq1@seq2@seq3@seq4@seq5
	
    let query a env expl = 
      match X1.Rel.query a env.r1 expl with
	| Yes _ as ans -> ans
	| No -> match X2.Rel.query a env.r2 expl with
	    | Yes _ as ans -> ans
	    | No -> match X3.Rel.query a env.r3 expl with
		| Yes _ as ans -> ans
		| No -> match X4.Rel.query a env.r4 expl with
		    | Yes _ as ans -> ans
		    | No -> X5.Rel.query a env.r5 expl
		      
    let case_split env = 
      let seq1 = X1.Rel.case_split env.r1 in
      let seq2 = X2.Rel.case_split env.r2 in
      let seq3 = X3.Rel.case_split env.r3 in
      let seq4 = X4.Rel.case_split env.r4 in
      let seq5 = X5.Rel.case_split env.r5 in
      seq1 @ seq2 @ seq3 @ seq4 @ seq5

    let add env r =
      {r1=X1.Rel.add env.r1 r;
       r2=X2.Rel.add env.r2 r;
       r3=X3.Rel.add env.r3 r;
       r4=X4.Rel.add env.r4 r;
       r5=X5.Rel.add env.r5 r;
      }
  end

end

and TX1 : Polynome.T with type r = CX.r = Arith.Type(CX)

and X1 : Sig.THEORY  with type t = TX1.t and type r = CX.r =
  Arith.Make(CX)(TX1)
    (struct
       type t = TX1.t
       type r = CX.r
       let extract = CX.extract1
       let embed =  CX.embed1
     end)

and X2 : Sig.THEORY with type r = CX.r and type t = CX.r Pairs.abstract =
  Pairs.Make
    (struct
       include CX
       let extract = extract2
       let embed = embed2
     end)

and X3 : Sig.THEORY with type r = CX.r and type t = CX.r Bitv.abstract =
  Bitv.Make
    (struct
       include CX
       let extract = extract3
       let embed = embed3
     end)

and X4 : Sig.THEORY with type r = CX.r and type t = CX.r Arrays.abstract =
  Arrays.Make
    (struct
       include CX
       let extract = extract4
       let embed = embed4
     end)

 (* Its signature is not Sig.THEORY because it doen't provide a solver *)
and AC : Ac.S with type r = CX.r = Ac.Make(CX)

and X5 : Sig.THEORY with type r = CX.r and type t = CX.r Sum.abstract =
  Sum.Make
    (struct
       include CX
       let extract = extract5
       let embed = embed5
     end)
end
include (IMPLEMENTATION : INTERFACE)
end
and Cc: sig
#0 "cc.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

(* Persistent and incremental congruence-closure modulo X data structure. 

   This module implements the CC(X) algorithm.

*)

module type S = sig
  type t

  val empty : unit -> t
  val assume : Literal.LT.t -> Explanation.t -> t -> t * int
  val query : Literal.LT.t -> t -> Sig.answer
  val class_of : t -> Term.t -> Term.t list
end

module Make (X:Sig.X) : S
end = struct
let _ = Printf.fprintf stderr "Executing cc.ml\n%!"module type INTERFACE = sig
#0 "cc.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

(* Persistent and incremental congruence-closure modulo X data structure. 

   This module implements the CC(X) algorithm.

*)

module type S = sig
  type t

  val empty : unit -> t
  val assume : Literal.LT.t -> Explanation.t -> t -> t * int
  val query : Literal.LT.t -> t -> Sig.answer
  val class_of : t -> Term.t -> Term.t list
end

module Make (X:Sig.X) : S
end
module IMPLEMENTATION = struct
#0 "cc.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Format
open Options
open Sig
open Exception


module type S = sig
  type t

  val empty : unit -> t
  val assume : Literal.LT.t -> Explanation.t -> t -> t * int
  val query : Literal.LT.t -> t -> answer
  val class_of : t -> Term.t -> Term.t list
end

module Make (X : Sig.X) = struct    

  module Ex = Explanation
  module SetA = Use.SA
  module Use = Use.Make(X)
  module Uf = Uf.Make(X)
  module SetF = Formula.Set
  module T = Term
  module A = Literal
  module LR = A.Make(struct type t = X.r include X end)
  module SetT = Term.Set
  module S = Symbols

  module SetX = Set.Make(struct type t = X.r let compare = X.compare end)
    
  type env = { 
    use : Use.t;  
    uf : Uf.t ;
    relation : X.Rel.t
  }

  type t = { 
    gamma : env;
    gamma_finite : env ;
    choices : (X.r A.view * Num.num * bool) list; 
  }

  module Print = struct


    let make_cst t ctx =
      if ctx = [] then ()
      else begin
        fprintf fmt "[cc] contraints of make(%a)@." Term.print t;
        let c = ref 0 in
        List.iter 
          (fun a ->
             incr c;
             fprintf fmt " %d) %a@." !c A.LT.print a) ctx
      end

    let lrepr fmt = List.iter (fprintf fmt "%a " X.print)

    let congruent t1 t2 flg = 
      fprintf fmt "@{<C.Bold>[cc]@} cong %a=%a ? [%s]@." 
	T.print t1 T.print t2 flg

    let add_to_use t = fprintf fmt "@{<C.Bold>[cc]@} add_to_use: %a@." T.print t
	
    let leaves t lvs = 
      fprintf fmt "@{<C.Bold>[cc]@} leaves of %a@.@." T.print t; lrepr fmt lvs
  end

  let compat_leaves env lt1 lt2 = 
    List.fold_left2
      (fun dep x y -> 
	 match Uf.are_equal env.uf x y with
	   | No -> raise Exception.NotCongruent
	   | Yes ex -> Ex.union ex dep) Ex.empty lt1 lt2

  let terms_congr env u1 u2 = 
    if Term.compare u1 u2 = 0 then raise Exception.Trivial;
    let {T.f=f1;xs=xs1;ty=ty1} = T.view u1 in
    if X.fully_interpreted f1 then raise Exception.Interpreted_Symbol
    else 
      let {T.f=f2;xs=xs2;ty=ty2} = T.view u2 in
      if Symbols.equal f1 f2 && Ty.equal ty1 ty2 then
        let ex = compat_leaves env xs1 xs2  in
        if debug_cc then Print.congruent u1 u2 "Yes";
        ex
      else 
        begin
	  if debug_cc then Print.congruent u1 u2 "No";
	  raise Exception.NotCongruent
        end

	      
  let concat_leaves uf l = 
    let one, _ = X.make (Term.make (S.name "@bottom") [] Ty.Tint) in 
    let rec concat_rec acc t = 
      match  X.leaves (fst (Uf.find uf t)) , acc with
	  [] , _ -> one::acc
	| res, [] -> res
	| res , _ -> List.rev_append res acc
    in
    match List.fold_left concat_rec [] l with
	[] -> [one]
      | res -> res

  let fex env ex l = 
    List.fold_left 
      (fun (lr, ex) t -> 
	 let r, ex_r = Uf.find env.uf t in 
	 r::lr, Ex.union ex_r ex)
      ([], ex) l

  let semantic_view env a ex_a = 
    match A.LT.view a with
      | A.Distinct (b, lt) -> 
	  let lr, ex = fex env ex_a lt in 
	  A.Distinct (b, lr), ex
      | A.Builtin(b, s, l) -> 
	  let lr, ex  = fex env ex_a l in
	  A.Builtin(b, s, List.rev lr), ex
      | _ -> assert false

  let rec close_up t1 t2 dep env =
    if debug_cc then 
      printf "@{<C.Bold>[cc]@} close_up: %a = %a@." T.print t1 T.print t2;

    (* we merge equivalence classes of t1 and t2 *)
    let r1, ex1 = Uf.find env.uf t1 in
    let r2, ex2 = Uf.find env.uf t2 in
    let dep = Explanation.union (Explanation.union ex1 ex2) dep in
    close_up_r r1 r2 dep env

  and close_up_r r1 r2 dep env =
    let uf, res = Uf.union env.uf r1 r2 dep in
    List.fold_left 
      (fun env (p,touched,v) ->
	 
	 (* we look for use(p) *)
      	 let gm_p_t, gm_p_a = Use.find p env.use in
	 
	 (* we compute terms and atoms to consider for congruence *)
	 let repr_touched = List.map (fun (_,a,_) -> a) touched in
	 let st_others, sa_others = Use.congr_close_up env.use p repr_touched in
	 
	 (* we update use *)
	 let nuse = Use.up_close_up env.use p v in
	 
	 (* we print updates in Gamma and Ac-Gamma *)
	 if debug_use then Use.print nuse;
	 
	 (* we check the congruence of the terms. *)
	 let env = replay_terms gm_p_t st_others {env with use=nuse} in
	 
       	 let eqs_nonlin = 
	   List.map (fun (x,y,e)-> (A.Eq(x, y), None, e)) touched 
	 in
         replay_atom env (SetA.union gm_p_a sa_others) eqs_nonlin dep
	   
      ) {env with uf=uf}  res
      

  and replay_terms gm_p_t st_others env = 
    SetT.fold 
      (fun x env -> 
	 SetT.fold 
	   (fun y env -> 
              try close_up x y (terms_congr env x y) env
	      with
                  Exception.NotCongruent
                | Exception.Trivial 
                | Exception.Interpreted_Symbol -> env
	   ) st_others env
      ) gm_p_t env


  and replay_atom env sa eqs_nonlin dep = 
    let sa = SetA.fold 
      (fun (a, ex_a) acc -> 
	 let ra, ex_ra = semantic_view env a ex_a in
	 (ra, Some a, ex_ra)::acc) 
      sa eqs_nonlin 
    in
    replay_atom_r env sa dep
	
  and replay_atom_r env sa dep = 
    let rel, leqs  = X.Rel.assume env.relation sa dep in
    let are_eq = Uf.are_equal env.uf in
    let are_dist = Uf.are_distinct env.uf in
    let rel, atoms = 
      X.Rel.instantiate rel are_eq are_dist (Uf.class_of env.uf) sa in
    let env = play_eqset {env with relation = rel} leqs dep in
    List.fold_left (fun env (a,ex) -> assume a ex env) env atoms

  and play_eqset env leqs dep =
    List.fold_left
      (fun env (ra, a, ex) -> 
	 (* TODO ajouter les galits dans Use avec les explications*)
         match ra with
           | A.Eq(r1,r2) -> 
	       let r1,_ = Uf.find_r env.uf r1 in
	       let r2,_ = Uf.find_r env.uf r2 in
	       let st_r1, sa_r1 = Use.find r1 env.use in
	       let st_r2, sa_r2 = Use.find r2 env.use in
	       let sa_r1', sa_r2' = match a with 
	         | Some a -> 
                     SetA.remove (a,ex) sa_r1, SetA.remove (a,ex) sa_r2 
	         | None -> sa_r1, sa_r2
	       in
	       let use =  Use.add r1 (st_r1, sa_r1') env.use in
	       let use =  Use.add r2 (st_r2, sa_r2') use in
	       (*TODO ou ex U dep*)	     
	       close_up_r r1 r2 (Ex.union ex dep) { env with use = use}
           (* XXX: les tableaux peuvent retourner des diseq aussi ! 
              Il faut factoriser un peu le code par la suite *)
           | A.Distinct (false, lr) -> 
	       let env = {env with uf = Uf.distinct env.uf lr dep} in
               replay_atom_r env [ra, None, ex] dep
           | _ -> assert false

      ) env leqs

  and congruents env t s = 
    SetT.fold 
      (fun t2 acc ->
	 if T.equal t t2 then acc
	 else 
	   try (t,t2,terms_congr env t t2)::acc
	   with
               Exception.NotCongruent
             | Exception.Interpreted_Symbol -> acc
      ) s []
	   
  (* add a new term in env *)   	

  and add_term expl env t = 
    if debug_cc then Print.add_to_use t;
    (* nothing to do if the term already exists *)
    if Uf.mem env.uf t then env
    else
      (* we add t's arguments in env *)
      let {T.f = f; xs = xs} = T.view t in
      let env = List.fold_left (add_term expl) env xs in
      (* we update uf and use *)
      let nuf, ctx  = Uf.add env.uf t in 
      if debug_cc then Print.make_cst t ctx;
      let rt,_   = Uf.find nuf t in (* XXX : ctx only in terms *)
      let lvs = concat_leaves nuf xs in
      let nuse = Use.up_add env.use t rt lvs in
      
      (* If finitetest is used we add the term to the relation *)
      let rel = X.Rel.add env.relation rt in

      (* print updates in Gamma *)
      if debug_use then Use.print nuse;

      (* we compute terms to consider for congruence *)
      (* we do this only for non-atomic terms with uninterpreted head-symbol *)
      let st_uset = Use.congr_add nuse lvs in
      
      (* we check the congruence of each term *)
      let env = {uf = nuf; use = nuse; relation = rel} in 
      let env = 
        List.fold_left (fun env a -> assume a expl env) env ctx in

      let ct = congruents env t st_uset in
      List.fold_left (fun e (x, y, dep) -> close_up x y dep e) env ct
	
  and add a expl env =
    match A.LT.view a with
      | A.Eq (t1, t2) -> add_term expl (add_term expl env t1) t2
      | A.Distinct (_, lt) -> List.fold_left (add_term expl) env lt
      | A.Builtin (_, _, lt) ->
	  let env = List.fold_left (add_term expl) env lt in
	  let lvs = concat_leaves env.uf lt in (* A verifier *)
	  List.fold_left
	    (fun env rx ->
	       let st_uset, sa_uset = Use.find rx env.use in
	       { env with 
		 use = Use.add rx (st_uset,SetA.add (a, expl) sa_uset) env.use }
	    ) env lvs

  and negate_prop t1 uf bol =
    match T.view t1 with
	{T.f=f1 ; xs=[a]} ->
	  List.fold_left 
	    (fun acc t2 ->
	       match T.view t2 with
		 | {T.f=f2 ; xs=[b]} when S.equal f1 f2 ->
                     let dist = 
		       A.LT.make (A.Distinct (false, [a; b])) in
                     begin match Uf.are_distinct uf t1 t2 with
                       | Yes ex -> (dist,ex) :: acc
                       | No -> assert false
                     end
		 | _ -> acc
	    )[] (Uf.class_of uf bol)
      | _ -> []
	  
  and assume_rec dep env a =
	(* explications a revoir *)
    try begin
    match A.LT.view a with
      | A.Eq(t1,t2) ->
	  let env = close_up t1 t2 dep env in
	  if Options.nocontracongru then env
	  else begin
	    let facts = match T.equal t2 T.faux , T.equal t2 T.vrai with
	      | true , false -> negate_prop t1 env.uf T.vrai
	      | false, true  -> negate_prop t1 env.uf T.faux
	      | _ , _        -> []
	    in 
            if debug_cc then
              begin
                fprintf fmt "[cc] %d equalities by contra-congruence@." 
                  (List.length facts);
                List.iter 
                  (fun (a,ex) ->
                     fprintf fmt "\t%a : %a@." A.LT.print a Ex.print ex) facts;
              end;
	    List.fold_left 
              (fun env (a,ex) -> assume_rec (Ex.union ex dep) env a) env facts
	  end
      | A.Distinct (false, lt) -> 
	  let lr, ex = fex env dep lt in
	  let env = {env with uf = Uf.distinct env.uf lr ex} in
	  let env = replay_atom env (SetA.singleton (a, dep)) [] dep in
	  contra_congruence env lr (Ex.union ex dep)

      | A.Distinct (true, _) -> assert false

      | _ -> replay_atom env (SetA.singleton (a, dep)) [] dep
    end with Inconsistent dep' -> raise (Inconsistent (Ex.union dep dep'))

  and assume a dep env =
    let env = assume_rec dep (add a dep env) a in
    if debug_uf then Uf.print fmt env.uf;
    env

  and contra_congruence env lr dep =
    if Options.nocontracongru then env
    else
      let mp =
        List.fold_left
          (fun mp r -> match X.term_extract r with
             | None -> mp
             | Some t ->
                 match T.view t with 
                   | {T.f=sy; xs=[a]} ->
                       let l = try S.Map.find sy mp with Not_found -> [] in
                       S.Map.add sy (a::l) mp
                   | _ -> mp
          ) S.Map.empty lr
      in 
      S.Map.fold
        (fun sy l env ->
           assume_rec dep env (A.LT.make (A.Distinct (false, l)))) mp env

(*

if Options.nocontracongru then env
	  else begin
	    let r1, ex1 = Uf.find env.uf t1 in
	    let r2, ex2 = Uf.find env.uf t2 in
	    let dep = Explanation.union (Explanation.union ex1 ex2) dep in
	    begin
	      match T.view t1,T.view t2 with
		| {T.f = f1; xs = [a]},{T.f = f2; xs = [b]}
		    when (S.equal f1 f2 
			  && X.equal (X.term_embed t1) r1 
			  && X.equal (X.term_embed t2) r2) 
		      -> 
		    assume_rec dep env (A.LT.make (A.Neq(a,b)))
		| _,_ -> env
	    end
	  end
	    
*)
    

  let assume_r env ra dep =
    match ra with
      | A.Eq(r1, r2) ->
          let env = replay_atom_r env [ra, None, dep] dep in
          close_up_r r1 r2 dep env
      | A.Distinct (false, lr) ->
	  let env = {env with uf = Uf.distinct env.uf lr dep} in
          replay_atom_r env [ra, None, dep] dep
      | A.Distinct (true, _) -> assert false
      | _ ->
          replay_atom_r env [ra, None, dep] dep


  let rec look_for_sat ?(bad_last=false) t base_env l dep =
    let rec aux bad_last dl base_env dep = function
      | [] -> 
	begin
          match X.Rel.case_split base_env.relation with
	    | [] -> 
	      { t with 
		gamma_finite = base_env; 
		choices = List.rev dl }
	    | l ->
	      let l = List.map (fun ((c,_), size) -> (c, size, false)) l in
	      let sz =
		List.fold_left
		  (fun acc (a,s,_) ->  Num.mult_num acc s) (Num.Int 1) (l@dl) in
	      if debug_split then
		fprintf fmt ">size case-split: %s@." (Num.string_of_num sz);
	      if Num.le_num sz max_split then aux false dl base_env dep l
	      else
		{ t with 
		  gamma_finite = base_env; 
		  choices = List.rev dl }
	end
      | ((c, size, true) as a)::l ->
	  let base_env = assume_r base_env c dep in
	  aux bad_last (a::dl) base_env dep l

      | [(c, size, false)] when bad_last ->
          (* XXX * Quelle explication pour la backtrack ?
             -> Celle de Inconsistent de try_it. C'est la qu'on appelle
          look_for_sat avec bad_last=true *)
          let neg_c = LR.neg (LR.make c) in
          if debug_split then
            fprintf fmt "[case-split] I backtrack on %a : %a@."
              LR.print neg_c Ex.print dep;
	  aux false dl base_env dep [LR.view neg_c, Num.Int 1, true] 

      | ((c, size, false) as a)::l ->
	  try
	    let base_env = assume_r base_env c dep in
	    aux bad_last (a::dl) base_env dep l
	  with Exception.Inconsistent dep' ->
            let neg_c = LR.neg (LR.make c) in
            (* Faut-il vraiement faire l'union ? *)
            let ex = Ex.union dep dep' in
            if debug_split then
              fprintf fmt "[case-split] I backtrack on %a : %a@." 
                LR.print neg_c Ex.print ex;
	    aux false dl base_env ex [LR.view neg_c, Num.Int 1, true] 
    in
    aux bad_last (List.rev t.choices) base_env dep l

  let try_it f t dep =
    if debug_split then
      fprintf fmt "============= Begin CASE-SPLIT ===============@.";
    let r =
      try 
	if t.choices = [] then 
	  look_for_sat t t.gamma [] dep
	else
	  try
	    let env = f t.gamma_finite in
	    look_for_sat t env [] dep
	  with Exception.Inconsistent dep' ->
            (* Faut-il vraiement faire l'union des dep ? *)
            let ex = Ex.union dep dep' in
	    look_for_sat ~bad_last:true { t with choices = []} t.gamma t.choices ex
      with Exception.Inconsistent d ->
	if debug_split then
	  fprintf fmt "============= Fin CASE-SPLIT ===============@.";
	raise (Exception.Inconsistent d)
    in
    if debug_split then
      fprintf fmt "============= Fin CASE-SPLIT ===============@.";
    r
  
  let assume a ex t = 
    (*let ex = Ex.union ex (Explanation.singleton (Formula.mk_lit a)) in*)
    let t = { t with gamma = assume a ex t.gamma } in
    let t = try_it (assume a ex) t  ex (* XXX: voir les explications *) in 
    t, 1

  let class_of t term = Uf.class_of t.gamma.uf term
	      
  let query a t = 
    try
      let t = { t with gamma = add a Explanation.empty t.gamma } in
      let t =  try_it (add a Explanation.empty) t Explanation.empty in
      let env = t.gamma in
      if debug_use then Use.print t.gamma.use;    
      match A.LT.view a with
	| A.Eq (t1, t2)  -> 
	    Uf.are_equal env.uf t1 t2

	| A.Distinct (false, [t1; t2]) -> 
	    Uf.are_distinct env.uf t1 t2

	| A.Distinct _ -> 
	    assert false (* devrait etre capture par une analyse statique *)

	| _ -> 
	      let na = A.LT.neg a in
	      let rna, ex_rna = semantic_view env na Ex.empty in
              X.Rel.query (rna, Some na) env.relation ex_rna
    with Exception.Inconsistent d -> Yes d

  let empty () = 
    let env = { 
      use = Use.empty ; 
      uf = Uf.empty ; 
      relation = X.Rel.empty ();
    }
    in
    let t = { gamma = env; gamma_finite = env; choices = [] } in
    fst 
      (assume 
	 (A.LT.make (A.Distinct (false, [T.vrai; T.faux])))
	 Ex.empty t)

end
end
include (IMPLEMENTATION : INTERFACE)
end
and Heap: sig
#0 "heap.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

(*
 * Heap: heaps implemented both functionally and imperatively
 * Copyright (C) 2003 Jean-Christophe FILLIATRE
 * 
 * This software is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License version 2, as published by the Free Software Foundation.
 * 
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * See the GNU Library General Public License version 2 for more details
 * (enclosed in the file LGPL).
 *)

(* Heaps *)

module type Ordered = sig
  type t
  val compare : t -> t -> int
end

exception EmptyHeap

(*S Imperative implementation. *)

module Imperative(X: Ordered) : sig

  (* Type of imperative heaps.
     (In the following [n] refers to the number of elements in the heap) *)

  type t 

  (* [create c] creates a new heap, with initial capacity of [c] *)
  val create : int -> t

  (* [is_empty h] checks the emptiness of [h] *)
  val is_empty : t -> bool

  (* [add x h] adds a new element [x] in heap [h]; size of [h] is doubled
     when maximum capacity is reached; complexity $O(log(n))$ *)
  val add : t -> X.t -> unit

  (* [maximum h] returns the maximum element of [h]; raises [EmptyHeap]
     when [h] is empty; complexity $O(1)$ *)
  val maximum : t -> X.t

  (* [remove h] removes the maximum element of [h]; raises [EmptyHeap]
     when [h] is empty; complexity $O(log(n))$ *)
  val remove : t -> unit

  (* [pop_maximum h] removes the maximum element of [h] and returns it;
     raises [EmptyHeap] when [h] is empty; complexity $O(log(n))$ *)
  val pop_maximum : t -> X.t

  (* usual iterators and combinators; elements are presented in
     arbitrary order *)
  val iter : (X.t -> unit) -> t -> unit

  val fold : (X.t -> 'a -> 'a) -> t -> 'a -> 'a

end

(*S Functional implementation. *)

module type FunctionalSig = sig

  (* heap elements *)
  type elt

  (* Type of functional heaps *)
  type t

  (* The empty heap *)
  val empty : t

  (* [add x h] returns a new heap containing the elements of [h], plus [x];
     complexity $O(log(n))$ *)
  val add : elt -> t -> t

  (* [maximum h] returns the maximum element of [h]; raises [EmptyHeap]
     when [h] is empty; complexity $O(1)$ *)
  val maximum : t -> elt

  (* [remove h] returns a new heap containing the elements of [h], except
     the maximum of [h]; raises [EmptyHeap] when [h] is empty; 
     complexity $O(log(n))$ *) 
  val remove : t -> t

  (* usual iterators and combinators; elements are presented in
     arbitrary order *)
  val iter : (elt -> unit) -> t -> unit

  val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a

end

module Functional(X: Ordered) : FunctionalSig with type elt = X.t
end = struct
let _ = Printf.fprintf stderr "Executing heap.ml\n%!"module type INTERFACE = sig
#0 "heap.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

(*
 * Heap: heaps implemented both functionally and imperatively
 * Copyright (C) 2003 Jean-Christophe FILLIATRE
 * 
 * This software is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License version 2, as published by the Free Software Foundation.
 * 
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * See the GNU Library General Public License version 2 for more details
 * (enclosed in the file LGPL).
 *)

(* Heaps *)

module type Ordered = sig
  type t
  val compare : t -> t -> int
end

exception EmptyHeap

(*S Imperative implementation. *)

module Imperative(X: Ordered) : sig

  (* Type of imperative heaps.
     (In the following [n] refers to the number of elements in the heap) *)

  type t 

  (* [create c] creates a new heap, with initial capacity of [c] *)
  val create : int -> t

  (* [is_empty h] checks the emptiness of [h] *)
  val is_empty : t -> bool

  (* [add x h] adds a new element [x] in heap [h]; size of [h] is doubled
     when maximum capacity is reached; complexity $O(log(n))$ *)
  val add : t -> X.t -> unit

  (* [maximum h] returns the maximum element of [h]; raises [EmptyHeap]
     when [h] is empty; complexity $O(1)$ *)
  val maximum : t -> X.t

  (* [remove h] removes the maximum element of [h]; raises [EmptyHeap]
     when [h] is empty; complexity $O(log(n))$ *)
  val remove : t -> unit

  (* [pop_maximum h] removes the maximum element of [h] and returns it;
     raises [EmptyHeap] when [h] is empty; complexity $O(log(n))$ *)
  val pop_maximum : t -> X.t

  (* usual iterators and combinators; elements are presented in
     arbitrary order *)
  val iter : (X.t -> unit) -> t -> unit

  val fold : (X.t -> 'a -> 'a) -> t -> 'a -> 'a

end

(*S Functional implementation. *)

module type FunctionalSig = sig

  (* heap elements *)
  type elt

  (* Type of functional heaps *)
  type t

  (* The empty heap *)
  val empty : t

  (* [add x h] returns a new heap containing the elements of [h], plus [x];
     complexity $O(log(n))$ *)
  val add : elt -> t -> t

  (* [maximum h] returns the maximum element of [h]; raises [EmptyHeap]
     when [h] is empty; complexity $O(1)$ *)
  val maximum : t -> elt

  (* [remove h] returns a new heap containing the elements of [h], except
     the maximum of [h]; raises [EmptyHeap] when [h] is empty; 
     complexity $O(log(n))$ *) 
  val remove : t -> t

  (* usual iterators and combinators; elements are presented in
     arbitrary order *)
  val iter : (elt -> unit) -> t -> unit

  val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a

end

module Functional(X: Ordered) : FunctionalSig with type elt = X.t
end
module IMPLEMENTATION = struct
#0 "heap.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

(*
 * Heap: heaps implemented both functionally and imperatively
 * Copyright (C) 2003 Jean-Christophe FILLIATRE
 * 
 * This software is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License version 2, as published by the Free Software Foundation.
 * 
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * See the GNU Library General Public License version 2 for more details
 * (enclosed in the file LGPL).
 *)

(*s Heaps *)

module type Ordered = sig
  type t
  val compare : t -> t -> int
end

exception EmptyHeap

(*s Imperative implementation *)

module Imperative(X : Ordered) = struct

  (* The heap is encoded in the array [data], where elements are stored
     from [0] to [size - 1]. From an element stored at [i], the left 
     (resp. right) subtree, if any, is rooted at [2*i+1] (resp. [2*i+2]). *)

  type t = { mutable size : int; mutable data : X.t array }

  (* When [create n] is called, we cannot allocate the array, since there is
     no known value of type [X.t]; we'll wait for the first addition to 
     do it, and we remember this situation with a negative size. *)

  let create n = 
    if n <= 0 then invalid_arg "create";
    { size = -n; data = [||] }

  let is_empty h = h.size <= 0

  (* [resize] doubles the size of [data] *)

  let resize h =
    let n = h.size in
    assert (n > 0);
    let n' = 2 * n in
    let d = h.data in
    let d' = Array.create n' d.(0) in
    Array.blit d 0 d' 0 n;
    h.data <- d'

  let add h x =
    (* first addition: we allocate the array *)
    if h.size < 0 then begin
      h.data <- Array.create (- h.size) x; h.size <- 0
    end;
    let n = h.size in
    (* resizing if needed *)
    if n == Array.length h.data then resize h;
    let d = h.data in
    (* moving [x] up in the heap *)
    let rec moveup i =
      let fi = (i - 1) / 2 in
      if i > 0 && X.compare d.(fi) x < 0 then begin
	d.(i) <- d.(fi);
	moveup fi
      end else
	d.(i) <- x
    in
    moveup n;
    h.size <- n + 1

  let maximum h =
    if h.size <= 0 then raise EmptyHeap;
    h.data.(0)

  let remove h =
    if h.size <= 0 then raise EmptyHeap;
    let n = h.size - 1 in
    h.size <- n;
    let d = h.data in
    let x = d.(n) in
    (* moving [x] down in the heap *)
    let rec movedown i =
      let j = 2 * i + 1 in
      if j < n then
	let j = 
	  let j' = j + 1 in 
	  if j' < n && X.compare d.(j') d.(j) > 0 then j' else j 
	in
	if X.compare d.(j) x > 0 then begin 
	  d.(i) <- d.(j); 
	  movedown j 
	end else
	  d.(i) <- x
      else
	d.(i) <- x
    in
    movedown 0

  let pop_maximum h = let m = maximum h in remove h; m

  let iter f h = 
    let d = h.data in
    for i = 0 to h.size - 1 do f d.(i) done

  let fold f h x0 =
    let n = h.size in
    let d = h.data in
    let rec foldrec x i =
      if i >= n then x else foldrec (f d.(i) x) (succ i)
    in
    foldrec x0 0

end


(*s Functional implementation *)

module type FunctionalSig = sig
  type elt
  type t
  val empty : t
  val add : elt -> t -> t
  val maximum : t -> elt
  val remove : t -> t
  val iter : (elt -> unit) -> t -> unit
  val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
end

module Functional(X : Ordered) = struct

  (* Heaps are encoded as complete binary trees, i.e., binary trees
     which are full expect, may be, on the bottom level where it is filled 
     from the left. 
     These trees also enjoy the heap property, namely the value of any node 
     is greater or equal than those of its left and right subtrees.

     There are 4 kinds of complete binary trees, denoted by 4 constructors:
     [FFF] for a full binary tree (and thus 2 full subtrees);
     [PPF] for a partial tree with a partial left subtree and a full
     right subtree;
     [PFF] for a partial tree with a full left subtree and a full right subtree
     (but of different heights);
     and [PFP] for a partial tree with a full left subtree and a partial
     right subtree. *)

  type elt = X.t

  type t = 
    | Empty
    | FFF of t * X.t * t (* full    (full,    full) *)
    | PPF of t * X.t * t (* partial (partial, full) *)
    | PFF of t * X.t * t (* partial (full,    full) *)
    | PFP of t * X.t * t (* partial (full,    partial) *)

  let empty = Empty
 
  (* smart constructors for insertion *)
  let p_f l x r = match l with
    | Empty | FFF _ -> PFF (l, x, r)
    | _ -> PPF (l, x, r)

  let pf_ l x = function
    | Empty | FFF _ as r -> FFF (l, x, r)
    | r -> PFP (l, x, r)

  let rec add x = function
    | Empty -> 
	FFF (Empty, x, Empty)
    (* insertion to the left *)
    | FFF (l, y, r) | PPF (l, y, r) ->
	if X.compare x y > 0 then p_f (add y l) x r else p_f (add x l) y r
    (* insertion to the right *)
    | PFF (l, y, r) | PFP (l, y, r) ->
	if X.compare x y > 0 then pf_ l x (add y r) else pf_ l y (add x r)

  let maximum = function
    | Empty -> raise EmptyHeap
    | FFF (_, x, _) | PPF (_, x, _) | PFF (_, x, _) | PFP (_, x, _) -> x

  (* smart constructors for removal; note that they are different
     from the ones for insertion! *)
  let p_f l x r = match l with
    | Empty | FFF _ -> FFF (l, x, r)
    | _ -> PPF (l, x, r)

  let pf_ l x = function
    | Empty | FFF _ as r -> PFF (l, x, r)
    | r -> PFP (l, x, r)

  let rec remove = function
    | Empty -> 
	raise EmptyHeap
    | FFF (Empty, _, Empty) -> 
	Empty
    | PFF (l, _, Empty) ->
	l
    (* remove on the left *)
    | PPF (l, x, r) | PFF (l, x, r) ->
        let xl = maximum l in
	let xr = maximum r in
	let l' = remove l in
	if X.compare xl xr >= 0 then 
	  p_f l' xl r 
	else 
	  p_f l' xr (add xl (remove r))
    (* remove on the right *)
    | FFF (l, x, r) | PFP (l, x, r) ->
        let xl = maximum l in
	let xr = maximum r in
	let r' = remove r in
	if X.compare xl xr > 0 then 
	  pf_ (add xr (remove l)) xl r'
	else 
	  pf_ l xr r'

  let rec iter f = function
    | Empty -> 
	()
    | FFF (l, x, r) | PPF (l, x, r) | PFF (l, x, r) | PFP (l, x, r) -> 
	iter f l; f x; iter f r

  let rec fold f h x0 = match h with
    | Empty -> 
	x0
    | FFF (l, x, r) | PPF (l, x, r) | PFF (l, x, r) | PFP (l, x, r) -> 
	fold f l (fold f r (f x x0))

end
end
include (IMPLEMENTATION : INTERFACE)
end
and Existantial: sig
#0 "existantial.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

val make : int quant_form -> int tform
end = struct
let _ = Printf.fprintf stderr "Executing existantial.ml\n%!"module type INTERFACE = sig
#0 "existantial.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

val make : int quant_form -> int tform
end
module IMPLEMENTATION = struct
#0 "existantial.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

let eq_var x t = 
  match t.c.tt_desc with
    | TTvar y -> Symbols.equal x y
    | _ -> false

let rec find_eq x eqs f = match f.c with
  | TFatom ({c=TAeq [t1;t2]}) -> 
      if eq_var x t1 then (x,t2)::eqs 
      else if eq_var x t2 then (x,t1)::eqs
      else eqs
  | TFop (OPand,l) -> List.fold_left (find_eq x) eqs l
  | _ -> eqs (* XXX: TODO *)

let find_equalities lv f = 
  List.fold_left 
    (fun eqs (x,_) -> 
       let l = find_eq x [] f in 
       if l = [] then raise Not_found; l::eqs ) [] lv

let rec apply_subst_term env t = 
  let tt = match t.c.tt_desc with
    | TTvar x as tt -> 
	(try (List.assoc x env).c.tt_desc with Not_found -> tt)
    | TTapp(s,l) -> TTapp(s,List.map (apply_subst_term env) l)
    | TTinfix(t1,s,t2) -> 
	TTinfix(apply_subst_term env t1,s,apply_subst_term env t2)
    | tt -> tt
  in
  { t with c = { t.c with tt_desc = tt }}

let rec apply_subst_formula env f = 
  let c = match f.c with
    | TFatom e -> 
	let a = match e.c with
	  | TAeq l -> TAeq (List.map (apply_subst_term env) l) 
	  | TAneq l -> TAneq (List.map (apply_subst_term env) l)
	  | TAdistinct l -> TAdistinct (List.map (apply_subst_term env) l)
	  | TAle l -> TAle (List.map (apply_subst_term env) l)
	  | TAlt l -> TAlt (List.map (apply_subst_term env) l)
	  | TAbuilt(s,l) -> TAbuilt(s,List.map (apply_subst_term env) l)
	  | TApred t -> TApred (apply_subst_term env t)
	  | TAfalse | TAtrue -> assert false
	in TFatom {e with c = a}
    | TFop (op, lf) ->
	TFop (op, List.map (apply_subst_formula env) lf)
    | TFforall _ | TFexists _ -> f.c (* XXX: TODO *)
    | _ -> f.c 
  in
  { f with c = c }
	
let make_instance f = 
  let lt = find_equalities f.qf_bvars f.qf_form in
  apply_subst_formula (List.map List.hd lt) f.qf_form

let make f = 
  if Options.no_rm_eq_existential 
  then TFexists f
  else
    try (*TFop(OPor,[TFexists f;*)
      (make_instance f).c
    (*])*) 
    with Not_found -> TFexists f

end
include (IMPLEMENTATION : INTERFACE)
end
and Pruning: sig
#0 "pruning.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

val split_and_prune :
  int -> (int tdecl, int) annoted list -> 
  ((int tdecl,int) annoted * bool) list list
end = struct
let _ = Printf.fprintf stderr "Executing pruning.ml\n%!"module type INTERFACE = sig
#0 "pruning.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

val split_and_prune :
  int -> (int tdecl, int) annoted list -> 
  ((int tdecl,int) annoted * bool) list list
end
module IMPLEMENTATION = struct
#0 "pruning.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

module F = Formula

module HS = struct
  type t = H of Hstring.t | STrue | SFalse
  let compare x y = match x,y with
    | H x, H y -> Hstring.compare x y
    | H _, _ -> -1
    | _, H _ -> 1
    | STrue, STrue -> 0
    | STrue, SFalse -> -1
    | SFalse, STrue -> 1
    | SFalse, SFalse -> 0
	
  let hash = function 
      H x -> Hstring.hash x | STrue -> 0 | SFalse -> 1
	
  let equal x y = compare x y = 0

  let view = function
      H x -> Hstring.view x | STrue -> "True" | SFalse -> "False"
end

module GF = Graph.Persistent.Digraph.ConcreteLabeled
  (HS)
  (struct 
     type t = string
     let compare = Pervasives.compare
     let default = "_default_axiom_"
   end)

module SetH = Set.Make (Hstring)
module SetHS = Set.Make (HS)
module SetS = Set.Make (struct type t = string let compare = compare end)
module HtblHS = Hashtbl.Make(Hstring)

let graph_attrs = ref (fun g -> [])
let edge_attrs = ref (fun e -> [])
let vertex_attrs = ref (fun v -> [])

module PrintG = Graph.Graphviz.Dot
  (struct
     include GF
     let graph_attributes g = (!graph_attrs g)
     let default_vertex_attributes g = []
     let vertex_name v = HS.view v
     let vertex_attributes v = `Style(`Filled)::(!vertex_attrs v)
     let get_subgraph v = None
     let default_edge_attributes g = []
     let edge_attributes e = `Label(E.label e)::(!edge_attrs e)
   end)

let print_graph g =
  let name , cout = Filename.open_temp_file "tmp_graph" ".dot" in
  let ps = name^".ps" in
  PrintG.output_graph cout g;
  ignore(Sys.command ("dot -Tps "^name^" > "^ps^" && evince "^ps))

module Polarite = struct
  type t = Plus | Moins | Neutre

  let not = function
      Plus -> Moins
    | Moins -> Plus
    | Neutre -> Neutre
	
  let xor b1 b2 =
    match b1,b2 with
	Plus , b | b , Plus -> b
      | Neutre , _ | _ , Neutre -> Neutre
      | Moins , Moins -> Plus

  let add p1 p2 = if p1 = p2 then p1 else Neutre

end


module PInfo = struct

  type spn = { mutable pos : SetH.t; mutable neg :  SetH.t; }
  type t_symb = { 
    all_symbs : spn; 
    conclusion : spn; 
    args : (Hstring.t * ((Polarite.t * bool) option) ref ) list
  }
      
  let defs = HtblHS.create 17

  let var_of_symb =  function
      Symbols.Var hs -> hs
    | _ -> assert false
 
  let init s l =  
    HtblHS.add defs s 
      {all_symbs = {pos = SetH.empty ; neg = SetH.empty };
       conclusion = {pos = SetH.empty ; neg = SetH.empty };
       args = List.rev_map (fun x -> (var_of_symb x,ref None)) l}

  let find p = try
    let { all_symbs = {pos=spos;neg=sneg}; 
	  conclusion = {pos=cpos;neg=cneg}; args=args} = HtblHS.find defs p in
    let args = List.map (fun (_,x) -> !x) args in
    spos , sneg , cpos, cneg , args
  with Not_found -> 
    SetH.empty , SetH.empty, SetH.singleton p, SetH.empty , []

  let update_spn v pol s = 
    match pol with
	Polarite.Plus -> v.pos <- SetH.add s v.pos
      | Polarite.Moins -> v.neg <- SetH.add s v.neg
      | Polarite.Neutre -> v.pos <- SetH.add s v.pos; v.neg <- SetH.add s v.neg

  let add p pol concl s = try
    let v = HtblHS.find defs p in
    update_spn (if concl then v.conclusion else v.all_symbs) pol s
  with Not_found -> assert false
    
  let set p pol concl x = try
    let {args=args} =  HtblHS.find defs p in
    (try 
       let info = List.assoc x args in
       info := 
	 match !info with
	     None -> Some(pol,concl)
	   | Some(pol',concl') -> Some(Polarite.add pol pol',concl || concl')
     with Not_found -> ())
  with Not_found -> assert false

    
end

let symbs_of_term add set pol concl t = 
  let pol = ref pol in
  let rec symb_rec t = 
    match t.c.tt_desc with
      | TTvar (Symbols.Name (hs,_)) -> add !pol concl hs
      | TTvar (Symbols.Var hs) -> set !pol concl hs
      | TTapp (Symbols.Name (hs,_), l) ->
	  add !pol concl hs;
	  List.iter symb_rec l
      | TTinfix (t1,_,t2) -> symb_rec t1; symb_rec  t2
      | _ -> ()
  in symb_rec t

let symbs_in_formula add set f = 
  let rec symbs_rec pol concl f = match f.c with 
    | TFatom {c = TApred {c={tt_desc = TTapp (Symbols.Name (hs,_), l)}}} -> 
	let spos , sneg , cpos , cneg , args = PInfo.find hs in
	SetH.iter (add pol false) spos;
	SetH.iter (add (Polarite.not pol) false) sneg;
	SetH.iter (add pol concl) cpos;
	SetH.iter (add (Polarite.not pol) concl) cneg;
	begin
	  match args with 
	      [] -> 
		List.iter (symbs_of_term add set pol concl) l
	    | _ -> 
		List.iter2
		  (fun t x -> 
		     match x with 
			 None -> ()
		       | Some(pol',concl') -> 
			   let pol'' = Polarite.xor pol pol' in
			   let concl'' = concl' && concl in
			   symbs_of_term add set pol'' concl'' t
		  ) l args
	end

    | TFatom {c = (TAbuilt(_,l)  | TAeq l | TAneq l | TAdistinct l
		  | TAle l | TAlt l)} ->
	List.iter (symbs_of_term add set pol concl) l

    | TFatom _ -> ()

    | TFop ((OPand | OPor), fl) ->
	List.iter (symbs_rec pol concl) fl

    | TFop (OPnot, [f]) ->
	symbs_rec (Polarite.not pol) concl f

    | TFop (OPimp,[f1;f2]) ->
	symbs_rec (Polarite.not pol) false f1;
	symbs_rec pol concl f2

    | TFop (OPiff,[f1;f2]) ->
	let imp f1 f2 = { c = TFop(OPimp,[f1;f2]); annot = 0 } in
	symbs_rec pol concl 
	  {c = TFop(OPand,[imp f1 f2; imp f2 f1]);
	   annot = 0}

    | TFop(OPif _,[f1;f2]) ->
	failwith "OPif is not implemented"

    | TFforall {qf_form = f} | TFexists {qf_form = f} -> 
	symbs_rec pol concl f

    | TFlet _ ->
        failwith "let is not implemented"

    | _ -> assert false
  in
  symbs_rec Polarite.Plus true f

let analyze_formula s g f =
  let spos = ref SetH.empty in
  let sneg = ref SetH.empty in
  let add p _ s = match p with
      Polarite.Plus -> spos := SetH.add s !spos 
    | Polarite.Moins -> sneg := SetH.add s !sneg 
    | Polarite.Neutre -> spos := SetH.add s !spos; sneg := SetH.add s !sneg 
  in
  symbs_in_formula add (fun _ _ _ -> ()) f;
  let spos , sneg = !spos , !sneg in
  match SetH.is_empty spos, SetH.is_empty sneg with
    | true, true -> 
	GF.add_edge_e g (GF.E.create HS.SFalse s HS.STrue)
    | true, false ->
	SetH.fold 
	  (fun sn g -> 
	     GF.add_edge_e g (GF.E.create (HS.H sn) s HS.SFalse))
	  sneg g
    | false, true ->
	SetH.fold 
	  (fun sp g -> 
	     GF.add_edge_e g (GF.E.create HS.STrue s (HS.H sp)))
	  spos g
    | false, false ->
	SetH.fold 
	  (fun sp g -> 
	     SetH.fold 
	       (fun sn g -> 
		  GF.add_edge_e g (GF.E.create (HS.H sn) s (HS.H sp)))
	       sneg g)
	  spos g
	  
let analyze_deps decl_list =
  List.fold_left
    (fun (g,gls) d -> match d.c with
       | TAxiom (_,s,f) ->
	   analyze_formula s g f, gls
       | TPredicate_def 
	   (_,s,_, {c = TFforall {qf_form = {c=TFop(OPiff,[f1;f2])}; 
				  qf_bvars = lvars}}) ->
	   let l , _ = List.split lvars in
	   let s = Hstring.make s in
	   PInfo.init s l;
	   symbs_in_formula (PInfo.add s) (PInfo.set s) f2;
	   (g, gls)
       | TPredicate_def _ -> assert false
       | TGoal (l,s,f) -> (g, (s,f)::gls)
       | _ -> (g,gls))
    (GF.empty, []) decl_list

let find_relevant b deps q = 
  let rec find b deps q vus acc =
    try
      let step , get = 
	if b then GF.fold_succ_e , GF.E.dst else GF.fold_pred_e , GF.E.src in
      let v, d = Queue.pop q in
	if d <= 0 then acc 
	else
	  let acc' =
	    try
	      let prevd = d-1 in
	      if SetHS.mem v vus then acc else
		step (fun e acc -> Queue.push (get e, prevd) q; 
			SetS.add (GF.E.label e) acc)  deps v acc
	    with Invalid_argument _ -> acc
	  in
	    find b deps q (SetHS.add v vus) acc'
    with Queue.Empty -> acc
  in
    find b deps q SetHS.empty SetS.empty

let rouge = 0x990000
let vert = 0x009900
let bleu = 0x000099
let jaune = 0x999900

let prune_goal depth s f g =
  let spos , sneg = ref SetH.empty , ref SetH.empty in
  let add p c s = 
    if c then
      begin
	match p with
	    Polarite.Plus -> spos := SetH.add s !spos 
	  | Polarite.Moins -> sneg := SetH.add s !sneg 
	  | Polarite.Neutre -> 
	      spos := SetH.add s !spos; sneg := SetH.add s !sneg 
      end
  in
  symbs_in_formula add (fun _ _ _ -> ()) f;
  let spos , sneg = !spos , !sneg in
  vertex_attrs :=
    (fun v -> 
       match v with 
	 | HS.STrue -> [`Fillcolor vert]
	 | HS.SFalse -> [`Fillcolor jaune]
	 | HS.H s -> (match SetH.mem s spos, SetH.mem s sneg with
			  | true, true -> [`Fillcolor jaune]
			  | false, true -> [`Fillcolor rouge]
			  | true, false -> [`Fillcolor vert]
			  | false, false -> []));
    let qin, qout = Queue.create (), Queue.create () in
      SetH.iter (fun s -> Queue.push (HS.H s, depth) qin) sneg; 
      SetH.iter (fun s -> Queue.push (HS.H s, depth) qout) spos;
      Queue.push (HS.SFalse, depth) qin; 
      Queue.push (HS.SFalse, depth) qout; 
      Queue.push (HS.STrue, depth) qout;
      SetS.union (find_relevant true g qin)
	(find_relevant false g qout)
      
let print_flag = true

let split_and_prune depth decl_list = 
  let deps, goals = analyze_deps decl_list in
  match goals with 
      [] -> [List.map (fun f -> f,true) decl_list]
    | _ ->
	List.map
	  (fun (s,f) ->
	     let df = prune_goal depth s f deps in
	     graph_attrs := (fun g -> [`Label ("Goal: "^s)]);
	     edge_attrs := 
	       (fun e -> if SetS.mem (GF.E.label e) df then 
		  [`Fontcolor bleu; `Color bleu] else []);
	     if print_flag then 
	       begin
		 print_graph deps;
		 Printf.printf "Goal %s:\n" s;
		 SetS.iter (fun s -> Printf.printf "\t %s\n" s) df; 
		 flush stdout;
	       end;
	     List.fold_right
	       (fun f acc -> match f.c with
		  | TAxiom(_, s',{c=TFforall {qf_bvars=_::_}}) -> 
		      if SetS.mem s' df then (f,true)::acc else acc
		  | TAxiom(loc,s',f') -> 
		      if SetS.mem s' df then (f,true)::acc
		      else 
			let f = { c = TAxiom(loc,s',f'); annot = f.annot} in
			(f,false)::acc
		  | TGoal (_,s',_) -> if s = s' then (f,true)::acc else acc
		  | _ -> (f,true)::acc) decl_list [])
	  goals

end
include (IMPLEMENTATION : INTERFACE)
end
and Triggers: sig
#0 "triggers.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

(* make b f computes the triggers for a formula f 
   if b is true then variables are authorized in mutli-triggers *)
val make : bool -> (int tform, int) annoted -> (int tform, int) annoted

end = struct
let _ = Printf.fprintf stderr "Executing triggers.ml\n%!"module type INTERFACE = sig
#0 "triggers.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

(* make b f computes the triggers for a formula f 
   if b is true then variables are authorized in mutli-triggers *)
val make : bool -> (int tform, int) annoted -> (int tform, int) annoted

end
module IMPLEMENTATION = struct
#0 "triggers.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)


open Options
open Format
open Why_ptree

module Vterm = Symbols.Set
module Vtype = Set.Make(struct type t=int let compare=Pervasives.compare end)

module STRS = Set.Make(
  struct
    type t = (int tterm, int) annoted * Vterm.t * Vtype.t

    let rec compare_term t1 t2 = match t1.c.tt_desc, t2.c.tt_desc with
      | TTvar s1 , TTvar s2 -> Symbols.compare s1 s2
      | TTapp (s1,l1) , TTapp(s2,l2) ->
	  let c = Symbols.compare s1 s2 in
	  if c=0 then compare_list l1 l2 else c
      | TTinfix(a1,s1,b1) , TTinfix(a2,s2,b2) ->
	  let c = Symbols.compare s1 s2 in
	  if c=0 then 
	    let c=compare_term a1 a2 in if c=0 then compare_term b1 b2 else c
	  else c
      | x , y -> Pervasives.compare x y
    and compare_list l1 l2 = match l1,l2 with
	[] , _ -> -1
      | _ , [] -> 1
      | x::l1 , y::l2 -> 
	  let c = compare x y in if c=0 then compare_list l1 l2 else c

    let compare (t1,_,_) (t2,_,_) = compare_term t1 t2
  end)

let sort = 
  List.sort (fun l1 l2 -> compare (List.length l1) (List.length l2) )
      
let compare_tconstant c1 c2 =
  match c1, c2 with
    | Tint s1, Tint s2 -> String.compare s1 s2
    | Tint s1, _ -> 1
    | _, Tint s1 -> -1
    | Treal s1, Treal s2 -> Num.compare_num s1 s2
    | Treal s1, _ -> 1
    | _, Treal s2 -> -1
    | Tbitv s1, Tbitv s2 -> String.compare s1 s2
    | Tbitv s1, _ -> 1
    | _, Tbitv s2 -> -1
    | _ -> Pervasives.compare c1 c2

let rec depth_tterm t =
  match t.c.tt_desc with
    | TTconst _ | TTvar _->  0
    | TTapp (_, tl) ->
	1 + (List.fold_left
	       (fun acc t -> max (depth_tterm t) acc) 0 tl)
    | TTinfix _ | TTprefix _ -> 
	0 (* arithmetic triggers are not suitable *)
    | TTget (t1, t2) | TTconcat (t1, t2) ->
	max (depth_tterm t1) (depth_tterm t2)
    | TTset (t1, t2, t3) | TTextract (t1, t2, t3) ->
	max (depth_tterm t1) (max (depth_tterm t2) (depth_tterm t3))
    | TTlet (s, t1, t2) ->
	max (depth_tterm t1 + 1) (depth_tterm t2)

exception Out of int

  (* pourquoi cette fonction de comparaison est-elle si compliquee? *)
let rec compare_tterm t1 t2 =
  match t1.c.tt_desc, t2.c.tt_desc with
    | TTconst c1, TTconst c2 -> compare_tconstant c1 c2
    | TTconst _, _ -> -1
    | _, TTconst _ -> 1
    | TTvar v1, TTvar v2 -> Symbols.compare v1 v2
    | TTvar _, _ -> -1
    | _, TTvar _ -> 1
    | TTinfix (tu1, s, tu2), TTinfix (tu1', s', tu2') ->
	let c = (depth_tterm t1) - (depth_tterm t2) in
	if c <> 0 then c
	else let c = Symbols.compare s s' in
	if c <> 0 then c
	else let c = compare_tterm tu1 tu1' in
	if c <> 0 then c
	else compare_tterm tu2 tu2'
    | TTinfix _, _ -> -1
    | _, TTinfix _ -> 1
    | TTprefix (s1, t1), TTprefix (s2, t2) ->
	let c = Symbols.compare s1 s2 in
	if c<>0 then c else compare_tterm t1 t2
    | TTprefix _, _ -> -1
    | _, TTprefix _ -> 1
    | TTapp (s1, tl1), TTapp (s2, tl2) ->
	let l1 = List.map depth_tterm tl1 in
	let l2 = List.map depth_tterm tl2 in
	let l1 = List.fast_sort compare l1 in
	let l2 = List.fast_sort compare l2 in
	let c = try
	  List.iter2
	    (fun n m -> 
	       if n <> m then raise (Out (n-m))
	    ) l1 l2; 0
	with 
	  | Out c -> c 
	  | _ -> (List.length l1) - (List.length l2) in
	if c <> 0 then c
	else let c = Symbols.compare s1 s2 in
	if c <> 0 then c
	else begin try
	  List.iter2
	    (fun t1 t2 ->
	       let c = compare_tterm t1 t2 in
	       if c <> 0 then raise (Out c)
	    ) tl1 tl2; 0 
	with Out c -> c end
    | TTapp _, _ -> -1
    | _, TTapp _ -> 1
    | TTget (t1, t2), TTget (u1, u2) ->
	let c = compare_tterm t1 u1 in
	if c<>0 then c else compare_tterm t2 u2
    | TTget _, _ -> -1
    | _, TTget _ -> 1
    | TTset(t1, t2, t3) , TTset(u1, u2, u3) ->
	let c = compare_tterm t1 u1 in
	if c<>0 then c else
	  let c = compare_tterm t2 u2 in
	  if c<>0 then c else compare_tterm t3 u3
    | TTset _, _ -> -1
    | _, TTset _ -> 1
    | TTextract(t1, t2, t3) , TTextract(u1, u2, u3) ->
	let c = compare_tterm t1 u1 in
	if c<>0 then c else
	  let c = compare_tterm t2 u2 in
	  if c<>0 then c else compare_tterm t3 u3
    | TTextract _, _ -> -1
    | _, TTextract _ -> 1
    | TTconcat (t1, t2), TTconcat (u1, u2) ->
	let c = compare_tterm t1 u1 in
	if c<>0 then c else compare_tterm t2 u2
    | TTconcat _, _ -> -1
    | _, TTconcat _ -> 1
    | TTlet (s1, t1, u1) , TTlet (s2, t2, u2) ->
	let c = Symbols.compare s1 s2 in
	if c<>0 then c else
	  let c = compare_tterm t1 u1 in
	  if c<>0 then c else compare_tterm u1 u2

let compare_tterm_list tl2 tl1 =
  let l1 = List.map depth_tterm tl1 in
  let l2 = List.map depth_tterm tl2 in
  let l1 = List.rev (List.fast_sort compare l1) in
  let l2 = List.rev (List.fast_sort compare l2) in
  let c = try
    List.iter2
      (fun n m -> 
	 if n <> m then raise (Out (n-m))
      ) l1 l2; 0
  with 
    | Out c -> c 
    | _ -> (List.length l2) - (List.length l1) in
  if c <> 0 then c
  else begin try
    List.iter2
      (fun t1 t2 ->
	 let c = compare_tterm t1 t2 in
	 if c <> 0 then raise (Out c)
      ) tl1 tl2; 0 
  with Out c -> c end
    

let at_most n l =
  let l = List.fast_sort compare_tterm_list l in
  let rec atmost acc n l = 
    match n, l with
      | n, _ when n <= 0 -> acc
      | _ , [] -> acc
      | n, x::l -> 
          if List.mem x acc then atmost acc n l
          else atmost (x::acc) (n-1) l
  in
  List.rev (atmost [] n l)

let is_var t = match t.c.tt_desc with
  | TTvar _ -> true
  | TTapp (_,l) -> l=[]
  | _ -> false

module SLLT = 
  Set.Make(
    struct 
      type t = (int tterm, int) annoted list * Vterm.t * Vtype.t
      let compare (_, y1, _) (_, y2, _)  = 
	Vterm.compare y1 y2
    end)

let parties bv vty l = 
  let rec parties_rec (llt, llt_ok)  l = 
    match l with 
	[] -> llt_ok
      | (t, bv1, vty1)::l -> 
	  let llt, llt_ok = 
	    SLLT.fold
	      (fun (l, bv2, vty2) (llt, llt_ok) ->
		 let lt, bv3, vty3 = 
		   t::l, Vterm.union bv2 bv1, Vtype.union vty2 vty1 
		 in 
		 let e = (lt, bv3, vty3) in
		 if Vterm.subset bv bv3 && Vtype.subset vty vty3 then
		   llt, SLLT.add e llt_ok
		 else 
		   SLLT.add e llt, llt_ok) 
	      llt (llt, llt_ok)
	  in
	  parties_rec (SLLT.add ([t],bv1,vty1) llt, llt_ok) l
  in 
  SLLT.elements (parties_rec (SLLT.empty, SLLT.empty) l)
	 
let strict_subset bv vty = 
  List.exists 
    (fun (_,bv',vty') -> 
       (Vterm.subset bv bv' && not(Vterm.equal bv bv')  
	&& Vtype.subset vty vty') 
       or (Vtype.subset vty vty' && not(Vtype.equal vty vty') 
	   && Vterm.subset bv bv') )

let simplification bv_a vty_a = 
  let rec simpl_rec acc = function
    | [] -> acc
    | ((t, bv, vty) as e)::l -> 
	if strict_subset bv vty l or strict_subset bv vty acc or
	  (Vterm.subset bv_a bv && Vtype.subset vty_a vty) or
	  (Vterm.equal (Vterm.inter bv_a bv) Vterm.empty &&
	     Vtype.equal (Vtype.inter vty_a vty) Vtype.empty)
	then simpl_rec acc l
	else  simpl_rec (e::acc) l
  in simpl_rec []

let rec vars_of_term bv acc t = match t.c.tt_desc with
  | TTvar x -> if Vterm.mem x bv then Vterm.add x acc else acc
  | TTapp (_,lt) -> List.fold_left (vars_of_term bv) acc lt
  | TTinfix (t1,_,t2) -> List.fold_left (vars_of_term bv) acc [t1;t2]
  | TTset (t1, t2, t3) -> List.fold_left (vars_of_term bv) acc [t1;t2;t3]
  | TTget (t1, t2) -> List.fold_left (vars_of_term bv) acc [t1;t2]
  | TTlet (_, t1, t2) -> List.fold_left (vars_of_term bv) acc [t1;t2]
  (* XXX TTlet ? *)
  | _ -> acc

let underscoring_term mvars underscores t = 
  let rec under_rec t =  
    { t with c={ t.c with tt_desc = under_rec_desc t.c.tt_desc}}
  and under_rec_desc t = match t with
    | TTvar x when Vterm.mem x mvars -> 
	if not (Vterm.mem x !underscores) then 
	  (	underscores := Vterm.add x !underscores; t)
	else 
	  TTvar (Symbols.underscoring x)
    | TTvar _ -> t
    | TTapp (s,lt) -> TTapp(s,List.map under_rec lt)
    | TTinfix (t1,op,t2) -> TTinfix(under_rec t1,op,under_rec t2)
       (* XXX TTlet ? *)
    | _ -> t
  in 
  under_rec t

let underscoring_mt bv mt = 
  let vars , mvars = 
    List.fold_left 
      (fun (vars,mvars) t -> 
	 let vs = vars_of_term bv Vterm.empty t in
	 let mvars = Vterm.union mvars (Vterm.inter vars vs) in
	 Vterm.union vars vs , mvars) (Vterm.empty,Vterm.empty) mt in
  let underscores = ref Vterm.empty in
  List.map (underscoring_term mvars underscores) mt
    
let multi_triggers gopt bv vty trs =
  let terms = simplification bv vty trs in
  let l_parties = parties bv vty terms  in 
  let lm = List.map (fun (lt,_,_) -> lt) l_parties in
(*    List.fold_left 
      (fun acc (lt, bv', vty') ->
	 if Vterm.subset bv bv' && Vtype.subset vty vty' then lt::acc else acc) 
      [] l_parties*)
  let mv , mt = List.partition (List.exists is_var) lm in
  let mv , mt = sort mv , sort mt in
  let lm = if gopt || triggers_var then mt@mv else mt in
  let m = at_most redondance  lm in
  (*(List.map (underscoring_mt bv) m)@
    (List.map (underscoring_mt bv) (List.map List.rev m))*)
  at_most redondance m 

let rec vty_ty acc t = 
  let t = Ty.shorten t in
  match t with
    | Ty.Tvar { Ty.v = i ; value = None } -> Vtype.add i acc 
    | Ty.Text(l,_) -> List.fold_left vty_ty acc l
    | Ty.Tfarray (t1,t2) -> vty_ty (vty_ty acc t1) t2
    | _ -> acc
    
let rec vty_term acc t = 
  let acc = vty_ty acc t.c.tt_ty in
  match t.c.tt_desc with
    | TTapp (_,l) -> List.fold_left vty_term acc l
    | TTinfix (t1,_,t2) -> vty_term (vty_term acc t1) t2
    | TTset (t1, t2, t3) -> List.fold_left vty_term acc [t1;t2;t3]
    | TTget (t1, t2) -> List.fold_left vty_term acc [t1;t2]
    | TTlet (_, t1, t2) -> List.fold_left vty_term acc [t1;t2]
    | _ -> acc

let rec vty_form acc f = match f.c with
  | TFatom {c=(TAeq l | TAneq l | TAdistinct l 
	       | TAle l | TAlt l | TAbuilt(_,l))}-> 
      List.fold_left vty_term acc l
  | TFatom {c=TApred t} -> vty_term acc t
  | TFop(_,l) -> List.fold_left vty_form acc l
  | TFforall qf | TFexists qf ->
      let acc = 
	List.fold_left (fun acc (_, ty) -> vty_ty acc ty) acc qf.qf_bvars in
      vty_form acc qf.qf_form
  | TFnamed (_, f) -> vty_form acc f
  | TFlet (ls, s, e, f') -> 
      vty_form (vty_term acc e) f'
  | _ -> acc

let csort = Symbols.name "c_sort"

let filter_mono vterm vtype (t, bv_t, vty_t) = 
  Vterm.subset vterm bv_t && Vtype.subset vtype vty_t && 
    match t.c.tt_desc with
      | TTapp(s,_) -> 
	  not (Symbols.equal s csort)
      | _ -> true
	    

let as_bv bv s = not (Vterm.is_empty (Vterm.inter bv s))
let as_tyv vty s = not (Vtype.is_empty (Vtype.inter vty s))

let potential_triggers = 
  let rec potential_rec ((bv,vty) as vars) acc t = 
    let vty_t = vty_term Vtype.empty t in
    match t.c.tt_desc with
      | TTvar x ->
	  if Vterm.mem x bv or as_tyv vty vty_t then
	    STRS.add (t,Vterm.singleton x, vty_t) acc
	  else acc
      | TTapp(s,lf)-> 
	  let vty_lf = List.fold_left vty_term vty_t lf in
	  let bv_lf = List.fold_left (vars_of_term bv) Vterm.empty lf in
	  if as_bv bv bv_lf or as_tyv vty vty_lf then
	    List.fold_left (potential_rec vars) 
	      (STRS.add (t,bv_lf,vty_lf) acc) lf
	  else acc
      | TTinfix(t1,_,t2) | TTlet (_, t1, t2) -> (* XXX TTlet ? *)
	  let vty_lf = List.fold_left vty_term vty_t [t1;t2] in
	  let bv_lf = List.fold_left (vars_of_term bv) Vterm.empty [t1;t2] in
	  if as_bv bv bv_lf or as_tyv vty vty_lf then
	    List.fold_left (potential_rec vars) 
	      (STRS.add (t,bv_lf,vty_lf) acc) (*acc*) [t1;t2]
	  else acc
      | TTset (t1, t2, t3) ->
	  let vty_lf = List.fold_left vty_term vty_t [t1;t2;t3] in
	  let bv_lf = List.fold_left (vars_of_term bv) Vterm.empty [t1;t2;t3] in
	  if as_bv bv bv_lf or as_tyv vty vty_lf then
	    List.fold_left (potential_rec vars) 
	      (STRS.add (t,bv_lf,vty_lf) acc) (*acc*) [t1;t2;t3]
	  else acc
	    
      | TTget (t1, t2) ->
	  let vty_lf = List.fold_left vty_term vty_t [t1;t2] in
	  let bv_lf = List.fold_left (vars_of_term bv) Vterm.empty [t1;t2] in
	  if as_bv bv bv_lf or as_tyv vty vty_lf then
	    List.fold_left (potential_rec vars) 
	      (STRS.add (t,bv_lf,vty_lf) acc) (*acc*) [t1;t2]
	  else acc

      | _ -> acc

  in fun vars -> List.fold_left (potential_rec vars) STRS.empty

let filter_good_triggers (bv,vty) = 
  List.filter 
    (fun l ->
       let s1 = List.fold_left (vars_of_term bv) Vterm.empty l in
       let s2 = List.fold_left vty_term Vtype.empty l in
       Vterm.subset bv s1 && Vtype.subset vty s2 )

let make_triggers gopt vterm vtype trs = 
  match List.filter (filter_mono vterm vtype) trs with
      [] -> 
	multi_triggers gopt vterm vtype trs
    | trs' -> 
	let f l = at_most redondance (List.map (fun (t,_,_) -> [t]) l) in
	let trs_v, trs_nv = 
	  List.partition (fun (t,_,_) -> is_var t) trs' in
	let ll = 
	  if trs_nv=[] then
	    if triggers_var || gopt then 
	      f trs_v 
	    else [](*multi_triggers vars trs*)
	  else f trs_nv 
	in 
	if glouton then ll@(multi_triggers gopt vterm vtype trs) else ll

let rec make_rec gopt vterm vtype f = 
  let c, trs = match f.c with
    | TFatom {c=(TAfalse | TAtrue)} ->
      f.c, STRS.empty
    | TFatom a ->
      if Vterm.is_empty vterm && Vtype.is_empty vtype then 
	f.c, STRS.empty
      else 
	let l = match a.c with    
	  | TAeq l | TAneq l | TAle l | TAlt l | TAbuilt(_,l) -> l
	  | TApred t -> [t]
	  | _ -> assert false
	in
	f.c, potential_triggers (vterm, vtype) l
    | TFop(op, lf) -> 
      let lf, trs = 
	List.fold_left
	  (fun (lf, trs1) f ->
	    let f, trs2 = make_rec gopt vterm vtype f in
	    f::lf, STRS.union trs1 trs2) ([], STRS.empty) lf in
      TFop(op,List.rev lf), trs

    | TFforall ({ qf_form= {c = TFop(OPiff,[{c=TFatom _} as f1;f2]); 
			    annot = ido}} as qf) -> 
      let vtype' = vty_form Vtype.empty qf.qf_form in
      let vterm' = 
	List.fold_left (fun b (s,_) -> Vterm.add s b) Vterm.empty qf.qf_bvars 
      in

      let vterm'' = Vterm.union vterm vterm' in
      let vtype'' = Vtype.union vtype vtype' in
      let f1', trs1 = make_rec gopt vterm'' vtype'' f1 in
      let f2', trs2 = make_rec gopt vterm'' vtype'' f2 in
      let trs12 = 
	if Options.notriggers || qf.qf_triggers = [] then
	  begin
	    (make_triggers false vterm' vtype' (STRS.elements trs1))@
	      (make_triggers false vterm' vtype' (STRS.elements trs2))
	  end
	else 
	  begin
	    let lf = filter_good_triggers (vterm', vtype') qf.qf_triggers in
	    if lf<>[] then lf
	    else
	      (make_triggers false vterm' vtype' (STRS.elements trs1))@
		(make_triggers false vterm' vtype' (STRS.elements trs2))
	  end
      in
      let trs = 
	STRS.filter 
	  (fun (_, bvt, _) -> Vterm.is_empty (Vterm.inter bvt vterm')) 
	  (STRS.union trs1 trs2) in
      let r  = 
	{ qf with 
	  qf_triggers = trs12 ; 
	  qf_form = {c=TFop(OPiff,[f1'; f2']); annot = ido} }
      in
      begin
	match f.c with 
	  | TFforall _ -> TFforall r, trs 
	  | _ -> TFexists r , trs
      end

  | TFforall qf | TFexists qf -> 
      let vtype' = vty_form Vtype.empty qf.qf_form in
      let vterm' = 
	List.fold_left (fun b (s,_) -> Vterm.add s b) Vterm.empty qf.qf_bvars in
      let f', trs = 
	make_rec gopt 
	  (Vterm.union vterm vterm') (Vtype.union vtype vtype') qf.qf_form in
      let trs' = 
	if Options.notriggers || qf.qf_triggers=[] then
	  make_triggers gopt vterm' vtype' (STRS.elements trs)
	else 
	  let lf = filter_good_triggers (vterm',vtype') qf.qf_triggers in
	  if lf <> [] then lf
	  else make_triggers gopt vterm' vtype' (STRS.elements trs)
      in
      let trs = 
	STRS.filter 
	  (fun (_,bvt,_) -> Vterm.is_empty (Vterm.inter bvt vterm')) trs in
      let r  = {qf with qf_triggers = trs' ; qf_form = f'} in
      (match f.c with 
	| TFforall _ -> TFforall r , trs 
	| _ -> TFexists r , trs)

  | TFlet (up, v, t, f) ->
      let f, trs = make_rec gopt vterm vtype f in 
      let trs = STRS.union trs (potential_triggers (vterm, vtype) [t]) in
       (* XXX correct for terms *)
      TFlet (up, v, t, f), trs

  | TFnamed(lbl, f) -> 
      let f, trs = make_rec gopt vterm vtype f in
      TFnamed(lbl, f), trs
  in
  { f with c = c }, trs
	  
let make gopt f = match f.c with
  | TFforall _ | TFexists _ -> 
      let f, _ = make_rec gopt Vterm.empty Vtype.empty f in
      f
  | _  ->  
      let vty = vty_form Vtype.empty f in
      let f, trs = make_rec gopt Vterm.empty vty f in
      if Vtype.is_empty vty then f
      else 
	let trs = STRS.elements trs in
	let trs = make_triggers gopt Vterm.empty vty trs in
	{ f with c = TFforall 
	  {qf_bvars=[]; qf_upvars=[]; qf_triggers=trs; qf_form=f }}

end
include (IMPLEMENTATION : INTERFACE)
end
and Cnf: sig
#0 "cnf.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

val make : ((int tdecl, int) annoted * bool) list -> sat_tdecl Queue.t
end = struct
let _ = Printf.fprintf stderr "Executing cnf.ml\n%!"module type INTERFACE = sig
#0 "cnf.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

val make : ((int tdecl, int) annoted * bool) list -> sat_tdecl Queue.t
end
module IMPLEMENTATION = struct
#0 "cnf.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Options
open Format
open Why_ptree

module T = Term
module F = Formula
module A = Literal

let queue = Queue.create ()

let clear () = Queue.clear queue

let varset_of_list = 
  List.fold_left 
    (fun acc (s,ty) -> 
       Term.Set.add (Term.make s [] (Ty.shorten ty)) acc) Term.Set.empty

let rec make_term {c = { tt_ty = ty; tt_desc = tt }} = 
  let ty = Ty.shorten ty in
  match tt with
    | TTconst Ttrue -> 
	T.vrai
    | TTconst Tfalse -> 
	T.faux
   | TTconst Tvoid -> 
	T.void
    | TTconst (Tint i) -> 
	T.int i
    | TTconst (Treal n) -> 
	T.real (Num.string_of_num n)
    | TTconst (Tbitv bt) -> 
	T.bitv bt ty
    | TTvar s ->  
	T.make s [] ty 
    | TTapp (s, l) -> 
	T.make s (List.map make_term l) ty
    | TTinfix (t1, s, t2) ->  
	T.make s [make_term t1;make_term t2] ty
    | TTprefix ((Symbols.Op Symbols.Minus) as s, n) ->
	let t1 = if ty = Ty.Tint then T.int "0" else T.real "0"  in
	T.make s [t1; make_term n] ty
    | TTprefix _ -> 
	assert false
    | TTget (t1, t2) ->
	T.make (Symbols.Op Symbols.Get) [make_term t1; make_term t2] ty
    | TTset (t1, t2, t3) ->
	let t1 = make_term t1 in
	let t2 = make_term t2 in
	let t3 = make_term t3 in
	T.make (Symbols.Op Symbols.Set) [t1; t2; t3] ty
    | TTextract (t1, t2, t3) ->
	let t1 = make_term t1 in
	let t2 = make_term t2 in
	let t3 = make_term t3 in
	T.make (Symbols.Op Symbols.Extract) [t1; t2; t3] ty
    | TTconcat (t1, t2) ->
	T.make (Symbols.Op Symbols.Concat) [make_term t1; make_term t2] ty
    | TTlet (s, t1, t2) ->
	let t1 = make_term t1 in
	let subst = Symbols.Map.add s t1 Symbols.Map.empty, Ty.esubst in
	let t2 = make_term t2 in
	T.apply_subst subst t2


let make_form name f = 
  let rec make_form acc c id = match c with
    | TFatom a ->
	let a , lit = match a.c with
	  | TAtrue -> 
	      A.LT.vrai , A.LT.vrai::acc
	  | TAfalse -> 
	      A.LT.faux , A.LT.faux::acc
	  | TAeq [t1;t2] -> 
	      let lit = A.LT.make (A.Eq (make_term t1, make_term t2)) in
	      lit , lit::acc
	  | TApred t ->
	      let lit = A.LT.mk_pred (make_term t) in
	      lit , lit::acc
	  | TAneq lt | TAdistinct lt -> 
	      let lt = List.map make_term lt in
	      let lit = A.LT.make (A.Distinct (false, lt)) in
	      lit , lit::acc
	  | TAle [t1;t2] -> 
	      (try 
		 let ale = Builtin.is_builtin "<=" in
		 let lit = 
		   A.LT.make (A.Builtin(true,ale,[make_term t1;make_term t2]))
		 in lit , lit::acc
	       with Not_found -> assert false)
	  | TAlt [t1;t2] ->  
	      (try 
		 let alt = Builtin.is_builtin "<" in
		 let lit = 
		   A.LT.make (A.Builtin(true,alt,[make_term t1;make_term t2])) 
		 in lit , lit::acc
	       with Not_found -> assert false)
	  | TAbuilt(n,lt) ->
	      let lit = A.LT.make (A.Builtin(true,n,List.map make_term lt)) in
	      lit , lit::acc
	  | _ -> assert false
	in F.mk_lit a id, lit

    | TFop(((OPand | OPor) as op),[f1;f2]) -> 
	let ff1 , lit1 = make_form acc f1.c f1.annot in
	let ff2 , lit2 = make_form lit1 f2.c f2.annot in
	let mkop = match op with 
	  | OPand -> F.mk_and ff1 ff2 id
	  | _ -> F.mk_or ff1 ff2 id in
	mkop , lit2
    | TFop(OPimp,[f1;f2]) -> 
	let ff1 , _ = make_form acc f1.c f1.annot in
	let ff2 , lit = make_form acc f2.c f2.annot in
	F.mk_imp ff1 ff2 id, lit
    | TFop(OPnot,[f]) -> 
	let ff , lit = make_form acc f.c f.annot in
	F.mk_not ff , lit
    | TFop(OPif t,[f2;f3]) -> 
	let tt = make_term t in
	let ff2 , lit2 = make_form acc f2.c f2.annot in
	let ff3 , lit3 = make_form lit2 f3.c f3.annot in
	F.mk_if tt ff2 ff3 id, lit3
    | TFop(OPiff,[f1;f2]) -> 
	let ff1 , lit1 = make_form acc f1.c f1.annot in
	let ff2 , lit2 = make_form lit1 f2.c f2.annot in
	F.mk_iff ff1 ff2 id, lit2
    | (TFforall qf | TFexists qf) as f -> 
	let bvars = varset_of_list qf.qf_bvars in
	let upvars = varset_of_list qf.qf_upvars in
	let trs = List.map (List.map make_term) qf.qf_triggers in
	let ff , lit = make_form acc qf.qf_form.c qf.qf_form.annot in
	begin match f with
	  | TFforall _ -> F.mk_forall upvars bvars trs ff name id, lit
	  | TFexists _ -> F.mk_exists upvars bvars trs ff name id, lit
	  | _ -> assert false
	end
    | TFlet(up,lvar,lterm,lf) -> 
	let ff, lit = make_form acc lf.c lf.annot in
        F.mk_let (varset_of_list up) lvar (make_term lterm) ff id, lit

    | TFnamed(lbl, f) ->
	let ff, lit = make_form acc f.c f.annot in
	F.add_label lbl ff; 
	ff, lit

    | _ -> assert false
  in
  make_form [] f.c f.annot

let push_assume f name loc match_flag = 
  let ff , _ = make_form name f in
  Queue.push {st_decl=Assume(ff, match_flag) ; st_loc=loc} queue

let push_preddef f name loc match_flag = 
  let ff , _ = make_form name f in
  Queue.push {st_decl=PredDef ff ; st_loc=loc} queue
      
let push_query n f loc = 
  let ff, lits = make_form "" f in
  Queue.push {st_decl=Query(n,ff,lits) ; st_loc=loc} queue

let make_rule ({rwt_left = t1; rwt_right = t2} as r) = 
  { r with rwt_left = make_term t1; rwt_right = make_term t2 }

let make l = 
  (*  Decl.clear ();
      Logics.clear();
      Types.clear();*)
  clear();
  List.iter
    (fun (d,b) -> match d.c with
       | TAxiom(loc, name, f) -> push_assume f name loc b
       | TRewriting(loc, name, lr) -> 
	   Queue.push 
	     {st_decl=RwtDef(List.map make_rule lr); st_loc=loc} queue
       | TGoal(loc, n, f) -> push_query n f loc
       | TPredicate_def(loc, n, [], f) -> push_assume f n loc b
       | TPredicate_def(loc, n, _, f) -> push_preddef f n loc b
       | TFunction_def(loc, n, _, _, f) -> push_assume f n loc b
       | TTypeDecl _ | TLogic _  -> ()) l;
  queue
end
include (IMPLEMENTATION : INTERFACE)
end
and Why_typing: sig
#0 "why_typing.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

type env

val file : file -> ((int tdecl, int) annoted * env) list 

val split_goals : 
  ((int tdecl, int) annoted * env) list -> 
  ((int tdecl, int) annoted * env) list list

val term : env -> (Symbols.t * Ty.t) list -> Why_ptree.lexpr -> 
  (int tterm, int) annoted

val new_id : unit -> int
end = struct
let _ = Printf.fprintf stderr "Executing why_typing.ml\n%!"module type INTERFACE = sig
#0 "why_typing.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

type env

val file : file -> ((int tdecl, int) annoted * env) list 

val split_goals : 
  ((int tdecl, int) annoted * env) list -> 
  ((int tdecl, int) annoted * env) list list

val term : env -> (Symbols.t * Ty.t) list -> Why_ptree.lexpr -> 
  (int tterm, int) annoted

val new_id : unit -> int
end
module IMPLEMENTATION = struct
#0 "why_typing.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Options
open Format
open Why_ptree
open Common

module M = Map.Make(String)
module S = Set.Make(String)
module Sy = Symbols.Set

module MString = 
  Map.Make(struct type t = string let compare = Pervasives.compare end)

module Types = struct

  type t = (int * string list) MString.t

  let empty = MString.empty

  let bad_arity =
    let rec check s = function
      | [] -> false
      | v :: l -> S.mem v s || check (S.add v s) l
    in
    check S.empty
      
  let add env v id lc loc = 
    if MString.mem id env then error (ClashType id) loc;
    if bad_arity v then error TypeBadArityDecl loc;
    MString.add id (List.length v, lc) env
      
  let valid env v s loc = try
    let (n, lc) = MString.find s env in
    if List.length v <> n  then error (WrongArity(s,n)) loc; 
    lc
  with Not_found -> error (UnknownType s) loc
    
end

module Profile = struct

  type t = Ty.t list * Ty.t

  let of_logictype env p = 
    let htbl = Hashtbl.create 17 in
    let rec of_puretype = function
      | PPTint -> Ty.Tint
      | PPTbool -> Ty.Tbool
      | PPTreal -> Ty.Treal
      | PPTunit -> Ty.Tunit
      | PPTbitv n -> Ty.Tbitv n
      | PPTvarid (s, _) -> 
	  begin
	    try Ty.Tvar(Hashtbl.find htbl s)
	    with Not_found-> 
	      let nv = Ty.fresh_var () in
	      Hashtbl.add htbl s nv;
	      Ty.Tvar nv
	  end
      | PPTexternal (l, s, loc) when s = "farray" ->
        begin match l with
          | [t2] -> Ty.Tfarray (Ty.Tint,of_puretype t2)
          | [t1;t2] -> Ty.Tfarray (of_puretype t1,of_puretype t2)
          | _ -> error (WrongArity(s,2)) loc end
      | PPTexternal (l, s, loc) ->
	  let lc = Types.valid env l s loc in
	  if lc = [] then
	    Ty.text (List.map of_puretype l) s
	  else
	    Ty.tsum s lc
    in
    match p with
	PPredicate l -> List.map of_puretype l , Ty.Tbool
      | PFunction([],PPTvarid(_,loc)) -> 
	  error CannotGeneralize loc
      | PFunction(l,t) -> List.map of_puretype l , of_puretype t

  (* create fresh type variables each time it is called *)
  let fresh (l,ty) = 
    let hvars = Hashtbl.create 17 in
    let rec freshrec = function
      | Ty.Tvar {Ty.v=x} -> 
	  (try Ty.Tvar(Hashtbl.find hvars x) 
	   with Not_found -> 
	     let nv = Ty.fresh_var() in 
	     Hashtbl.add hvars x nv; Ty.Tvar nv)
      | Ty.Text(l,s) -> Ty.Text(List.map freshrec l,s)
      | Ty.Tfarray(t1,t2) -> Ty.Tfarray(freshrec t1,freshrec t2)
      | t -> t
    in
    List.map (fun t->freshrec (Ty.shorten t)) l , freshrec (Ty.shorten ty)

end

module Logics = struct

  type t = (Symbols.t * Profile.t) MString.t

  let empty = MString.empty 

  let add env pf loc name_kind n = 
    let sy = Symbols.name n ~kind:name_kind in
    if MString.mem n env then error (SymbAlreadyDefined n) loc;
    MString.add n (sy,pf) env

  let fresh env n loc = try
      let s, ty = MString.find n env in 
      s, Profile.fresh ty
  with Not_found -> error (SymbUndefined n) loc

end
    
module Env = struct

  type t = { 
    var_map : (Symbols.t * Ty.t) M.t ; (* variables' map*)
    tvar_map : Ty.t M.t ; (* typed variables' map *)
    types_map : Types.t ; 
    logics_map : Logics.t
  }

  let empty = { 
    var_map = M.empty;  
    tvar_map = M.empty;
    types_map = Types.empty;
    logics_map = Logics.empty
  }

  let rec of_puretype env create_var ty = 
    match ty with
      | PPTint -> Ty.Tint, env
      | PPTbool -> Ty.Tbool, env
      | PPTunit -> Ty.Tunit, env
      | PPTreal -> Ty.Treal, env
      | PPTbitv n -> Ty.Tbitv n, env
      | PPTvarid (s, _) -> 
	  begin
	    try M.find s env.tvar_map, env
	    with Not_found-> 
	      let nv =  create_var() in 
	      nv, { env with tvar_map = M.add s nv env.tvar_map } 
	  end
      | PPTexternal (l, s, loc) when s = "farray" ->
        let t1,t2 = match l with
          | [t2] -> PPTint,t2
          | [t1;t2] -> t1,t2
          | _ -> error (WrongArity(s,2)) loc in
	  let ty1, env = of_puretype env create_var t1 in
          let ty2, env = of_puretype env create_var t2 in
	  Ty.Tfarray (ty1,ty2), env
      | PPTexternal (l, s, loc) ->
	  let lc = Types.valid env.types_map l s loc in
	  if lc <> [] then
	    Ty.tsum s lc, env
	  else
	    let env , l = 
	      List.fold_left 
		(fun (env, l) t -> 
		   let ty , env = of_puretype env create_var t in
		   env , ty::l) 
	      (env, []) l 
	    in
	    Ty.text (List.rev l) s, env

  let add_raw env x sx ty = 
    { env with var_map = M.add x (sx, ty) env.var_map }

  let add create_symb create_var =
    List.fold_left
      (fun env (l, pty) ->
	 let ty , env = of_puretype env create_var pty in
	 List.fold_left 
	   (fun env x -> let sx = create_symb x in add_raw env x sx ty)
	   env l)

  let add_var = add Symbols.var (fun () -> Ty.Tvar (Ty.fresh_var ()))

  let add_name = add Symbols.name Ty.fresh_empty_text

  let add_logics env loc ac lp ty = 
    let prof = Profile.of_logictype env.types_map ty in
    let lmap = 
      List.fold_left 
	(fun lmap -> Logics.add lmap prof loc ac) env.logics_map lp
    in
    {env with logics_map = lmap }

  let find {var_map=m} n = M.find n m

  let mem n {var_map=m} = M.mem n m

  let list_of {var_map=m} = M.fold (fun _ c acc -> c::acc) m []

  let add_type_decl env v id lc loc =  
    { env with types_map = Types.add env.types_map v id lc loc }

  let fresh_type env = Logics.fresh env.logics_map
      
end



let new_id = 
  let r = ref 0 in 
  let next () = 
    r := !r+1; !r 
  in next


let rec freevars_term acc t = match t.c.tt_desc with
  | TTvar x -> Sy.add x acc
  | TTapp (_,lt) -> List.fold_left freevars_term acc lt
  | TTinfix (t1,_,t2) | TTget(t1, t2) -> 
      List.fold_left freevars_term acc [t1; t2]
  | TTset(t1, t2, t3) ->
      List.fold_left freevars_term acc [t1; t2; t3]
  | _ -> acc
      
let freevars_atom a = match a.c with
  | TAeq lt | TAneq lt | TAle lt
  | TAlt lt | TAbuilt(_,lt) | TAdistinct lt ->
      List.fold_left freevars_term Sy.empty lt
  | TApred t -> freevars_term  Sy.empty t
  | _ -> Sy.empty
      
let rec freevars_form f = match f with
  | TFatom a -> freevars_atom a
  | TFop (_,lf) ->
      List.fold_left Sy.union Sy.empty 
	(List.map (fun f -> freevars_form f.c) lf)
  | TFforall qf | TFexists qf -> 
      let s = freevars_form qf.qf_form.c in
      List.fold_left (fun acc (s,_) -> Sy.remove s acc) s qf.qf_bvars
  | TFlet(up,v,t,f) -> freevars_term (Sy.remove v (freevars_form f.c)) t
  | TFnamed(_, f) -> freevars_form f.c

let symbol_of = function
    PPadd -> Symbols.Op Symbols.Plus
  | PPsub -> Symbols.Op Symbols.Minus
  | PPmul -> Symbols.Op Symbols.Mult
  | PPdiv -> Symbols.Op Symbols.Div
  | PPmod ->  Symbols.Op Symbols.Modulo
  | _ -> assert false  

let rec type_term env f = 
  let e,t = type_term_desc env f.pp_loc f.pp_desc in
  {c = { tt_desc = e ; tt_ty = t }; annot = new_id ()}

and type_term_desc env loc = function
  | PPconst ConstTrue -> 
      TTconst Ttrue, Ty.Tbool
  | PPconst ConstFalse -> 
      TTconst Tfalse, Ty.Tbool
  | PPconst ConstVoid -> 
      TTconst Tvoid, Ty.Tunit
  | PPconst (ConstInt n) -> 
      TTconst(Tint n), Ty.Tint
  | PPconst (ConstReal n) -> 
      TTconst(Treal n), Ty.Treal
  | PPconst (ConstBitv n) -> 
      TTconst(Tbitv n), Ty.Tbitv (String.length n)
  | PPvar p -> 
      begin
	try let s,t = Env.find env p in TTvar s , t
	with Not_found -> 
	  match Env.fresh_type env p loc with
	    | s, ([], ty) -> TTvar s , ty 
	    | _ -> error (ShouldBeApply p) loc
      end
  | PPapp(p,args) -> 
      begin
	let te_args = List.map (type_term env) args in
	let lt_args =  List.map (fun {c={tt_ty=t}} -> t) te_args in
	let s, (lt, t) = Env.fresh_type env p loc in
	try
	  List.iter2 Ty.unify lt lt_args; 
	  TTapp(s,te_args), t
	with 
	  | Ty.TypeClash(t1,t2) -> 
	      error (Unification(t1,t2)) loc
	  | Invalid_argument _ -> 
	      error (WrongNumberofArgs p) loc
      end
  | PPinfix(t1,(PPadd | PPsub | PPmul | PPdiv as op),t2) ->
      begin
	let s = symbol_of op in
	let te1 = type_term env t1 in
	let te2 = type_term env t2 in
	let ty1 = Ty.shorten te1.c.tt_ty in
	let ty2 = Ty.shorten te2.c.tt_ty in
	match ty1, ty2 with
	    Ty.Tint, Ty.Tint -> TTinfix(te1,s,te2) , ty1
	  | Ty.Treal, Ty.Treal -> TTinfix(te1,s,te2), ty2
	  | Ty.Tint, _ -> error (ShouldHaveType(ty2,Ty.Tint)) t2.pp_loc
	  | Ty.Treal, _ -> error (ShouldHaveType(ty2,Ty.Treal)) t2.pp_loc
	  | _ -> error (ShouldHaveTypeIntorReal ty1) t1.pp_loc
      end
 | PPinfix(t1, PPmod, t2) ->
      begin
	let s = symbol_of PPmod in
	let te1 = type_term env t1 in
	let te2 = type_term env t2 in
	let ty1 = Ty.shorten te1.c.tt_ty in
	let ty2 = Ty.shorten te2.c.tt_ty in
	match ty1, ty2 with
	    Ty.Tint, Ty.Tint -> TTinfix(te1,s,te2) , ty1
	  | _ -> error (ShouldHaveTypeInt ty1) t1.pp_loc
      end
  | PPprefix(PPneg, {pp_desc=PPconst (ConstInt n)}) -> 
      TTconst(Tint ("-"^n)), Ty.Tint
  | PPprefix(PPneg, {pp_desc=PPconst (ConstReal n)}) -> 
      TTconst(Treal (Num.minus_num n)), Ty.Treal
  | PPprefix(PPneg, e) -> 
	let te = type_term env e in
	let ty = Ty.shorten te.c.tt_ty in
	if ty<>Ty.Tint && ty<>Ty.Treal then
	  error (ShouldHaveTypeIntorReal ty) e.pp_loc;
	TTprefix(Symbols.Op Symbols.Minus, te), ty
  | PPconcat(t1, t2) ->
      begin
	let te1 = type_term env t1 in
	let te2 = type_term env t2 in
	let ty1 = Ty.shorten te1.c.tt_ty in
	let ty2 = Ty.shorten te2.c.tt_ty in
	match ty1, ty2 with
	    Ty.Tbitv n , Ty.Tbitv m -> TTconcat(te1, te2), Ty.Tbitv (n+m)
	  | Ty.Tbitv _ , _ -> error (ShouldHaveTypeBitv ty2) t2.pp_loc
	  | _ , Ty.Tbitv _ -> error (ShouldHaveTypeBitv ty1) t1.pp_loc
	  | _ -> error (ShouldHaveTypeBitv ty1) t1.pp_loc
      end
  | PPextract(e, ({pp_desc=PPconst(ConstInt i)} as ei),
	      ({pp_desc=PPconst(ConstInt j)} as ej)) ->
      begin
	let te = type_term env e in
	let tye = Ty.shorten te.c.tt_ty in
	let i = int_of_string i in
	let j = int_of_string j in
	match tye with
	    Ty.Tbitv n -> 
	      if i>j then error (BitvExtract(i,j)) loc;
	      if j>=n then error (BitvExtractRange(n,j) ) loc;
	      let tei = type_term env ei in
	      let tej = type_term env ej in
	      TTextract(te, tei, tej), Ty.Tbitv (j-i+1)
	  | _ -> error (ShouldHaveType(tye,Ty.Tbitv (j+1))) loc
      end
  | PPget (t1, t2) ->
      begin
	let te1 = type_term env t1 in
	let te2 = type_term env t2 in
	let tyarray = Ty.shorten te1.c.tt_ty in
	let tykey2 = Ty.shorten te2.c.tt_ty in
	match tyarray with
	    Ty.Tfarray (tykey,tyval) ->
	      begin try
	              Ty.unify tykey tykey2;
                      TTget(te1, te2), tyval
	        with
	          | Ty.TypeClash(t1,t2) ->
	            error (Unification(t1,t2)) loc
              end
	  | _ ->
	    error ShouldHaveTypeArray t1.pp_loc
      end
  | PPset (t1, t2, t3) ->
      begin
	let te1 = type_term env t1 in
	let te2 = type_term env t2 in
	let te3 = type_term env t3 in
	let ty1 = Ty.shorten te1.c.tt_ty in
	let tykey2 = Ty.shorten te2.c.tt_ty in
	let tyval2 = Ty.shorten te3.c.tt_ty in
	try
	  match ty1 with
	    | Ty.Tfarray (tykey,tyval) ->
		Ty.unify tykey tykey2;Ty.unify tyval tyval2;
		TTset(te1, te2, te3), ty1
	    | _ -> error ShouldHaveTypeArray t1.pp_loc
	with
	  | Ty.TypeClash(t, t') -> 
	      error (Unification(t, t')) loc
      end

  | PPif(t1,t2,t3) ->
      begin
	let te1 = type_term env t1 in
	let ty1 = Ty.shorten te1.c.tt_ty in
	if not (Ty.equal ty1 Ty.Tbool) then 
	  error (ShouldHaveType(ty1,Ty.Tbool)) t1.pp_loc;
	let te2 = type_term env t2 in
	let te3 = type_term env t3 in
	let ty2 = Ty.shorten te2.c.tt_ty in
	let ty3 = Ty.shorten te3.c.tt_ty in
	if not (Ty.equal ty2 ty3) then
	  error (ShouldHaveType(ty3,ty2)) t3.pp_loc;
	TTapp(Symbols.name "ite",[te1;te2;te3]) , ty2
      end
  | PPnamed(lbl, t) -> 
      let t = type_term env t in
      t.c.tt_desc, t.c.tt_ty

  | PPlet(x,t1,t2) ->
      let te1 = type_term env t1 in
      let ty1 = Ty.shorten te1.c.tt_ty in
      let sx = Symbols.name x in
      let env = Env.add_raw env x sx ty1 in 
      let te2 = type_term env t2 in
      let ty2 = Ty.shorten te2.c.tt_ty in
      let s, _ = Env.find env x in
      TTlet(s, te1, te2), ty2
      
  | _ -> error SyntaxError loc


let rec join_forall f = match f.pp_desc with
    PPforall(vs,ty,trs1,f) -> 
      let tyvars,trs2,f = join_forall f in  
      (vs,ty)::tyvars , trs1@trs2 , f
  | PPnamed(lbl, f) -> 
      join_forall f
  | _ -> [] , [] , f

let rec join_exists f = match f.pp_desc with
  | PPexists (vars, ty, f) -> 
      let tyvars,f = join_exists f in  
      (vars, ty)::tyvars ,  f
  | PPnamed (_, f) -> join_exists f
  | _ -> [] , f

let make_le_or_lt p l = 
  let s = match p with PPle -> "<=" | PPlt -> "<" | _ -> assert false in
  try 
    let _ = Builtin.is_builtin s in 
    (match p with 
      | PPle -> TAle l
      | PPlt -> TAlt l
      | _ -> assert false)
  with Not_found -> 
    let s = Symbols.name s in (* XXX *)
    let t2 = {c={tt_desc=TTconst Ttrue;tt_ty=Ty.Tbool}; annot=new_id ()} in
    let t1 = {c={tt_desc=TTapp(s,l);tt_ty=Ty.Tbool}; annot=new_id ()} in 
    TAeq [t1;t2]

let rec type_form env f = 
  let form, vars = (match f.pp_desc with
    | PPconst ConstTrue -> 
      TFatom {c=TAtrue; annot=new_id ()}, Sy.empty
    | PPconst ConstFalse -> 
      TFatom {c=TAfalse; annot=new_id ()}, Sy.empty
    | PPvar p ->
      let r = begin
	match Env.fresh_type env p f.pp_loc with
	  | s, ([] ,Ty.Tbool) -> 
	    (try 
	       TFatom {c = TAbuilt(Builtin.is_builtin p,[]);
		       annot = new_id() }
	     with Not_found -> 
	       let t2 = {c = {tt_desc=TTconst Ttrue;tt_ty=Ty.Tbool};
			 annot = new_id ()} in
	       let t1 = {c = {tt_desc=TTvar s; tt_ty=Ty.Tbool};
			 annot = new_id ()} in
	       TFatom {c = TAeq [t1;t2]; annot=new_id ()})
	  | _ -> error (NotAPropVar p) f.pp_loc
      end in r, freevars_form r
	
    | PPapp(p,args )->
      let r = 
	begin
	  let te_args = List.map (type_term env) args in
	  let lt_args =  List.map (fun {c={tt_ty=t}} -> t) te_args in
	  match Env.fresh_type env p f.pp_loc with
	    | s , (lt,Ty.Tbool) -> 
	      begin
		try
		  List.iter2 Ty.unify lt lt_args;
		  (try 
		     TFatom { c = TAbuilt(Builtin.is_builtin p,te_args);
			      annot=new_id ()}
		   with Not_found -> 
		     let t1 = {c = {tt_desc=TTapp(s,te_args); tt_ty=Ty.Tbool};
			       annot=new_id ()} in
		     (* TFatom (TAeq[t1;{tt_desc=TTtrue;tt_ty=Ty.Tbool}]) *)
		     TFatom { c = TApred t1; annot=new_id () })
		with 
		    Ty.TypeClash(t1,t2) -> error (Unification(t1,t2)) f.pp_loc
		  | Invalid_argument _ -> error (WrongNumberofArgs p) f.pp_loc
	      end
	    | _ -> error (NotAPredicate p) f.pp_loc
	end 
      in r, freevars_form r
	
    | PPdistinct (args) ->
      let r = 
	begin
	  let te_args = List.map (type_term env) args in
	  let lt_args =  List.map (fun {c={tt_ty=t}} -> t) te_args in
	  try
	    let t = match lt_args with
	      | t::_ -> t
	      | [] ->
		  error (WrongNumberofArgs "distinct") f.pp_loc
	    in
	    List.iter (Ty.unify t) lt_args; 
	    TFatom { c = TAdistinct te_args; annot=new_id () }
	  with 
	    | Ty.TypeClash(t1,t2) -> error (Unification(t1,t2)) f.pp_loc
	end
      in r, freevars_form r

    | PPinfix 
	({pp_desc = PPinfix (_, (PPlt|PPle|PPgt|PPge|PPeq|PPneq), a)} as p, 
	 (PPlt | PPle | PPgt | PPge | PPeq | PPneq as r), b) ->
      let r = 
        let q = { pp_desc = PPinfix (a, r, b); pp_loc = f.pp_loc } in
        let f1,_ = type_form env p in
        let f2,_ = type_form env q in
        TFop(OPand, [f1;f2])
      in r, freevars_form r
    | PPinfix(t1, (PPlt | PPgt | PPle | PPge | PPeq | PPneq as op) ,t2) -> 
      let r = begin
	let tt1 = type_term env t1 in
	let tt2 = type_term env t2 in
	try
	  Ty.unify tt1.c.tt_ty tt2.c.tt_ty;
	  match op with
	    | PPeq -> TFatom {c = TAeq [tt1;tt2]; annot=new_id ()}
	    | PPneq -> TFatom {c = TAneq [tt1;tt2]; annot=new_id ()}
	    | _ ->
	      let ty = Ty.shorten tt1.c.tt_ty in
	      match ty with
		| Ty.Tint | Ty.Treal -> begin 
		  match op with
		    | PPle ->
		      TFatom {c = make_le_or_lt PPle [tt1;tt2];
			      annot = new_id ()}
		    | PPge ->
		      TFatom {c = make_le_or_lt PPle [tt2;tt1];
			      annot = new_id ()}
		    | PPlt -> begin match ty with
			| Ty.Tint -> 
			  let one = 
			    { c = {tt_ty = Ty.Tint ;
				   tt_desc = TTconst(Tint "1")};
				annot = new_id () } in
			  let desc = 
			    TTinfix(tt2, Symbols.Op Symbols.Minus,one)
			  in
			  TFatom { c = (make_le_or_lt PPle 
				  [tt1;{tt2 with c={tt2.c with tt_desc=desc}}]);
				   annot = new_id ()}
			| _ -> 
			  TFatom { c = make_le_or_lt PPlt [tt1;tt2];
				   annot = new_id ()}
		    end
		    | PPgt -> begin match ty with
			| Ty.Tint ->
			  let one = 
			    { c = {tt_ty = Ty.Tint ;
				   tt_desc = TTconst(Tint "1")};
				annot = new_id () } in
			  let desc = 
			    TTinfix(tt1, Symbols.Op Symbols.Minus, one) 
			  in
			  TFatom { c = (make_le_or_lt PPle
				 [tt2;{tt1 with c={tt1.c with tt_desc=desc}}]);
			      	   annot = new_id ()}
			| _ -> 
			  TFatom { c = make_le_or_lt PPlt [tt2;tt1];
				   annot = new_id () }
		    end
		    | _ -> assert false
		end
		| _ -> error (ShouldHaveTypeIntorReal ty) t1.pp_loc
	with Ty.TypeClash(t1,t2) -> error (Unification(t1,t2)) f.pp_loc
      end in r, freevars_form r
    | PPinfix(f1,op ,f2) -> 
      begin
	let f1,fv1 = type_form env f1 in
	let f2,fv2 = type_form env f2 in
	((match op with
	  | PPand -> 
	    TFop(OPand,[f1;f2])
	  | PPor -> TFop(OPor,[f1;f2])
	  | PPimplies -> TFop(OPimp,[f1;f2])
	  | PPiff -> TFop(OPiff,[f1;f2])
	  | _ -> assert false), Sy.union fv1 fv2)
      end
    | PPprefix(PPnot,f) -> 
      let f, fv = type_form env f in TFop(OPnot,[f]),fv
    | PPif(f1,f2,f3) -> 
      let f1 = type_term env f1 in
      let f2,fv2 = type_form env f2 in
      let f3,fv3 = type_form env f3 in
      TFop(OPif f1,[f2;f3]), Sy.union fv2 fv3
    | PPnamed(lbl,f) -> 
      let f, fv = type_form env f in
      let lbl = Hstring.make lbl in
      TFnamed(lbl, f), fv
    | PPforall _ | PPexists _ ->
      let ty_vars, ty, triggers, f' = 
	match f.pp_desc with 
	  | PPforall(vars,ty,triggers,f') -> 
	    let ty_vars, triggers', f' = join_forall f' in
	    (vars, ty)::ty_vars,ty ,triggers@triggers', f'
	  | PPexists(vars,ty,f') -> 
	    let ty_vars, f' = join_exists f' in
	    (vars, ty)::ty_vars, ty, [], f'
	  | _ -> assert false
      in
      let env' = Env.add_var env ty_vars in
      let f', fv = type_form env' f' in
      let ty_triggers = List.map (List.map (type_term env')) triggers in
      let upbvars = Env.list_of env in
      let bvars = 
	List.fold_left 
	  (fun acc (l,_) -> 
	    let tys = List.map (Env.find env') l in
	    let tys = List.filter (fun (s,_) -> Sy.mem s fv) tys in
	    tys @ acc) [] ty_vars in 
      let qf_form = {
	qf_upvars = upbvars ; 
	qf_bvars = bvars ;
	qf_triggers = ty_triggers ;
	qf_form = f'}
      in
      (match f.pp_desc with 
	  PPforall _ -> TFforall qf_form
	| _ -> Existantial.make qf_form), 
      (List.fold_left (fun acc (l,_) -> Sy.remove l acc) fv bvars)
    | PPlet (var,t,f) -> 
      let {c= { tt_ty = ttype }} as tt = type_term env t in
      let svar = Symbols.var var in
      let up = Env.list_of env in
      let env = {env with 
	Env.var_map = M.add var (svar, ttype) env.Env.var_map} in
      let f,fv = type_form env f in
      TFlet (up ,svar , tt, f), freevars_term (Sy.remove svar fv) tt
    | _ -> error ShouldHaveTypeProp f.pp_loc)
  in
  {c = form; annot = new_id ()}, vars


let make_rules loc f = match f.c with
  | TFforall {qf_bvars = vars; qf_form = {c = TFatom {c = TAeq [t1; t2]}}} ->
      {rwt_vars = vars; rwt_left = t1; rwt_right = t2}
  | TFatom {c = TAeq [t1; t2]} -> 
      {rwt_vars = []; rwt_left = t1; rwt_right = t2}
  | _ -> error SyntaxError loc


let fresh_var = 
  let cpt = ref 0 in
  fun x -> incr cpt; ("_"^x^(string_of_int !cpt))

let rec alpha_renaming s f =
  { f with pp_desc = alpha_rec s f.pp_desc }
and alpha_rec ((up, m) as s) f = 
  match f with
    | PPvar x ->
	begin 
	  try
	    let y = M.find x m in
	    PPvar y
	  with Not_found -> f 
	end
    | PPapp(k, l) -> 
	PPapp(k, List.map (alpha_renaming s) l)
    | PPdistinct l -> 
	PPdistinct (List.map (alpha_renaming s) l)
    | PPconst _ -> f
    | PPinfix(f1, op, f2) -> 
	let ff1 = alpha_renaming s f1 in
	let ff2 = alpha_renaming s f2 in
	PPinfix(ff1, op, ff2)
    | PPprefix(op, f1) ->
	PPprefix(op, alpha_renaming s f1)
    | PPget(f1,f2) ->
	let ff1 = alpha_renaming s f1 in
	let ff2 = alpha_renaming s f2 in
	PPget(ff1, ff2)
    | PPset(f1, f2, f3) ->
	let ff1 = alpha_renaming s f1 in
	let ff2 = alpha_renaming s f2 in
	let ff3 = alpha_renaming s f3 in
	PPset(ff1, ff2, ff3)
    | PPextract(f1, f2, f3) ->
	let ff1 = alpha_renaming s f1 in
	let ff2 = alpha_renaming s f2 in
	let ff3 = alpha_renaming s f3 in
	PPextract(ff1, ff2, ff3)
    | PPconcat(f1, f2) ->
	let ff1 = alpha_renaming s f1 in
	let ff2 = alpha_renaming s f2 in
	PPconcat(ff1, ff2)
    | PPif(f1, f2, f3) ->
	let ff1 = alpha_renaming s f1 in
	let ff2 = alpha_renaming s f2 in
	let ff3 = alpha_renaming s f3 in
	PPif(ff1, ff2, ff3)
    | PPnamed(n, f1) ->
	PPnamed(n, alpha_renaming s f1)
    | PPforall(xs, ty, trs, f1) ->
	let xs1, xs2 = List.partition (fun x -> S.mem x up) xs in
	let nv = List.map fresh_var xs1 in
	let m = List.fold_left2 (fun m x nx -> M.add x nx m) m xs1 nv in
	let xs = nv@xs2 in
	let up = List.fold_left (fun up x -> S.add x up) up xs in
	let s = (up, m) in
	let ff1 = alpha_renaming s f1 in
	let trs = List.map (List.map (alpha_renaming s)) trs in
	PPforall(xs, ty, trs, ff1)
    | PPlet(x, f1, f2) ->
	let s, x = 
	  if S.mem x up then
	    let nx = fresh_var x in
	    let m = M.add x nx m in
	    let up = S.add nx up in
	    (up, m), nx
	  else
	    (S.add x up, m), x
	in
	let ff1 = alpha_renaming s f1 in
	let ff2 = alpha_renaming s f2 in
	PPlet(x, ff1, ff2)
	
    | PPexists(lx, ty, f1) ->
	let s, lx = 
	  List.fold_left
	    (fun (s, lx) x ->
	       if S.mem x up then
		 let nx = fresh_var x in
		 let m = M.add x nx m in
		 let up = S.add nx up in
		 (up, m), nx :: lx
	       else
		 (S.add x up, m), x :: lx)
	    (s, []) lx
	in
	let ff1 = alpha_renaming s f1 in
	PPexists(lx, ty, ff1)
 
let alpha_renaming = alpha_renaming (S.empty, M.empty)

let inv_infix = function 
  | PPand -> PPor | PPor -> PPand | _ -> assert false

let rec elim_toplevel_forall env bnot f = 
  (* bnot = true : nombre impaire de not *)
  match f.pp_desc with
    | PPforall(lv,t,_,f) when bnot-> 
	elim_toplevel_forall (Env.add_name env [lv,t]) bnot f

    | PPinfix(f1,PPand,f2) when not bnot -> 
	let env , f1 = elim_toplevel_forall env false f1 in
	let env , f2 = elim_toplevel_forall env false f2 in
	env , { f with pp_desc = PPinfix(f1, PPand , f2)}
	
    | PPinfix(f1, PPor,f2) when bnot -> 
	let env , f1 = elim_toplevel_forall env true f1 in
	let env , f2 = elim_toplevel_forall env true f2 in
        env , { f with pp_desc = PPinfix(f1, PPand , f2)}

    | PPinfix(f1,PPimplies,f2) when bnot -> 
        let env , f1 = elim_toplevel_forall env false f1 in
	let env , f2 = elim_toplevel_forall env true f2 in
	  env , { f with pp_desc = PPinfix(f1,PPand,f2)}
	
    | PPprefix(PPnot,f) -> elim_toplevel_forall env (not bnot) f

    | _ when bnot -> 
	env , { f with pp_desc=PPprefix(PPnot,f)}

    | _  -> env , f


let rec intro_hypothesis env valid_mode f = 
  match f.pp_desc with
    | PPinfix(f1,PPimplies,f2) when valid_mode -> 
	let env, f1 = elim_toplevel_forall env (not valid_mode) f1 in
	let env, axioms , goal = intro_hypothesis env valid_mode f2 in
	env, f1::axioms , goal
    | PPforall(lv, ty, _, f) when valid_mode ->  
	intro_hypothesis (Env.add_name env [lv, ty]) valid_mode f
    | PPexists(lv, ty, f) when not valid_mode-> 
	intro_hypothesis (Env.add_name env [lv, ty]) valid_mode f
    | _ -> 
	let env , f = elim_toplevel_forall env valid_mode f in
	env , [] , f

(*
let rec move_up f = 
  { f with pp_desc = move_up_desc f.pp_desc }

and move_up_desc = function
  | PPinfix(f1,op,f2) ->
      PPinfix(move_up f1,op,move_up f2)
	
  | PPprefix(op,f1) ->
      PPprefix(op,move_up f1)
	
  | PPif(f1,f2,f3) ->
      PPif(move_up f1, move_up f2, move_up f3)
	
  | PPforall(lv1,t1,[],
	     ({pp_desc=
		  PPinfix(fl,op,({pp_desc=PPforall(lv2,t2,[],f2)} as ff))} 
		as fd)) ->
      let ff = { ff with pp_desc = PPinfix(fl,op,f2)} in
      let fd = {fd with pp_desc=PPforall(lv2,t2,[],ff)} in
      PPforall(lv1,t1,[],fd)
	
    | f -> f
*)

let fresh_axiom_name = 
  let cpt = ref 0 in fun () -> incr cpt; "_H"^(string_of_int !cpt)

let check_duplicate_params l =
  let rec loop l acc =
    match l with
      | [] -> ()
      | (loc,x,_)::rem ->
	  if List.mem x acc then
	    error (ClashParam x) loc
	  else loop rem (x::acc)
  in
  loop l []

let rec make_pred loc trs f = function
    [] ->  f
  | [x,t] ->
      { pp_desc = PPforall([x],t,trs,f) ; pp_loc = loc }
  | (x,t)::l -> 
      { pp_desc = PPforall([x],t,[],(make_pred loc trs f l)) ; 
	pp_loc = loc }

let rec max_terms acc f = 
  match f.pp_desc with
    | PPinfix(f1, ( PPand | PPor | PPimplies | PPiff ), f2) 
    | PPconcat(f1, f2) ->  
	let acc = max_terms acc f1 in
	max_terms acc f2

    | PPforall(_, _, _, _) 
    | PPexists(_, _, _) 
    | PPvar _ 
    | PPlet(_, _, _) 
    | PPinfix(_, _, _) -> raise Exit

    | PPif(f1, f2, f3) ->
	let acc = max_terms acc f1 in
	let acc = max_terms acc f2 in
	max_terms acc f3
    | PPextract(f1, _, _) | PPprefix(_, f1) 
    | PPnamed(_, f1) ->
	max_terms acc f1
    | _ -> f::acc

let max_terms f = try max_terms [] f with Exit -> []

let rec mono_term {c = {tt_ty=tt_ty; tt_desc=tt_desc}; annot = id} = 
  let tt_desc = match tt_desc with
    | TTconst _ | TTvar _ -> 
        tt_desc
    | TTinfix (t1, sy, t2) -> 
        TTinfix(mono_term t1, sy, mono_term t2)
    | TTprefix (sy,t) -> 
        TTprefix(sy, mono_term t)
    | TTapp (sy,tl) -> 
        TTapp (sy, List.map mono_term tl)
    | TTget (t1,t2) ->
        TTget (mono_term t1, mono_term t2)
    | TTset (t1,t2,t3) -> 
        TTset(mono_term t1, mono_term t2, mono_term t3)
    | TTextract (t1,t2,t3) -> 
        TTextract(mono_term t1, mono_term t2, mono_term t3)
    | TTconcat (t1,t2)->
        TTconcat (mono_term t1, mono_term t2)
    | TTlet (sy,t1,t2)-> 
        TTlet (sy, mono_term t1, mono_term t2)
  in 
  { c = {tt_ty = Ty.monomorphize tt_ty; tt_desc=tt_desc}; annot = id}
 

let monomorphize_atom tat =
  let c = match tat.c with 
    | TAtrue | TAfalse -> tat.c
    | TAeq tl -> TAeq (List.map mono_term tl)
    | TAneq tl -> TAneq (List.map mono_term tl)
    | TAle tl -> TAle (List.map mono_term tl)
    | TAlt tl -> TAlt (List.map mono_term tl)
    | TAdistinct tl -> TAdistinct (List.map mono_term tl)
    | TApred t -> TApred (mono_term t)
    | TAbuilt (hs, tl) -> TAbuilt(hs, List.map mono_term tl)
  in 
  { tat with c = c }

let rec monomorphize_form tf = 
  let c = match tf.c with
    | TFatom tat -> TFatom (monomorphize_atom tat)
    | TFop (oplogic , tfl) ->
        TFop(oplogic, List.map monomorphize_form tfl)
    | TFforall qf ->
        TFforall
          {qf with
             qf_form = monomorphize_form qf.qf_form;
             qf_triggers = List.map (List.map mono_term) qf.qf_triggers}

    | TFexists qf ->
        TFexists 
          {qf with
             qf_form = monomorphize_form qf.qf_form;
             qf_triggers = List.map (List.map mono_term) qf.qf_triggers}

    | TFlet (l, sy, tt, tf) ->
        TFlet(l,sy, mono_term tt, monomorphize_form tf)
    | TFnamed (hs,tf) ->
        TFnamed(hs, monomorphize_form tf)
  in 
  { tf with c = c }

let axioms_of_rules loc name lf acc env =
  let acc = 
    List.fold_left
      (fun acc (f, _) ->
        let f = Triggers.make false f in
        let name = (Common.fresh_string ()) ^ "_" ^ name in
        let td = {c = TAxiom(loc,name,f); annot = new_id () } in
	(td, env)::acc
      ) acc lf
  in 
  acc, env
      
let type_decl (acc, env) d = 
  try
    match d with
      | Logic (loc, ac, lp, ty) -> 
	  let env' = Env.add_logics env loc ac lp ty in
	  let td = {c = TLogic(loc,lp,ty); annot = new_id () } in
	  (td, env)::acc, env'

      | Axiom(loc,name,f) -> 
	  let f, _ = type_form env f in 
	  let f = Triggers.make false f in
	  let td = {c = TAxiom(loc,name,f); annot = new_id () } in
	  (td, env)::acc, env

      | Rewriting(loc, name, lr) -> 
	  let lf = List.map (type_form env) lr in
          if Options.rewriting then
            let rules = List.map (fun (f,_) -> make_rules loc f) lf in
	    let td = {c = TRewriting(loc, name, rules); annot = new_id () } in
	    (td, env)::acc, env
          else
            axioms_of_rules loc name lf acc env


      | Goal(loc,n,f) ->
	  (*let f = move_up f in*)
	  let f = alpha_renaming f in
	  let env', axioms, goal = 
	    intro_hypothesis env (not (!smtfile or !smt2file or !satmode)) f in
	  let acc =
	    List.fold_left
	      (fun acc f ->
		 let f,_ = type_form env' f in
		 let f = monomorphize_form f in
                 let f = Triggers.make false f in
		 let td = {c = TAxiom(loc, fresh_axiom_name(), f);
			   annot = new_id () } in
		 (td, env')::acc) acc axioms
	  in
	  let goal, _ = type_form env' goal in
          let goal = monomorphize_form goal in
	  let goal = Triggers.make true goal in
	  let td = {c = TGoal(loc, n, goal); annot = new_id () } in
	  (td, env')::acc, env

      | Predicate_def(loc,n,l,e) 
      | Function_def(loc,n,l,_,e) ->
	  check_duplicate_params l;
	  let ty = 
	    let l = List.map (fun (_,_,x) -> x) l in
	    match d with
		Function_def(_,_,_,t,_) -> PFunction(l,t) 
	      | _ -> PPredicate l 
	  in
	  let l = List.map (fun (_,x,t) -> (x,t)) l in

	  let env = Env.add_logics env loc Symbols.Other [n] ty in (* TODO *)

	  let lvar = List.map (fun (x,_) -> {pp_desc=PPvar x;pp_loc=loc}) l in
	  let p = {pp_desc=PPapp(n,lvar) ; pp_loc=loc } in
	  let infix = match d with Function_def _ -> PPeq | _ -> PPiff in
	  let f = { pp_desc = PPinfix(p,infix,e) ; pp_loc = loc } in
	  (* le trigger [[p]] ne permet pas de replier la definition,
	     donc on calcule les termes maximaux de la definition pour
	     laisser une possibilite de replier *)
	  let trs = max_terms e in
	  let f = make_pred loc ([p]::[trs]) f l in
	  let f,_ = type_form env f in
	  let f = Triggers.make false f in
	  let td = 
	    match d with 
	      | Function_def(_,_,_,t,_) -> TFunction_def(loc,n,l,t,f)
	      | _ ->  TPredicate_def(loc,n,l,f)
	  in
	  let td_a = { c = td; annot=new_id () } in
	  (td_a, env)::acc, env

      | TypeDecl(loc, ls, s, lc) -> 
	  let env1 = Env.add_type_decl env ls s lc loc in
	  let td1 =  TTypeDecl(loc, ls, s, lc) in
	  let td1_a = { c = td1; annot=new_id () } in
          let tls = List.map (fun s -> PPTvarid (s,loc)) ls in
	  let ty = PFunction([], PPTexternal(tls, s, loc)) in
	  let env2 = Env.add_logics env1 loc Symbols.Constructor lc ty in
	  let td2 = TLogic(loc, lc, ty) in
	  let td2_a = { c = td2; annot=new_id () } in
	  (td1_a, env1)::(td2_a,env2)::acc, env2

  with Warning(e,loc) -> 
    Loc.report loc; 
    acc, env

let file ld = 
  let ltd, _ = 
    List.fold_left 
      (fun acc d -> type_decl acc d)
      ([], Env.empty) ld
  in
  List.rev ltd

let split_goals l =
  let _, _, ret = 
    List.fold_left
      (fun (ctx, hyp, ret) ( (td, env) as x) -> 
	 match td.c with 
	   | TGoal _ -> ctx, [], (x::(hyp@ctx))::ret
	   | TAxiom (_, s, _) when String.length s > 0 && s.[0] = '_' ->
	       ctx, x::hyp, ret
	   | _ -> x::ctx, hyp, ret) ([],[],[]) l
  in 
  List.rev_map List.rev ret

let term env vars t =
  let vmap = 
    List.fold_left
      (fun m (s,ty)->
	 let str = Symbols.to_string s in
	 M.add str (s,ty) m
      ) env.Env.var_map vars in
  let env = { env with Env.var_map = vmap } in
  type_term env t



type env = Env.t
end
include (IMPLEMENTATION : INTERFACE)
end
and Matching: sig
#0 "matching.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type gsubst = { sbt : Term.subst ; gen : int ; goal : bool}

type pat_info = {
  pat_age : int ; 
  pat_orig : Formula.t ; 
  pat_formula : Formula.t ; 
  pat_dep : Explanation.t ;
}

type term_info = {
  term_age : int ; 
  term_from_goal : bool ;
  term_orig : Formula.t option
}

module type X = sig
  type t

  val class_of : t -> Term.t -> Term.t list
  val query : Literal.LT.t -> t -> Sig.answer
end

module type S = sig
  type t
  type uf

  val empty : t
  val add_term : term_info -> Term.t -> t -> t 
  val add_pat : pat_info * Term.t list -> t -> uf -> t
  val query : t -> uf -> (pat_info * gsubst list) list

end

module Make (X : X) : S with type uf = X.t
end = struct
let _ = Printf.fprintf stderr "Executing matching.ml\n%!"module type INTERFACE = sig
#0 "matching.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type gsubst = { sbt : Term.subst ; gen : int ; goal : bool}

type pat_info = {
  pat_age : int ; 
  pat_orig : Formula.t ; 
  pat_formula : Formula.t ; 
  pat_dep : Explanation.t ;
}

type term_info = {
  term_age : int ; 
  term_from_goal : bool ;
  term_orig : Formula.t option
}

module type X = sig
  type t

  val class_of : t -> Term.t -> Term.t list
  val query : Literal.LT.t -> t -> Sig.answer
end

module type S = sig
  type t
  type uf

  val empty : t
  val add_term : term_info -> Term.t -> t -> t 
  val add_pat : pat_info * Term.t list -> t -> uf -> t
  val query : t -> uf -> (pat_info * gsubst list) list

end

module Make (X : X) : S with type uf = X.t
end
module IMPLEMENTATION = struct
#0 "matching.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Format
open Options

module T = Term
module F = Formula

type gsubst = { 
  sbt : T.subst ; 
  gen : int ;     (* l'age d'une substitution est l'age du plus vieux 
		     terme qu'elle contient *)
  goal : bool     (* vrai si la substitution contient un terme ayant un lien 
		     avec le but de la PO *)
}

type pat_info = {
  pat_age : int ; (* age d'un trigger *)
  pat_orig : Formula.t ; (* lemme d'origine *)
  pat_formula : Formula.t ; (* formule associee au trigger *)
  pat_dep : Explanation.t ;
}

type term_info = {
  term_age : int ;   (* age du terme *)
  term_from_goal : bool ; (* vrai si le terme provient du but de la PO *)
  term_orig : Formula.t option (* lemme d'origine du terme *)
}

module type X = sig
  type t

  val class_of : t -> Term.t -> Term.t list
  val query : Literal.LT.t -> t -> Sig.answer

end

module type S = sig
  type t
  type uf

  val empty : t
  val add_term : term_info -> Term.t -> t -> t 
  val add_pat : pat_info * Term.t list -> t -> uf -> t
  val query : t -> uf -> (pat_info * gsubst list) list  
end

module Make (X : X) = struct

  type uf = X.t

  module MT = T.Map

  type info = {
    age : int ; (* age du terme *)
    lem_orig : F.t option ; (* lemme d'ou provient eventuellement le terme *)
    but : bool  (* le terme a-t-il un lien avec le but final de la PO *)
  }

  type t = { 
    fils : T.t list MT.t Subst.t ; 
    info : info MT.t ; 
    pats : (pat_info * Term.t list) list 
  }

  exception Echec
    
  module SubstT = Subst.Make(T)

  let empty = { 
    fils = SubstT.empty ; 
    info = MT.empty ;
    pats = [ ];
  }

  let age_limite = Options.age_limite
    (* l'age limite des termes, au dela ils ne sont pas consideres par le
       matching *)

  let infos op_gen op_but t g b env = 
    try 
      let i = MT.find t env.info in
      op_gen i.age g , op_but i.but b 
    with Not_found -> g , b

  let add_term { term_age = age; term_from_goal = but; term_orig = lem} t env =
    let rec add_rec env t = 
      let {T.f=f;xs=xs} = T.view t in
      let env = 
	let map_f = try SubstT.find f env.fils with Not_found -> MT.empty in
	
	(* - l'age d'un terme est le min entre l'age passe en argument
	   et l'age dans la map 
	   - un terme est en lien avec le but de la PO seulement s'il
	   ne peut etre produit autrement (d'ou le &&)
	   - le lemme de provenance est le dernier lemme
	*)
	let g , b = infos min (&&) t age but env in
	{ env with
	    fils = SubstT.add f (MT.add t xs map_f) env.fils; 
	    info= MT.add t {age=g; lem_orig=lem; but=b} env.info }
      in
      List.fold_left add_rec env xs
    in
    if age>age_limite then env else add_rec env t
      
  let add_pat p env _ = { env with pats = p::env.pats }

  exception Deja_vu
  let deja_vu lem1 = 
    function None -> false | Some lem2 -> F.compare lem1 lem2=0

  let all_terms f ty env pinfo {sbt=(s_t,s_ty); gen=g; goal=b} = 
    SubstT.fold 
      (fun k s l-> 
	 MT.fold 
	   (fun t _ l -> 
	      try
		let s_ty = Ty.matching s_ty ty (T.view t).T.ty in
		let ng , but = 
		  try 
		    let {age=ng;lem_orig=lem'; but=bt} = MT.find t env.info in
		    if deja_vu pinfo.pat_orig lem' then raise Deja_vu;
		    max ng g , bt or b
		  with Not_found -> g , b
		in
		{sbt=(SubstT.add f t s_t, s_ty);gen=ng; goal=but}::l
	      with Ty.TypeClash _ | Deja_vu-> l
	   )
	   s l)
      env.fils []

  let add_msymb uf f t ({sbt=(s_t,s_ty)} as sg)= 
    try 
      let t' = SubstT.find f s_t in
      let a = Literal.LT.make (Literal.Eq (t, t')) in
      if X.query a uf (*Explanation.singleton (Formula.mk_lit a)*) <> Sig.No
      then sg 
      else raise Echec
    with Not_found ->  {sg with sbt=(SubstT.add f t s_t,s_ty) }

(* ancien iter_exception: pas complet

  let rec iter_exception f gsb l = match l with
      []    -> raise Echec
    | xs::l -> try (f gsb xs) with Echec -> iter_exception f gsb l
*)	

  let rec iter_exception f gsb l =
    let l = 
      List.fold_left
        (fun acc xs -> try (f gsb xs) @ acc with Echec -> acc) [] l in
    match l with [] -> raise Echec | l  -> l
	
  let rec matchterm env uf ( {sbt=(s_t,s_ty);gen=g;goal=b} as sg) pat t =
    let {T.f=f_pat;xs=pats;ty=ty_pat} =  T.view pat in
    match f_pat with
	Symbols.Var _ -> 
	  let sb =
            (try
	       let s_ty = Ty.matching s_ty ty_pat (T.view t).T.ty in
	       let g',b' = infos max (||) t g b env in
	       add_msymb uf f_pat t {sbt=(s_t,s_ty);gen=g';goal=b'}
	     with Ty.TypeClash _ -> raise Echec)
          in 
          [sb]
      | _ -> 
	  let l = List.map T.view (X.class_of uf t) in
	  let s_ty , l = 
	    List.fold_left
	      (fun (s_ty,l) ({T.f=f;ty=ty_t} as t) -> 
		 if Symbols.compare f_pat f=0 then 
		   try
		     let s_ty = Ty.matching s_ty ty_pat ty_t in
		     s_ty , t::l 
		   with Ty.TypeClash _ -> s_ty , l
		 else s_ty , l
	      ) (s_ty,[]) l 
	  in
	  iter_exception (* pas sur que ce soit correct ici *)
	    (fun m {T.xs=xs} -> matchterms env uf m pats xs) 
	    { sg with sbt = (s_t,s_ty)} l
	  

  and matchterms env uf sg pats xs = 
    try List.fold_left2 
          (fun sb_l pt arg -> 
            let sb_ll = List.map (fun sg -> matchterm env uf sg pt arg) sb_l in
            List.flatten sb_ll
          )[sg] pats xs 
    with Invalid_argument _ -> raise Echec

  let matchpat env uf pat_info lsubst ({gen=g; goal=b} as sg,pat) = 
    let {T.f=f;xs=pats;ty=ty} = T.view pat in
    match f with
	Symbols.Var _ -> all_terms f ty env pat_info sg
      | _ -> 
	  try  
	    MT.fold 
	      (fun t xs l -> 
		 try 
		   let gen , but = infos max (||) t g b env in
		   (matchterms env uf
			{sg with gen=gen ; goal=but } pats xs) @ l 
		 with Echec -> l)
	      (SubstT.find f env.fils) lsubst
	  with Not_found -> lsubst
	    
  let matchpats env uf pat_info lsubsts pat = 
    let lpats = 
      List.map (fun sg -> (sg,T.apply_subst sg.sbt pat)) lsubsts in
    List.flatten (List.map (matchpat env uf pat_info []) lpats)

  let matching (pat_info, pats) env uf = 
    let egs = {sbt=(SubstT.empty,Ty.esubst) ; gen = 0; goal = false} in
    List.fold_left (matchpats env uf pat_info) [egs] pats

  let query env uf = 
    List.fold_left 
      (fun r ((pat_infos, pats) as v) -> (pat_infos, matching v env uf)::r)
      [] env.pats 
end
end
include (IMPLEMENTATION : INTERFACE)
end
and Sat: sig
#0 "sat.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type t

type gformula = { 
  f:Formula.t; 
  age: int; 
  name: Formula.t option; 
  mf: bool;
  gf: bool;
}

exception Sat of t
exception Unsat of Explanation.t
exception I_dont_know

(* the empty sat-solver context *)
val empty : t

(* [assume env f] assume a new formula [f] in [env]. Raises Unsat if
   [f] is unsatisfiable in [env] *)
val assume : t -> gformula -> t

(* [pred_def env f] assume a new predicate definition [f] in [env]. *)
val pred_def : t -> Formula.t -> t

(* [unsat env f size] checks the unsatisfiability of [f] in
   [env]. Raises I_dont_know when the proof tree's height reaches
   [size]. Raises Sat if [f] is satisfiable in [env] *)
val unsat : t -> gformula -> int -> Explanation.t

val start : unit -> unit
val stop : unit -> int64
end = struct
let _ = Printf.fprintf stderr "Executing sat.ml\n%!"module type INTERFACE = sig
#0 "sat.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

type t

type gformula = { 
  f:Formula.t; 
  age: int; 
  name: Formula.t option; 
  mf: bool;
  gf: bool;
}

exception Sat of t
exception Unsat of Explanation.t
exception I_dont_know

(* the empty sat-solver context *)
val empty : t

(* [assume env f] assume a new formula [f] in [env]. Raises Unsat if
   [f] is unsatisfiable in [env] *)
val assume : t -> gformula -> t

(* [pred_def env f] assume a new predicate definition [f] in [env]. *)
val pred_def : t -> Formula.t -> t

(* [unsat env f size] checks the unsatisfiability of [f] in
   [env]. Raises I_dont_know when the proof tree's height reaches
   [size]. Raises Sat if [f] is satisfiable in [env] *)
val unsat : t -> gformula -> int -> Explanation.t

val start : unit -> unit
val stop : unit -> int64
end
module IMPLEMENTATION = struct
#0 "sat.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Options
open Format
open Sig

module A = Literal
module CcX = Cc.Make(Combine.CX)
module F = Formula
module M = Matching.Make(CcX) 
module SF = F.Set
module MF = F.Map
module Ex = Explanation

let steps = ref 0L

type gformula = { 
  f: F.t; 
  age: int; 
  name: F.t option; 
  mf: bool;
  gf: bool
}

type t = { 
    gamma : Ex.t MF.t; 
    delta : (gformula * gformula * Ex.t) list;
    tbox : CcX.t;
    lemmas : (int * Ex.t) MF.t;
    definitions : (int * Ex.t) MF.t;
    matching : M.t
}
      
exception Sat of t
exception Unsat of Ex.t
exception I_dont_know
exception IUnsat of Ex.t

let max_max_size = 96

module Print = struct

  let assume {f=f;age=age;name=lem;mf=mf} dep = 
    if debug_sat then
      begin
	(match F.view f with
	    F.Unit _ -> ()
	      
	  | F.Clause _ -> 
	      printf "@[@{<C.Bold>[sat]@}";
	      printf "@{<C.G_Cyan>I assume a clause@} @[%a@]@]@." F.print f
		
	  | F.Lemma _ ->
	      printf "@[@{<C.Bold>[sat]@}";
	      printf "@{<C.G_Yellow>I assume a [%d-atom] lemma: @}" (F.size f);
	      printf "@[%a@]@]@." F.print f
		
	  | F.Literal a -> 
	      let s = 
		match lem with 
		    None -> "" 
		  | Some ff -> 
		      (match F.view ff with F.Lemma xx -> xx.F.name | _ -> "") 
	      in
	      printf "\n@[@{<C.Bold>[sat]@}";
	      printf "@{<C.G_Blue_B>I assume a literal@}";
	      printf "(%s) %a@]@." s Literal.LT.print a;
	      printf "================================================@.@."
		
	  | F.Skolem{F.sko_subst=(s,s_ty); sko_f=f} ->
	      printf "@[@{<C.Bold>[sat]@} I assume a skolem %a @]@." F.print f 
		
	  | F.Let {F.let_var=lvar; let_term=lterm; let_f=lf} ->
	      printf "@[@{<C.Bold>[sat]@} I assume a let %a =@ %a in@ %a@ @]@." 
		Symbols.print lvar Term.print lterm F.print lf);
	printf " with explanations : %a@." Explanation.print dep
      end

  let unsat () = 
    if debug_sat then printf "@[@{<C.Bold>[sat]@} @{<C.G_Red_B>unsat@}@]@."

  let mround s = 
    if debug_sat then 
      printf "@[@{<C.Bold>[sat]@} matching round of size %d@]@." s

  let decide f = 
    if debug_sat then 
      printf "@[@{<C.Bold>[sat]@} @{<C.G_Green>I decide@} on %a@]@." F.print f

  let backtracking f = 
    if debug_sat then 
      printf "@[@{<C.Bold>[sat]@} @{<C.G_Green>I backtrack@} on %a@]@." 
	F.print f

  let backjumping f = 
    if debug_sat then 
      (printf "@[@{<C.Bold>[sat]@} @{<C.G_Green>I don't consider the case @}";
       printf "%a@]@." F.print f)
       
  let elim _ _ = if debug_sat && verbose then printf "@[@{<C.Bold>[elim]@}@."

  let red _ _ = if debug_sat && verbose then printf "@[@{<C.Bold>[red]@}@."

  let delta d = 
    if debug_sat && verbose then begin
      printf "@[@{<C.Bold>[sat]@} - Delta ---------------------]@.";
      List.iter (fun (f1, f2, ex) ->
	printf "(%a or %a), %a@." F.print f1.f F.print f2.f Ex.print ex) d;
      printf "@[@{<C.Bold>[sat]@} --------------------- Delta -]@."
    end
    
  let gamma g =
    if debug_sat then begin
      printf "@[@{<C.Bold>[sat]@} - GAMMA ---------------------]@.";
      MF.iter (fun f ex ->
	printf "%a \t->\t%a@." F.print f Ex.print ex) g;
      printf "@[@{<C.Bold>[sat]@} --------------------- GAMMA -]@."
      
    end
      

end

(* matching part of the solver *)

let add_terms env s goal age lem = 
  let infos = { 
    Matching.term_age = age ; 
    term_from_goal = goal ;
    term_orig = lem ;
  }
  in
  { env with matching = Term.Set.fold (M.add_term infos) s env.matching }

(*exception EnoughLemmasAlready of int * (gformula * Ex.t) list*)

exception EnoughLemmasAlready of t * int

let b_max_size = 100

let rec double_until min s =
  let s2 = s + b_max_size in 
    if s2 >= min then s2 else double_until min s2

let mtriggers env formulas max_size = 
  let stop = ref false in
  try
    MF.fold
      (fun lem (age, dep) (env, max_size) ->
	 let size = F.size lem in
	 let max_size = 
	   if size <= max_size then max_size 
	   else 
	     begin
	       if !stop then raise (EnoughLemmasAlready(env, max_size));
	       stop:=true; double_until size max_size
	     end
	 in
	 let env = 
	   match F.view lem with
	       F.Lemma {F.triggers = tgs; main = f} -> 
		 List.fold_left 
		   (fun env tg ->
		      let info = 
			{ Matching.pat_age = age ; 
			  pat_orig = lem ;
			  pat_formula = f ;
			  pat_dep = dep }
		      in
		      { env with 
			  matching = 
			  M.add_pat (info, tg) env.matching env.tbox })
		   env tgs
	     | _ -> assert false		 
	 in 
	 (env, max_size)
      )
      formulas (env, max_size)
  with EnoughLemmasAlready(env, max_size) -> env, max_size

let new_facts mode env = 
  List.fold_left
    (fun acc ({Matching.pat_formula=f; 
	       pat_age=age; pat_dep=dep }, subst_list) ->
       List.fold_left
	 (fun acc {Matching.sbt=s;gen=g;goal=b} ->
	    if mode && not b then acc
	    else
	      begin
		let nf = F.apply_subst s f in
		if MF.mem nf env.gamma then acc else
		  let p = {f=nf;age=1+(max g age);name=Some f;mf=true;gf=b} in
		  (p,dep)::acc
	      end
	 ) 
	 acc subst_list
    )
    [] (M.query env.matching env.tbox)


let mround predicate mode env max_size =
  let round mode =
    Print.mround max_size;
    let axioms = if predicate then env.definitions else env.lemmas in
    let env, max_size = mtriggers env axioms max_size in
    let rec bouclage n (env, lf) = 
      if n <=0 then (env, lf)
      else 
        let env = 
	  List.fold_left 
	    (fun env (f,_) -> add_terms env (F.terms f.f) mode f.age None)
	    env lf
        in
        bouclage (n-1) (env, (new_facts mode env))
    in
    let _, lf = bouclage Options.bouclage (env, []) in
    max_size, lf 
  in
  let max_size, lf = round (mode || Options.goal_directed) in 
  if Options.goal_directed && lf = [] then round false 
  else max_size, lf
  

let extract_model t = 
  let s = ref SF.empty in
  MF.iter 
    (fun f _ -> 
       let lbl = F.label f in
       if not (Hstring.equal Hstring.empty lbl) then
	 s := SF.add f !s
    ) 
    t.gamma;
  !s

let print_model fmt s = 
  SF.iter (fprintf fmt "%a\n" F.print) s

(* sat-solver *)

let elim {f=f} env = 
  MF.mem f env.gamma ||
    match F.view f with 
      | F.Literal a -> CcX.query a env.tbox <> No
      | _ -> false

let size_formula = 1_000_000

let red {f=f} env = 
  let nf = F.mk_not f in
  try 
    Yes (MF.find nf env.gamma)
  with Not_found -> 
    match F.view nf with
      |	F.Literal a -> CcX.query a env.tbox
      | _ -> No

let pred_def env f = 
  let ff = {f=f;age=0;name=None;mf=false;gf=false} in
  Print.assume ff Explanation.empty;
  { env with definitions = MF.add f (0,Ex.empty) env.definitions }



let add_dep f dep =
  match F.view f with 
    | F.Literal _ when proof -> 
      if not (Ex.mem_as_bj f dep) then
	Ex.union (Ex.singleton ~bj:false f) dep
      else dep
    | _ -> dep
  

let rec add_dep_of_formula f dep =
  let dep = add_dep f dep in
  match F.view f with 
    | F.Unit (f1, f2) when proof ->
      add_dep_of_formula f2 (add_dep_of_formula f1 dep)
    | F.Clause _ when proof -> 
	Ex.union (Ex.singleton ~bj:false f) dep
    | _ -> dep


let rec assume env ({f=f;age=age;name=lem;mf=mf;gf=gf} as ff ,dep) =
  try
    let dep = add_dep f dep in
    let dep_gamma = add_dep_of_formula f dep in
    (try (* Print.gamma env.gamma; *)
	 (* fprintf fmt "ass:%a %a @." F.print (F.mk_not f) Ex.print dep_gamma; *)
       raise (IUnsat (Ex.union dep_gamma (MF.find (F.mk_not f) env.gamma)))
     with Not_found -> ());
    if MF.mem f env.gamma then env
    else 
      begin
	let size = F.size f in
	if size > size_formula then env
	else
	  let env =
	    if mf && glouton  && size < size_formula then 
	      add_terms env (F.terms f) gf age lem else env in
	  let env = { env with gamma = MF.add f dep_gamma env.gamma } in
	  Print.assume ff dep;
	  match F.view f with
	    | F.Unit (f1, f2) ->
	      let env = assume env 
		({ f = f1; age = age; name = lem; mf = mf; gf = gf }, dep) in
	      assume env 
		({ f = f2; age = age; name = lem; mf = mf; gf = gf }, dep) 
	    | F.Clause(f1,f2) -> 
	        (* let dep = Ex.union (Ex.singleton ~bj:false f) dep in *)
		let p1 = {f=f1;age=age;name=lem;mf=mf;gf=gf} in
		let p2 = {f=f2;age=age;name=lem;mf=mf;gf=gf} in
		bcp { env with delta = (p1,p2,dep)::env.delta }

	    | F.Lemma _ ->
	        (* let dep = Ex.union (Ex.singleton ~bj:false f) dep in *)
		let age , dep = 
		  try 
		    let age' , dep' = MF.find f env.lemmas in
		    min age age' , Ex.union dep dep' 
		  with Not_found -> age , dep 
		in
		bcp { env with lemmas=MF.add f (age,dep) env.lemmas }

	    | F.Literal a ->
	        (* let dep = Ex.union (Ex.singleton ~bj:false f) dep in *)
		let env = 
		  if mf && size < size_formula then 
		    add_terms env (A.LT.terms_of a) gf age lem
		  else env 
		in
		let tbox, cpt = CcX.assume a dep env.tbox in
		steps := Int64.add (Int64.of_int cpt) !steps;
		if stepsb <> -1 
		  && Int64.compare !steps (Int64.of_int stepsb) > 0 then 
		  begin 
		    printf "Steps limit reached: %Ld@." !steps;
		    exit 1
		  end;
		let env = { env with tbox = tbox } in
		bcp env

	    | F.Skolem{F.sko_subst=sigma; sko_f=f} -> 
		let f' = F.apply_subst sigma f in
		assume env ({f=f';age=age;name=lem;mf=mf;gf=gf},dep)

            | F.Let {F.let_var=lvar; let_term=lterm; let_subst=s; let_f=lf} ->
                let f' = F.apply_subst s lf in
		let id = F.id f' in
                let v = Symbols.Map.find lvar (fst s) in
                let env = assume env 
		  ({f=F.mk_lit (A.LT.make (A.Eq(v,lterm))) id;
		    age=age;name=lem;mf=mf;gf=gf},dep) 
		in
                assume env ({f=f';age=age;name=lem;mf=mf;gf=gf},dep)
      end
  with Exception.Inconsistent expl -> 
    if debug_sat then fprintf fmt "inconsistent %a@." Ex.print expl; 
    raise (IUnsat expl)
    
and bcp env =
  let cl , u = 
    List.fold_left 
      (fun (cl,u) ((f1,f2,d) as fd) -> 
         Print.elim f1 f2;
	 if elim f1 env || elim f2 env  then (cl,u)
	 else 
           (Print.red f1 f2;
	   match red f1 env with
	     | Yes d1 -> (cl,(f2,Ex.union d d1)::u)
	     | No -> 
		 match red f2 env with
		     Yes d2 -> (cl,(f1,Ex.union d d2)::u)
		   | No -> fd::cl , u)
      ) ([],[]) env.delta
  in
  List.fold_left assume {env with delta=cl} u
    
let rec unsat_rec env fg stop max_size = 
  try
    if stop < 0 then raise I_dont_know;
    back_tracking (assume env fg) stop max_size
  with IUnsat d-> Print.unsat (); d

and back_tracking env stop max_size =  match env.delta with
    []  when stop >= 0  -> 
      let _ , l2 = mround true false env max_max_size in 
      let env = List.fold_left assume env l2 in

      let max_size , l1 = mround false false env max_size in 
      let env = List.fold_left assume env l1 in

      let env = 
	List.fold_left 
	  (fun env ({f=f; age=g; name=lem; gf=gf},_) -> 
	     add_terms env (F.terms f) gf g lem) env l1 
      in
      (match l1, l2 with
	 | [], [] -> 
	     let m = extract_model env in
	     if all_models then 
	       begin
		 Format.printf "--- SAT ---\n";
		 Format.printf "%a@." print_model m;
		 raise (IUnsat (Ex.make_deps m))
	       end;
	     raise (Sat env)
	 | l1, l2 -> 
	     back_tracking 
	       (List.fold_left assume  (List.fold_left assume env l2) l1) 
	       (stop-1) (max_size + b_max_size))
  | [] -> 
      raise I_dont_know
  | ({f=f;age=g;name=lem;mf=mf} as a,b,d)::l -> 
      Print.decide f;
      let dep = unsat_rec {env with delta=l} (a,Ex.singleton f) stop max_size in
      if debug_sat then fprintf fmt "unsat_rec : %a@." Ex.print dep;
      try
	let dep' = Ex.remove f dep in
	Print.backtracking (F.mk_not f);
	unsat_rec
	  (assume {env with delta=l} (b, Ex.union d dep'))
	  ({a with f=F.mk_not f},dep') stop max_size
      with Not_found -> Print.backjumping (F.mk_not f); dep 
	
let unsat env fg stop = 
  try
    let env = assume env (fg,Ex.empty) in
    let env = add_terms env (F.terms fg.f) fg.gf fg.age fg.name in

    let _ , l = mround true false env max_max_size in
    let env = List.fold_left assume env l in

    let _ , l = mround false true env max_max_size in
    let env = List.fold_left assume env l in

    back_tracking env stop 100
  with IUnsat dep -> Print.unsat ();dep

let assume env fg = 
  try assume env (fg,Ex.empty) with IUnsat d -> raise (Unsat d)

let empty = { 
  gamma = MF.empty;
  delta = [] ;
  tbox = CcX.empty (); 
  lemmas = MF.empty ; 
  matching = M.empty;
  definitions = MF.empty
} 

let start () = steps := 0L
let stop () = !steps
end
include (IMPLEMENTATION : INTERFACE)
end
and Frontend: sig
#0 "frontend.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

module Time : sig

  val start: unit -> unit

  val get: unit -> float

end

type output = Unsat of Explanation.t | Inconsistent | Sat | Unknown


val process_decl:
  (Why_ptree.sat_tdecl -> output -> int64 -> 'a) ->
  Sat.t * bool * Explanation.t -> sat_tdecl ->
  Sat.t * bool * Explanation.t

val open_file:
  string -> Lexing.lexbuf -> 
  ((int tdecl, int) annoted * Why_typing.env) list list * Smt_ast.status

val processing:
  (Why_ptree.sat_tdecl -> output -> int64 -> 'a) -> 
  ((int tdecl, int) annoted * Why_typing.env) list list -> unit
end = struct
let _ = Printf.fprintf stderr "Executing frontend.ml\n%!"module type INTERFACE = sig
#0 "frontend.mli"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

module Time : sig

  val start: unit -> unit

  val get: unit -> float

end

type output = Unsat of Explanation.t | Inconsistent | Sat | Unknown


val process_decl:
  (Why_ptree.sat_tdecl -> output -> int64 -> 'a) ->
  Sat.t * bool * Explanation.t -> sat_tdecl ->
  Sat.t * bool * Explanation.t

val open_file:
  string -> Lexing.lexbuf -> 
  ((int tdecl, int) annoted * Why_typing.env) list list * Smt_ast.status

val processing:
  (Why_ptree.sat_tdecl -> output -> int64 -> 'a) -> 
  ((int tdecl, int) annoted * Why_typing.env) list list -> unit
end
module IMPLEMENTATION = struct
#0 "frontend.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree

let _ = 
  Sys.set_signal Sys.sigint 
    (Sys.Signal_handle 
       (fun _ -> print_endline "User wants me to stop."; exit 1))

open Lexing
open Format
open Options

module Time = struct

  open Unix
    
  let u = ref 0.0
    
  let start () = u:=(times()).tms_utime

  let get () = 
    let res = (times()).tms_utime -. !u in
    start();
    res

end

type output = Unsat of Explanation.t | Inconsistent | Sat | Unknown

let check_produced_proof dep =
  if verbose then 
    fprintf fmt "checking the proof:\n-------------------\n%a@." 
      Explanation.print_proof dep;

  try
    let env =
      (Formula.Set.fold
         (fun f env -> 
            Sat.assume env {Sat.f=f;age=0;name=None;mf=false;gf=false}
         ) (Explanation.formulas_of dep) Sat.empty)
    in
    raise (Sat.Sat env)
  with 
    | Sat.Unsat _  -> ()
    | (Sat.Sat _ | Sat.I_dont_know) as e -> raise e


let process_decl print_status (env, consistent, dep) d =
  try
    match d.st_decl with
      | Assume(f,mf) -> 
	  Sat.assume env {Sat.f=f;age=0;name=None;mf=mf;gf=false},
	  consistent, dep

      |	PredDef f -> 
	Sat.pred_def env f , consistent, dep

      | RwtDef r -> assert false

      | Query(n, f, lits)-> 
	  let dep = 
	    if consistent then
	      let dep' = Sat.unsat env 
		{Sat.f=f;age=0;name=None;mf=true;gf=true} stopb in
	      Explanation.union dep' dep
	    else dep
          in
          if debug_proof then check_produced_proof dep;
	  print_status d (Unsat dep) (Sat.stop ());
	  env, consistent, dep
  with 
    | Sat.Sat _ -> 
	print_status d Sat (Sat.stop ());
	env , consistent, dep
    | Sat.Unsat dep' -> 
        let dep = Explanation.union dep dep' in
        if debug_proof then check_produced_proof dep;
	print_status d Inconsistent (Sat.stop ());
	env , false, dep
    | Sat.I_dont_know -> 
	print_status d Unknown (Sat.stop ());
	env , consistent, dep

let get_smt_prelude () =
  let libdir =
    try Sys.getenv "ERGOLIB"
    with Not_found -> Version.libdir
  in
  let f = Filename.concat libdir "smt_prelude.mlw"
  in
  from_channel (open_in f)

let open_file file lb =
  let d ,status =
    if !smtfile then begin
      let _ = get_smt_prelude () in 
      (*let lp = Why_parser.file Why_lexer.token lb_prelude in*)
      let bname,l,status = Smt_parser.benchmark Smt_lex.token lb in
      if verbose then printf "converting smt file : ";
      let l = List.flatten (List.map Smt_to_why.bench_to_why l) in
      if verbose then printf "done.@.";
      if parse_only then exit 0;
      let ltd = Why_typing.file (l) in
      let lltd = Why_typing.split_goals ltd in
      lltd, status
    end
    else if !smt2file then begin
      let commands = Smtlib2_parse.main Smtlib2_lex.token lb in
      if verbose then printf "converting smt2 file : ";
      let l = Smtlib2_to_why.smt2_to_why commands in
      if verbose then printf "done.@.";
      if parse_only then exit 0;
      let ltd = Why_typing.file l in
      let lltd = Why_typing.split_goals ltd in
      lltd, Smt_ast.Unknown
    end
    else
      let a = Why_parser.file Why_lexer.token lb in
      if parse_only then exit 0;
      let ltd = Why_typing.file a in
      let lltd = Why_typing.split_goals ltd in
      lltd, Smt_ast.Unknown
  in
  if file <> " stdin" then close_in cin;
  if type_only then exit 0;
  d, status

let pruning = 
  List.map
    (fun d -> 
       if select > 0 then Pruning.split_and_prune select d 
       else [List.map (fun f -> f,true) d])
    
let processing report declss = 
  Sat.start ();
  let declss = List.map (List.map fst) declss in
  List.iter
    (List.iter 
       (fun dcl ->
	  let cnf = Cnf.make dcl in 
	  ignore (Queue.fold (process_decl report)
		    (Sat.empty, true, Explanation.empty) cnf)
       )) (pruning declss)
end
include (IMPLEMENTATION : INTERFACE)
end
and Main: sig
#0 "main.mli"
val print_status : Why_ptree.sat_tdecl -> Frontend.output -> int64 -> unit
val main : 'a -> unit
end = struct
let _ = Printf.fprintf stderr "Executing main.ml\n%!"module type INTERFACE = sig
#0 "main.mli"
val print_status : Why_ptree.sat_tdecl -> Frontend.output -> int64 -> unit
val main : 'a -> unit
end
module IMPLEMENTATION = struct
#0 "main.ml"
(**************************************************************************)
(*                                                                        *)
(*     The Alt-ergo theorem prover                                        *)
(*     Copyright (C) 2006-2010                                            *)
(*                                                                        *)
(*     Sylvain Conchon                                                    *)
(*     Evelyne Contejean                                                  *)
(*     Stephane Lescuyer                                                  *)
(*     Mohamed Iguernelala                                                *)
(*     Alain Mebsout                                                      *)
(*                                                                        *)
(*     CNRS - INRIA - Universite Paris Sud                                *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence     *)
(*                                                                        *)
(**************************************************************************)

open Why_ptree
open Frontend

open Lexing
open Format
open Options

let _ = 
  Sys.set_signal Sys.sigint 
    (Sys.Signal_handle 
       (fun _ -> print_endline "User wants me to stop."; exit 1))	  



let print_status d s steps =
  let satmode = !smtfile or !smt2file or !satmode in 
  match s with
    | Unsat dep -> 
	if not satmode then Loc.report d.st_loc;
	if satmode then printf "@{<C.F_Red>unsat@}@." 
	else printf "@{<C.F_Green>Valid@} (%2.4f) (%Ld)@." (Time.get()) steps;
	if proof && not debug_proof then 
          printf "Proof:\n%a@." Explanation.print_proof dep
	  
    | Inconsistent ->
	if not satmode then 
	  (Loc.report d.st_loc; 
	   fprintf fmt "Inconsistent assumption@.")
	else printf "unsat@."
	  
    | Unknown ->
	if not satmode then
	  (Loc.report d.st_loc; printf "I don't know.@.")
	else printf "unknown@."
	  
    | Sat  -> 
	if not satmode then Loc.report d.st_loc;
	if satmode then printf "unknown (sat)@." 
	else printf "I don't know@."



let main _ = 
  let lb = from_channel cin in 
  try 
    let d, status = open_file !file lb in 
    processing print_status d
  with
    | Why_lexer.Lexical_error s -> 
	Loc.report (lexeme_start_p lb, lexeme_end_p lb);
	printf "lexical error: %s\n@." s;
	exit 1
    | Parsing.Parse_error ->
	let  loc = (lexeme_start_p lb, lexeme_end_p lb) in
	Loc.report loc;
        printf "syntax error\n@.";
	exit 1
    | Common.Error(e,l) -> 
	Loc.report l; 
	printf "typing error: %a\n@." Common.report e;
	exit 1

let _ = main ();

end
include (IMPLEMENTATION : INTERFACE)
end
